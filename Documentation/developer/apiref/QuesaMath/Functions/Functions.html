<html><head><title>Functions</title></head><body background="../../../../images/logo_gray.gif" bgcolor="#ffffff"><font face="Geneva,Arial,Helvtica"><h1>Functions</h1></font><hr><br>
<a name="//apple_ref/c/func/Q3BoundingBox_Copy"></a>
<h3><a name="Q3BoundingBox_Copy">Q3BoundingBox_Copy</a></h3>
<blockquote><pre><tt>TQ3BoundingBox * 
Q3BoundingBox_Copy (
    const TQ3BoundingBox          *bBox,
    TQ3BoundingBox                *result
);
</tt><br>
</pre></blockquote>
<p>Copy a bounding box.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bBox</tt></td><td>Address of source bounding box.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of bounding box to set (may be the same as bBox).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingBox_Set"></a>
<h3><a name="Q3BoundingBox_Set">Q3BoundingBox_Set</a></h3>
<blockquote><pre><tt>TQ3BoundingBox * 
Q3BoundingBox_Set (
    TQ3BoundingBox                *bBox,
    const TQ3Point3D              *min,
    const TQ3Point3D              *max,
    TQ3Boolean                    isEmpty
);
</tt><br>
</pre></blockquote>
<p>Set a bounding box.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bBox</tt></td><td>Address of bounding box to set.</td></tr>
<tr valign=top><td><tt>min</tt></td><td>Address of point indicating minimum X, Y, and Z.</td></tr>
<tr valign=top><td><tt>max</tt></td><td>Address of point indicating maximum X, Y, and Z.</td></tr>
<tr valign=top><td><tt>isEmpty</tt></td><td>True of the bounding box is empty, false otherwise.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of bBox parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingBox_SetFromPoints3D"></a>
<h3><a name="Q3BoundingBox_SetFromPoints3D">Q3BoundingBox_SetFromPoints3D</a></h3>
<blockquote><pre><tt>TQ3BoundingBox * 
Q3BoundingBox_SetFromPoints3D (
    TQ3BoundingBox                *bBox,
    const TQ3Point3D              *points3D,
    TQ3Uns32                      numPoints,
    TQ3Uns32                      structSize
);
</tt><br>
</pre></blockquote>
<p>Set a bounding box to just enclose a set of 3D points.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bBox</tt></td><td>Address of bounding box to set.</td></tr>
<tr valign=top><td><tt>points3D</tt></td><td>Array of 3D points.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many points are in the array.</td></tr>
<tr valign=top><td><tt>structSize</tt></td><td>Size of each array element, typically sizeof(TQ3Point3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of bBox parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingBox_SetFromRationalPoints4D"></a>
<h3><a name="Q3BoundingBox_SetFromRationalPoints4D">Q3BoundingBox_SetFromRationalPoints4D</a></h3>
<blockquote><pre><tt>TQ3BoundingBox * 
Q3BoundingBox_SetFromRationalPoints4D (
    TQ3BoundingBox                *bBox,
    const TQ3RationalPoint4D      *rationalPoints4D,
    TQ3Uns32                      numPoints,
    TQ3Uns32                      structSize
);
</tt><br>
</pre></blockquote>
<p>Set a bounding box to just enclose a set of 4D rational points.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bBox</tt></td><td>Address of bounding box to set.</td></tr>
<tr valign=top><td><tt>rationalPoints4D</tt></td><td>Array of 4D rational points.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many points are in the array.</td></tr>
<tr valign=top><td><tt>structSize</tt></td><td>Size of each array element, typically sizeof(TQ3RationalPoint4D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of bBox parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingBox_Union"></a>
<h3><a name="Q3BoundingBox_Union">Q3BoundingBox_Union</a></h3>
<blockquote><pre><tt>TQ3BoundingBox * 
Q3BoundingBox_Union (
    const TQ3BoundingBox          *b1,
    const TQ3BoundingBox          *b2,
    TQ3BoundingBox                *result
);
</tt><br>
</pre></blockquote>
<p>Compute the minimum bounding box that encloses both 'b1' and 'b2'.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>b1</tt></td><td>Address of one bounding box.</td></tr>
<tr valign=top><td><tt>b2</tt></td><td>Address of another bounding box.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of bounding box to set (may be the same as b1 and/or b2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingBox_UnionPoint3D"></a>
<h3><a name="Q3BoundingBox_UnionPoint3D">Q3BoundingBox_UnionPoint3D</a></h3>
<blockquote><pre><tt>TQ3BoundingBox * 
Q3BoundingBox_UnionPoint3D (
    const TQ3BoundingBox          *bBox,
    const TQ3Point3D              *point3D,
    TQ3BoundingBox                *result
);
</tt><br>
</pre></blockquote>
<p>Return the minimum bounding box that encloses both 'bBox' and 'point3D'.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bBox</tt></td><td>Address of initial bounding box.</td></tr>
<tr valign=top><td><tt>point3D</tt></td><td>Address of a point to enclose.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of bounding box to set (may be the same as bBox).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingBox_UnionRationalPoint4D"></a>
<h3><a name="Q3BoundingBox_UnionRationalPoint4D">Q3BoundingBox_UnionRationalPoint4D</a></h3>
<blockquote><pre><tt>TQ3BoundingBox * 
Q3BoundingBox_UnionRationalPoint4D (
    const TQ3BoundingBox          *bBox,
    const TQ3RationalPoint4D      *rationalPoint4D,
    TQ3BoundingBox                *result
);
</tt><br>
</pre></blockquote>
<p>Return the minimum bounding box that encloses both 'bBox' and 'rationalPoint4D'.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bBox</tt></td><td>Address of initial bounding box.</td></tr>
<tr valign=top><td><tt>rationalPoint4D</tt></td><td>Address of a point to enclose.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of bounding box to set (may be the same as bBox).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingSphere_Copy"></a>
<h3><a name="Q3BoundingSphere_Copy">Q3BoundingSphere_Copy</a></h3>
<blockquote><pre><tt>TQ3BoundingSphere * 
Q3BoundingSphere_Copy (
    const TQ3BoundingSphere       *bSphere,
    TQ3BoundingSphere             *result
);
</tt><br>
</pre></blockquote>
<p>Copy a bounding sphere.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bSphere</tt></td><td>Address of source bounding sphere.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of bounding sphere to set (may be the same as bSphere).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingSphere_Set"></a>
<h3><a name="Q3BoundingSphere_Set">Q3BoundingSphere_Set</a></h3>
<blockquote><pre><tt>TQ3BoundingSphere * 
Q3BoundingSphere_Set (
    TQ3BoundingSphere             *bSphere,
    const TQ3Point3D              *origin,
    float                         radius,
    TQ3Boolean                    isEmpty
);
</tt><br>
</pre></blockquote>
<p>Set a bounding sphere.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bSphere</tt></td><td>Address of bounding sphere to set.</td></tr>
<tr valign=top><td><tt>origin</tt></td><td>Address of point indicating sphere origin.</td></tr>
<tr valign=top><td><tt>radius</tt></td><td>Sphere radius.</td></tr>
<tr valign=top><td><tt>isEmpty</tt></td><td>True of the bounding sphere is empty, false otherwise.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of bSphere parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingSphere_SetFromPoints3D"></a>
<h3><a name="Q3BoundingSphere_SetFromPoints3D">Q3BoundingSphere_SetFromPoints3D</a></h3>
<blockquote><pre><tt>TQ3BoundingSphere * 
Q3BoundingSphere_SetFromPoints3D (
    TQ3BoundingSphere             *bSphere,
    const TQ3Point3D              *points3D,
    TQ3Uns32                      numPoints,
    TQ3Uns32                      structSize
);
</tt><br>
</pre></blockquote>
<p>Set a bounding sphere to just enclose a set of 3D points.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bSphere</tt></td><td>Description of the parameter.</td></tr>
<tr valign=top><td><tt>points3D</tt></td><td>Array of 3D points.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many points are in the array.</td></tr>
<tr valign=top><td><tt>structSize</tt></td><td>Size of each array element, typically sizeof(TQ3Point3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of bSphere parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingSphere_SetFromRationalPoints4D"></a>
<h3><a name="Q3BoundingSphere_SetFromRationalPoints4D">Q3BoundingSphere_SetFromRationalPoints4D</a></h3>
<blockquote><pre><tt>TQ3BoundingSphere * 
Q3BoundingSphere_SetFromRationalPoints4D (
    TQ3BoundingSphere             *bSphere,
    const TQ3RationalPoint4D      *rationalPoints4D,
    TQ3Uns32                      numPoints,
    TQ3Uns32                      structSize
);
</tt><br>
</pre></blockquote>
<p>Set a bounding sphere to just enclose a set of 4D rational points.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bSphere</tt></td><td>Address of bounding sphere to set.</td></tr>
<tr valign=top><td><tt>rationalPoints4D</tt></td><td>Array of 4D rational points.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many points are in the array.</td></tr>
<tr valign=top><td><tt>structSize</tt></td><td>Size of each array element, typically sizeof(TQ3RationalPoint4D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of bSphere parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingSphere_Union"></a>
<h3><a name="Q3BoundingSphere_Union">Q3BoundingSphere_Union</a></h3>
<blockquote><pre><tt>TQ3BoundingSphere * 
Q3BoundingSphere_Union (
    const TQ3BoundingSphere       *s1,
    const TQ3BoundingSphere       *s2,
    TQ3BoundingSphere             *result
);
</tt><br>
</pre></blockquote>
<p>Compute the minimum bounding sphere that encloses both 's1' and 's2'.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>s1</tt></td><td>Address of one bounding sphere.</td></tr>
<tr valign=top><td><tt>s2</tt></td><td>Address of another bounding sphere.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of bounding sphere to set (may be the same as s1 and/or s2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingSphere_UnionPoint3D"></a>
<h3><a name="Q3BoundingSphere_UnionPoint3D">Q3BoundingSphere_UnionPoint3D</a></h3>
<blockquote><pre><tt>TQ3BoundingSphere * 
Q3BoundingSphere_UnionPoint3D (
    const TQ3BoundingSphere       *bSphere,
    const TQ3Point3D              *point3D,
    TQ3BoundingSphere             *result
);
</tt><br>
</pre></blockquote>
<p>Return the minimum bounding sphere that encloses both 'bSphere' and 'point3D'.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bSphere</tt></td><td>Address of initial bounding sphere.</td></tr>
<tr valign=top><td><tt>point3D</tt></td><td>Address of a point to enclose.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of bounding sphere to set (may be the same as bSphere).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingSphere_UnionRationalPoint4D"></a>
<h3><a name="Q3BoundingSphere_UnionRationalPoint4D">Q3BoundingSphere_UnionRationalPoint4D</a></h3>
<blockquote><pre><tt>TQ3BoundingSphere * 
Q3BoundingSphere_UnionRationalPoint4D (
    const TQ3BoundingSphere       *bSphere,
    const TQ3RationalPoint4D      *rationalPoint4D,
    TQ3BoundingSphere             *result
);
</tt><br>
</pre></blockquote>
<p>Return the minimum bounding sphere that encloses both 'bSphere' and 'rationalPoint4D'.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bSphere</tt></td><td>Address of initial bounding sphere.</td></tr>
<tr valign=top><td><tt>rationalPoint4D</tt></td><td>Address of a point to enclose.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of bounding sphere to set (may be the same as bSphere).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_Adjoint"></a>
<h3><a name="Q3Matrix3x3_Adjoint">Q3Matrix3x3_Adjoint</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_Adjoint (
    const TQ3Matrix3x3            *matrix3x3,
    TQ3Matrix3x3                  *result
);
</tt><br>
</pre></blockquote>
<p>Calculate adjoint of 3x3 matrix.
<br><br>
The adjoint of a matrix is a scalar multiple of the inverse of
the matrix. For some applications, the adjoint can be used in
place of the inverse. In particular:
<br><br>
adjoint(A) = determinant(A) * inverse(A)
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of a matrix to calculate the adjoint of.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of matrix to set (may be the same as matrix3x3).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_Copy"></a>
<h3><a name="Q3Matrix3x3_Copy">Q3Matrix3x3_Copy</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_Copy (
    const TQ3Matrix3x3            *matrix3x3,
    TQ3Matrix3x3                  *result
);
</tt><br>
</pre></blockquote>
<p>Copy a 3x3 matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of source matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of destination matrix (may be the same as matrix3x3).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_Determinant"></a>
<h3><a name="Q3Matrix3x3_Determinant">Q3Matrix3x3_Determinant</a></h3>
<blockquote><pre><tt>float  
Q3Matrix3x3_Determinant (
    const TQ3Matrix3x3            *matrix3x3
);
</tt><br>
</pre></blockquote>
<p>Return the determinant of 3x3 matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of a matrix.</td></tr>
</table>
</blockquote>
<b>Result:</b> Determinant of that matrix.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_Invert"></a>
<h3><a name="Q3Matrix3x3_Invert">Q3Matrix3x3_Invert</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_Invert (
    const TQ3Matrix3x3            *matrix3x3,
    TQ3Matrix3x3                  *result
);
</tt><br>
</pre></blockquote>
<p>Calculate the inverse of a 3x3 non-singular matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of non-singular matrix to invert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of matrix to set (may be the same as matrix3x3).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_Multiply"></a>
<h3><a name="Q3Matrix3x3_Multiply">Q3Matrix3x3_Multiply</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_Multiply (
    const TQ3Matrix3x3            *m1,
    const TQ3Matrix3x3            *m2,
    TQ3Matrix3x3                  *result
);
</tt><br>
</pre></blockquote>
<p>Multiply two 3x3 matrices.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>m1</tt></td><td>Address of first matrix.</td></tr>
<tr valign=top><td><tt>m2</tt></td><td>Address of second matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of matrix to set with m1*m2 (may be the same as m1 and/or m2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_SetIdentity"></a>
<h3><a name="Q3Matrix3x3_SetIdentity">Q3Matrix3x3_SetIdentity</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_SetIdentity (
    TQ3Matrix3x3                  *matrix3x3
);
</tt><br>
</pre></blockquote>
<p>Set a 3x3 matrix to the identity matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of matrix to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix3x3 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_SetRotate"></a>
<h3><a name="Q3Matrix3x3_SetRotate">Q3Matrix3x3_SetRotate</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_SetRotate (
    TQ3Matrix3x3                  *matrix3x3,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set a 3x3 matrix to rotate about the origin.
<br><br>
Not supported by QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix3x3 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_SetRotateAboutPoint"></a>
<h3><a name="Q3Matrix3x3_SetRotateAboutPoint">Q3Matrix3x3_SetRotateAboutPoint</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_SetRotateAboutPoint (
    TQ3Matrix3x3                  *matrix3x3,
    const TQ3Point2D              *origin,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set a 3x3 matrix to rotate about a point.
<br><br>
This is equivalent to translating the point to the origin,
doing a rotation about the origin, and translating back.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>origin</tt></td><td>Address of a 2D point about which to rotate.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix3x3 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_SetScale"></a>
<h3><a name="Q3Matrix3x3_SetScale">Q3Matrix3x3_SetScale</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_SetScale (
    TQ3Matrix3x3                  *matrix3x3,
    float                         xScale,
    float                         yScale
);
</tt><br>
</pre></blockquote>
<p>Set 3x3 matrix to scale in x, y.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>xScale</tt></td><td>Amount to scale in x.</td></tr>
<tr valign=top><td><tt>yScale</tt></td><td>Amount to scale in y.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix3x3 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_SetTranslate"></a>
<h3><a name="Q3Matrix3x3_SetTranslate">Q3Matrix3x3_SetTranslate</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_SetTranslate (
    TQ3Matrix3x3                  *matrix3x3,
    float                         xTrans,
    float                         yTrans
);
</tt><br>
</pre></blockquote>
<p>Set a 3x3 matrix to translate in x, y.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>xTrans</tt></td><td>Amount to translate in x.</td></tr>
<tr valign=top><td><tt>yTrans</tt></td><td>Amount to translate in y.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix3x3 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_Transpose"></a>
<h3><a name="Q3Matrix3x3_Transpose">Q3Matrix3x3_Transpose</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_Transpose (
    const TQ3Matrix3x3            *matrix3x3,
    TQ3Matrix3x3                  *result
);
</tt><br>
</pre></blockquote>
<p>Transpose a 3x3 matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of a matrix to transpose.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of matrix to set (may be the same as matrix3x3).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_Copy"></a>
<h3><a name="Q3Matrix4x4_Copy">Q3Matrix4x4_Copy</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_Copy (
    const TQ3Matrix4x4            *matrix4x4,
    TQ3Matrix4x4                  *result
);
</tt><br>
</pre></blockquote>
<p>Copy a 4x4 matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of source matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of destination matrix (may be the same as matrix4x4).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_Determinant"></a>
<h3><a name="Q3Matrix4x4_Determinant">Q3Matrix4x4_Determinant</a></h3>
<blockquote><pre><tt>float  
Q3Matrix4x4_Determinant (
    const TQ3Matrix4x4            *matrix4x4
);
</tt><br>
</pre></blockquote>
<p>Return the determinant of 4x4 matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of a matrix.</td></tr>
</table>
</blockquote>
<b>Result:</b> Determinant of that matrix.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_Invert"></a>
<h3><a name="Q3Matrix4x4_Invert">Q3Matrix4x4_Invert</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_Invert (
    const TQ3Matrix4x4            *matrix4x4,
    TQ3Matrix4x4                  *result
);
</tt><br>
</pre></blockquote>
<p>Calculate the inverse of a 4x4 non-singular matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of non-singular matrix to invert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of matrix to set (may be the same as matrix4x4).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_Multiply"></a>
<h3><a name="Q3Matrix4x4_Multiply">Q3Matrix4x4_Multiply</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_Multiply (
    const TQ3Matrix4x4            *m1,
    const TQ3Matrix4x4            *m2,
    TQ3Matrix4x4                  *result
);
</tt><br>
</pre></blockquote>
<p>Multiply two 4x4 matrices.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>m1</tt></td><td>Address of first matrix.</td></tr>
<tr valign=top><td><tt>m2</tt></td><td>Address of second matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of matrix to set with m1*m2 (may be the same as m1 and/or m2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetIdentity"></a>
<h3><a name="Q3Matrix4x4_SetIdentity">Q3Matrix4x4_SetIdentity</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetIdentity (
    TQ3Matrix4x4                  *matrix4x4
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix to the identity matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetQuaternion"></a>
<h3><a name="Q3Matrix4x4_SetQuaternion">Q3Matrix4x4_SetQuaternion</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetQuaternion (
    TQ3Matrix4x4                  *matrix4x4,
    const TQ3Quaternion           *quaternion
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix from to the rotation represented by a quaternion.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of the quaternion to imitate.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetRotateAboutAxis"></a>
<h3><a name="Q3Matrix4x4_SetRotateAboutAxis">Q3Matrix4x4_SetRotateAboutAxis</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetRotateAboutAxis (
    TQ3Matrix4x4                  *matrix4x4,
    const TQ3Point3D              *origin,
    const TQ3Vector3D             *axis,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set 4x4 matrix to rotate about an arbitrary origin and axis.
<br><br>
Note that for correct results, the axis should be normalized
(i.e. have length = 1).
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>origin</tt></td><td>Address of a 2D point about which to rotate.</td></tr>
<tr valign=top><td><tt>axis</tt></td><td>Address of a 3D vector to use as the rotation axis.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetRotateAboutPoint"></a>
<h3><a name="Q3Matrix4x4_SetRotateAboutPoint">Q3Matrix4x4_SetRotateAboutPoint</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetRotateAboutPoint (
    TQ3Matrix4x4                  *matrix4x4,
    const TQ3Point3D              *origin,
    float                         xAngle,
    float                         yAngle,
    float                         zAngle
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix to rotate about axes through apoint and 
parallel to the X, Y, and Z axes (in that order).
<br><br>
This order of rotations is rarely useful, but it's kept for backwards
compatibility with QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>origin</tt></td><td>Address of a 3D point about which to rotate.</td></tr>
<tr valign=top><td><tt>xAngle</tt></td><td>Angle to rotate about the translated X axis (in radians).</td></tr>
<tr valign=top><td><tt>yAngle</tt></td><td>Angle to rotate about the translated Y axis (in radians).</td></tr>
<tr valign=top><td><tt>zAngle</tt></td><td>Angle to rotate about the translated Z axis (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetRotateVectorToVector"></a>
<h3><a name="Q3Matrix4x4_SetRotateVectorToVector">Q3Matrix4x4_SetRotateVectorToVector</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetRotateVectorToVector (
    TQ3Matrix4x4                  *matrix4x4,
    const TQ3Vector3D             *v1,
    const TQ3Vector3D             *v2
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix to rotate vector 'v1' to 'v2'.
<br><br>
Note that for correct results, both vectors should be normalized
(i.e. have length = 1).
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>v1</tt></td><td>Address of "starting" vector.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of "ending" vector.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetRotate_X"></a>
<h3><a name="Q3Matrix4x4_SetRotate_X">Q3Matrix4x4_SetRotate_X</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetRotate_X (
    TQ3Matrix4x4                  *matrix4x4,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix to rotate about the X axis.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetRotate_XYZ"></a>
<h3><a name="Q3Matrix4x4_SetRotate_XYZ">Q3Matrix4x4_SetRotate_XYZ</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetRotate_XYZ (
    TQ3Matrix4x4                  *matrix4x4,
    float                         xAngle,
    float                         yAngle,
    float                         zAngle
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix to rotate about the X, Y, Z axes (in that order).
<br><br>
This order of rotations is rarely useful, but it's kept for backwards
compatibility with QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>xAngle</tt></td><td>Angle to rotate about the X axis (in radians).</td></tr>
<tr valign=top><td><tt>yAngle</tt></td><td>Angle to rotate about the Y axis (in radians).</td></tr>
<tr valign=top><td><tt>zAngle</tt></td><td>Angle to rotate about the Z axis (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetRotate_Y"></a>
<h3><a name="Q3Matrix4x4_SetRotate_Y">Q3Matrix4x4_SetRotate_Y</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetRotate_Y (
    TQ3Matrix4x4                  *matrix4x4,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix to rotate about the Y axis.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetRotate_Z"></a>
<h3><a name="Q3Matrix4x4_SetRotate_Z">Q3Matrix4x4_SetRotate_Z</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetRotate_Z (
    TQ3Matrix4x4                  *matrix4x4,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix to rotate about the Z axis.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetScale"></a>
<h3><a name="Q3Matrix4x4_SetScale">Q3Matrix4x4_SetScale</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetScale (
    TQ3Matrix4x4                  *matrix4x4,
    float                         xScale,
    float                         yScale,
    float                         zScale
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix to scale in x, y, z.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>xScale</tt></td><td>Amount to scale in x.</td></tr>
<tr valign=top><td><tt>yScale</tt></td><td>Amount to scale in y.</td></tr>
<tr valign=top><td><tt>zScale</tt></td><td>Amount to scale in z.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetTranslate"></a>
<h3><a name="Q3Matrix4x4_SetTranslate">Q3Matrix4x4_SetTranslate</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetTranslate (
    TQ3Matrix4x4                  *matrix4x4,
    float                         xTrans,
    float                         yTrans,
    float                         zTrans
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix to translate in x, y, z.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>xTrans</tt></td><td>Amount to translate in x.</td></tr>
<tr valign=top><td><tt>yTrans</tt></td><td>Amount to translate in y.</td></tr>
<tr valign=top><td><tt>zTrans</tt></td><td>Amount to translate in z.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_Transpose"></a>
<h3><a name="Q3Matrix4x4_Transpose">Q3Matrix4x4_Transpose</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_Transpose (
    const TQ3Matrix4x4            *matrix4x4,
    TQ3Matrix4x4                  *result
);
</tt><br>
</pre></blockquote>
<p>Transpose a 4x4 matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of a matrix to transpose.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of matrix to set (may be the same as matrix4x4).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Param2D_AffineComb"></a>
<h3><a name="Q3Param2D_AffineComb">Q3Param2D_AffineComb</a></h3>
<blockquote><pre><tt>TQ3Param2D * 
Q3Param2D_AffineComb (
    const TQ3Param2D              *params2D,
    const float                   *weights,
    TQ3Uns32                      numPoints,
    TQ3Param2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Return weighted combination of several 2D parameter points.
<br><br>
Provide an array of points and a parallel array of weights, and
this function will compute the weighted combination.  Note that
the weights are NOT required to sum to 1, but the sum must be
nonzero.
<br><br>
If you have only two points, use Q3Param2D_RRatio instead.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>params2D</tt></td><td>Array of 2D parameter points.</td></tr>
<tr valign=top><td><tt>weights</tt></td><td>Array of weights.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many elements there are in each array.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set with the weighted combination.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Param2D_Distance"></a>
<h3><a name="Q3Param2D_Distance">Q3Param2D_Distance</a></h3>
<blockquote><pre><tt>float  
Q3Param2D_Distance (
    const TQ3Param2D              *p1,
    const TQ3Param2D              *p2
);
</tt><br>
</pre></blockquote>
<p>Return Euclidean distance between two UV parameter points.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Distance between the given points.
 
<hr>
<a name="//apple_ref/c/func/Q3Param2D_DistanceSquared"></a>
<h3><a name="Q3Param2D_DistanceSquared">Q3Param2D_DistanceSquared</a></h3>
<blockquote><pre><tt>float  
Q3Param2D_DistanceSquared (
    const TQ3Param2D              *p1,
    const TQ3Param2D              *p2
);
</tt><br>
</pre></blockquote>
<p>Return the squared Euclidean distance between two UV parameter points.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Square of the distance between the given points.
 
<hr>
<a name="//apple_ref/c/func/Q3Param2D_RRatio"></a>
<h3><a name="Q3Param2D_RRatio">Q3Param2D_RRatio</a></h3>
<blockquote><pre><tt>TQ3Param2D * 
Q3Param2D_RRatio (
    const TQ3Param2D              *p1,
    const TQ3Param2D              *p2,
    float                         r1,
    float                         r2,
    TQ3Param2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Return the point at ratio r2/(r1+r2) along the line segment is
parameter (UV) space from p1 to p2.
<br><br>
Put another way, this function gives you the weighted average of points
p1 and p2, with the weights given by r1 and r2.  (Note that r1+r2 must
be nonzero.)
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of one end of a line segment.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of the other end of a line segment.</td></tr>
<tr valign=top><td><tt>r1</tt></td><td>Weight given to point p1.</td></tr>
<tr valign=top><td><tt>r2</tt></td><td>Weight given to point p2.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as p1 and/or p2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Param2D_Set"></a>
<h3><a name="Q3Param2D_Set">Q3Param2D_Set</a></h3>
<blockquote><pre><tt>TQ3Param2D * 
Q3Param2D_Set (
    TQ3Param2D                    *param2D,
    float                         u,
    float                         v
);
</tt><br>
</pre></blockquote>
<p>Set a 2D parameterization value (i.e., a UV coordinate).
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>param2D</tt></td><td>Address of param2D to set (may be NULL).</td></tr>
<tr valign=top><td><tt>u</tt></td><td>U coordinate to set into param2D.</td></tr>
<tr valign=top><td><tt>v</tt></td><td>V coordinate to set into param2D.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of param2D parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Param2D_Subtract"></a>
<h3><a name="Q3Param2D_Subtract">Q3Param2D_Subtract</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Param2D_Subtract (
    const TQ3Param2D              *p1,
    const TQ3Param2D              *p2,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Subtract 2D parametric point p2 from p1.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of a point.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of point to subtract.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of a vector to set with (p1-p2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Param2D_Transform"></a>
<h3><a name="Q3Param2D_Transform">Q3Param2D_Transform</a></h3>
<blockquote><pre><tt>TQ3Param2D * 
Q3Param2D_Transform (
    const TQ3Param2D              *param2D,
    const TQ3Matrix3x3            *matrix3x3,
    TQ3Param2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Transform a 2D parametric point by a 3x3 matrix.
<br><br>
A more extensive description can be supplied here, covering
the typical usage of this function and any special requirements.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point2D</tt></td><td>Address of a point to transform.</td></tr>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of a 3x3 transformation matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as point2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Param2D_Vector2D_Add"></a>
<h3><a name="Q3Param2D_Vector2D_Add">Q3Param2D_Vector2D_Add</a></h3>
<blockquote><pre><tt>TQ3Param2D * 
Q3Param2D_Vector2D_Add (
    const TQ3Param2D              *param2D,
    const TQ3Vector2D             *vector2D,
    TQ3Param2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Add a 2D vector to a parametric (UV) point.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>param2D</tt></td><td>Address of a 2D parametric point.</td></tr>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of a vector to add.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as param2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Param2D_Vector2D_Subtract"></a>
<h3><a name="Q3Param2D_Vector2D_Subtract">Q3Param2D_Vector2D_Subtract</a></h3>
<blockquote><pre><tt>TQ3Param2D * 
Q3Param2D_Vector2D_Subtract (
    const TQ3Param2D              *param2D,
    const TQ3Vector2D             *vector2D,
    TQ3Param2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Subtract a 2D vector from a parametric (UV) point.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>param2D</tt></td><td>Address of a 2D parametric point.</td></tr>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of a vector to subtract.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as param2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_AffineComb"></a>
<h3><a name="Q3Point2D_AffineComb">Q3Point2D_AffineComb</a></h3>
<blockquote><pre><tt>TQ3Point2D * 
Q3Point2D_AffineComb (
    const TQ3Point2D              *points2D,
    const float                   *weights,
    TQ3Uns32                      numPoints,
    TQ3Point2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Return weighted combination of several 2D points.
<br><br>
Provide an array of points and a parallel array of weights, and
this function will compute the weighted combination.  Note that
the weights are NOT required to sum to 1, but the sum must be
nonzero.
<br><br>
If you have only two points, use Q3Point2D_RRatio instead.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>points2D</tt></td><td>Array of 2D points.</td></tr>
<tr valign=top><td><tt>weights</tt></td><td>Array of weights.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many elements there are in each array.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set with the weighted combination.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_CrossProductTri"></a>
<h3><a name="Q3Point2D_CrossProductTri">Q3Point2D_CrossProductTri</a></h3>
<blockquote><pre><tt>float 
Q3Point2D_CrossProductTri (
    const TQ3Point2D              *p1,
    const TQ3Point2D              *p2,
    const TQ3Point2D              *p3
);
</tt><br>
</pre></blockquote>
<p>Return the length of the cross product of a triangle specified by
three 2D points, that is, of the vectors p2-p1 and p3-p2.
<br><br>
Not supported by QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of one point in the triangle.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of a second point in the triangle.</td></tr>
<tr valign=top><td><tt>p3</tt></td><td>Address of a third point in the triangle.</td></tr>
</table>
</blockquote>
<b>Result:</b> Length of (p2-p1) x (p3-p2).
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_Distance"></a>
<h3><a name="Q3Point2D_Distance">Q3Point2D_Distance</a></h3>
<blockquote><pre><tt>float  
Q3Point2D_Distance (
    const TQ3Point2D              *p1,
    const TQ3Point2D              *p2
);
</tt><br>
</pre></blockquote>
<p>Return Euclidean distance between two 2D points.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Distance between the given points.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_DistanceSquared"></a>
<h3><a name="Q3Point2D_DistanceSquared">Q3Point2D_DistanceSquared</a></h3>
<blockquote><pre><tt>float  
Q3Point2D_DistanceSquared (
    const TQ3Point2D              *p1,
    const TQ3Point2D              *p2
);
</tt><br>
</pre></blockquote>
<p>Return the squared Euclidean distance between two 2D points.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Square of the distance between the given points.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_RRatio"></a>
<h3><a name="Q3Point2D_RRatio">Q3Point2D_RRatio</a></h3>
<blockquote><pre><tt>TQ3Point2D * 
Q3Point2D_RRatio (
    const TQ3Point2D              *p1,
    const TQ3Point2D              *p2,
    float                         r1,
    float                         r2,
    TQ3Point2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Return the point at ratio r2/(r1+r2) along the line segment from p1 to p2.
<br><br>
Put another way, this function gives you the weighted average of points
p1 and p2, with the weights given by r1 and r2.  (Note that r1+r2 must
be nonzero.)
<br><br>
NOTE: The QD3D docs claim that the ratio used is r1/(r1+r2), but
it was found by direct experimentation that the QD3D library (1.6)
in fact uses r2/(r1+r2) instead.  This is as it should be, if r1 is
the weight of p1, and r2 is the weight of p2.
<br><br>
As usual, we do as QD3D does, not as the docs say.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of one end of a line segment.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of the other end of a line segment.</td></tr>
<tr valign=top><td><tt>r1</tt></td><td>Weight given to point p1.</td></tr>
<tr valign=top><td><tt>r2</tt></td><td>Weight given to point p2.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as p1 and/or p2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_Set"></a>
<h3><a name="Q3Point2D_Set">Q3Point2D_Set</a></h3>
<blockquote><pre><tt>TQ3Point2D * 
Q3Point2D_Set (
    TQ3Point2D                    *point2D,
    float                         x,
    float                         y
);
</tt><br>
</pre></blockquote>
<p>Set a 2D point.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point2D</tt></td><td>Address of point to set (may be NULL).</td></tr>
<tr valign=top><td><tt>x</tt></td><td>X coordinate to set into vector2D.</td></tr>
<tr valign=top><td><tt>y</tt></td><td>Y coordinate to set into vector2D.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of point2D parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_Subtract"></a>
<h3><a name="Q3Point2D_Subtract">Q3Point2D_Subtract</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Point2D_Subtract (
    const TQ3Point2D              *p1,
    const TQ3Point2D              *p2,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Subtract the 2D point p2 from p1.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of a point.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of point to subtract.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of a vector to set with (p1-p2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_To2DTransformArray"></a>
<h3><a name="Q3Point2D_To2DTransformArray">Q3Point2D_To2DTransformArray</a></h3>
<blockquote><pre><tt>TQ3Status  
Q3Point2D_To2DTransformArray (
    const TQ3Point2D              *inPoints2D,
    const TQ3Matrix3x3            *matrix3x3,
    TQ3Point2D                    *outPoints2D,
    TQ3Int32                      numPoints,
    TQ3Uns32                      inStructSize,
    TQ3Uns32                      outStructSize
);
</tt><br>
</pre></blockquote>
<p>Transform an array of 2D points by a 3x3 matrix.
<br><br>
When you have many points to transform, this is a more efficient
alternative to calling Q3Point2D_Transform repeatedly.
<br><br>
Not supported by QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>inPoints2D</tt></td><td>Array of 2D points to transform.</td></tr>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Transformation matrix.</td></tr>
<tr valign=top><td><tt>outPoints2D</tt></td><td>Array of points to receive output (may be the same as inPoints2D).</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many points are in each array.</td></tr>
<tr valign=top><td><tt>inStructSize</tt></td><td>Size of one element of the input array, typically sizeof(TQ3Point2D).</td></tr>
<tr valign=top><td><tt>outStructSize</tt></td><td>Size of one element of the output array, typically sizeof(TQ3Point2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> kQ3Success or some error code.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_To3D"></a>
<h3><a name="Q3Point2D_To3D">Q3Point2D_To3D</a></h3>
<blockquote><pre><tt>TQ3RationalPoint3D * 
Q3Point2D_To3D (
    const TQ3Point2D              *point2D,
    TQ3RationalPoint3D            *result
);
</tt><br>
</pre></blockquote>
<p>Convert 2D point to rational 3D, setting w to 1.
<br><br>
The Apple version incorrectly declares the type of 'result' to
be TQ3Point3D rather than TQ3RationalPoint3D. At a binary level
there is no difference, but at the source code level the Apple
version forces the use of the incorrect type or type casting.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point2D</tt></td><td>Address of 2D point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 3D rational point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_ToPolar"></a>
<h3><a name="Q3Point2D_ToPolar">Q3Point2D_ToPolar</a></h3>
<blockquote><pre><tt>TQ3PolarPoint * 
Q3Point2D_ToPolar (
    const TQ3Point2D              *point2D,
    TQ3PolarPoint                 *result
);
</tt><br>
</pre></blockquote>
<p>Convert 2D cartesian point to polar coordinates.
<br><br>
The angle (theta) here is measured counter-clockwise from the +x axis.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point2D</tt></td><td>Address of 2D point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of polar point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_Transform"></a>
<h3><a name="Q3Point2D_Transform">Q3Point2D_Transform</a></h3>
<blockquote><pre><tt>TQ3Point2D * 
Q3Point2D_Transform (
    const TQ3Point2D              *point2D,
    const TQ3Matrix3x3            *matrix3x3,
    TQ3Point2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Transform a 2D point by a 3x3 matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point2D</tt></td><td>Address of a point to transform.</td></tr>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of a 3x3 transformation matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as point2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_Vector2D_Add"></a>
<h3><a name="Q3Point2D_Vector2D_Add">Q3Point2D_Vector2D_Add</a></h3>
<blockquote><pre><tt>TQ3Point2D * 
Q3Point2D_Vector2D_Add (
    const TQ3Point2D              *point2D,
    const TQ3Vector2D             *vector2D,
    TQ3Point2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Add a 2D vector to a point.
<br><br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point2D</tt></td><td>Address of a point.</td></tr>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of a vector to add.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as point2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_Vector2D_Subtract"></a>
<h3><a name="Q3Point2D_Vector2D_Subtract">Q3Point2D_Vector2D_Subtract</a></h3>
<blockquote><pre><tt>TQ3Point2D * 
Q3Point2D_Vector2D_Subtract (
    const TQ3Point2D              *point2D,
    const TQ3Vector2D             *vector2D,
    TQ3Point2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Subtract a 2D vector from a point.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point2D</tt></td><td>Address of a point.</td></tr>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of a vector to subtract.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as point2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_AffineComb"></a>
<h3><a name="Q3Point3D_AffineComb">Q3Point3D_AffineComb</a></h3>
<blockquote><pre><tt>TQ3Point3D * 
Q3Point3D_AffineComb (
    const TQ3Point3D              *points3D,
    const float                   *weights,
    TQ3Uns32                      numPoints,
    TQ3Point3D                    *result
);
</tt><br>
</pre></blockquote>
<p>Return weighted combination of several 3D points.
<br><br>
Provide an array of points and a parallel array of weights, and
this function will compute the weighted combination.  Note that
the weights are NOT required to sum to 1, but the sum must be
nonzero.
<br><br>
If you have only two points, use Q3Point3D_RRatio instead.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>points3D</tt></td><td>Array of 3D points.</td></tr>
<tr valign=top><td><tt>weights</tt></td><td>Array of weights.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many elements there are in each array.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set with the weighted combination.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_CrossProductTri"></a>
<h3><a name="Q3Point3D_CrossProductTri">Q3Point3D_CrossProductTri</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Point3D_CrossProductTri (
    const TQ3Point3D              *p1,
    const TQ3Point3D              *p2,
    const TQ3Point3D              *p3,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Return the cross product of triangle triangle defined by three
3D points, that is, of the vectors p2-p1 and p3-p2.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of one point in the triangle.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of a second point in the triangle.</td></tr>
<tr valign=top><td><tt>p3</tt></td><td>Address of a third point in the triangle.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set with cross product (p2-p1) x (p3-p2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_Distance"></a>
<h3><a name="Q3Point3D_Distance">Q3Point3D_Distance</a></h3>
<blockquote><pre><tt>float  
Q3Point3D_Distance (
    const TQ3Point3D              *p1,
    const TQ3Point3D              *p2
);
</tt><br>
</pre></blockquote>
<p>Return Euclidean distance between two 3D points.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Distance between the given points.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_DistanceSquared"></a>
<h3><a name="Q3Point3D_DistanceSquared">Q3Point3D_DistanceSquared</a></h3>
<blockquote><pre><tt>float  
Q3Point3D_DistanceSquared (
    const TQ3Point3D              *p1,
    const TQ3Point3D              *p2
);
</tt><br>
</pre></blockquote>
<p>Return the squared Euclidean distance between two 3D points.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Square of the distance between the given points.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_RRatio"></a>
<h3><a name="Q3Point3D_RRatio">Q3Point3D_RRatio</a></h3>
<blockquote><pre><tt>TQ3Point3D * 
Q3Point3D_RRatio (
    const TQ3Point3D              *p1,
    const TQ3Point3D              *p2,
    float                         r1,
    float                         r2,
    TQ3Point3D                    *result
);
</tt><br>
</pre></blockquote>
<p>Return the point at ratio r2/(r1+r2) along the line segment from p1 to p2.
<br><br>
Put another way, this function gives you the weighted average of points
p1 and p2, with the weights given by r1 and r2.  (Note that r1+r2 must
be nonzero.)
<br><br>
NOTE: The QD3D docs claim that the ratio used is r1/(r1+r2), but
it was found by direct experimentation that the QD3D library (1.6)
in fact uses r2/(r1+r2) instead.  This is as it should be, if r1 is
the weight of p1, and r2 is the weight of p2.
<br><br>
As usual, we do as QD3D does, not as the docs say.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of one end of a line segment.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of the other end of a line segment.</td></tr>
<tr valign=top><td><tt>r1</tt></td><td>Weight given to point p1.</td></tr>
<tr valign=top><td><tt>r2</tt></td><td>Weight given to point p2.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as p1 and/or p2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_Set"></a>
<h3><a name="Q3Point3D_Set">Q3Point3D_Set</a></h3>
<blockquote><pre><tt>TQ3Point3D * 
Q3Point3D_Set (
    TQ3Point3D                    *point3D,
    float                         x,
    float                         y,
    float                         z
);
</tt><br>
</pre></blockquote>
<p>Set a 3D point.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point3D</tt></td><td>Address of point to set (may be NULL).</td></tr>
<tr valign=top><td><tt>x</tt></td><td>X coordinate to set into point3D.</td></tr>
<tr valign=top><td><tt>y</tt></td><td>Y coordinate to set into point3D.</td></tr>
<tr valign=top><td><tt>z</tt></td><td>Z coordinate to set into point3D.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of point3D parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_Subtract"></a>
<h3><a name="Q3Point3D_Subtract">Q3Point3D_Subtract</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Point3D_Subtract (
    const TQ3Point3D              *p1,
    const TQ3Point3D              *p2,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Subtract 3D point p2 from p1.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of a point.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of a point to subtract.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as p1 and/or p2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_To3DTransformArray"></a>
<h3><a name="Q3Point3D_To3DTransformArray">Q3Point3D_To3DTransformArray</a></h3>
<blockquote><pre><tt>TQ3Status  
Q3Point3D_To3DTransformArray (
    const TQ3Point3D              *inPoints3D,
    const TQ3Matrix4x4            *matrix4x4,
    TQ3Point3D                    *outPoints3D,
    TQ3Int32                      numPoints,
    TQ3Uns32                      inStructSize,
    TQ3Uns32                      outStructSize
);
</tt><br>
</pre></blockquote>
<p>Transform an array of 3D points by a 4x4 matrix.
<br><br>
When you have many points to transform, this is a more efficient
alternative to calling Q3Point3D_Transform repeatedly.
<br><br>
Not supported by QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>inPoints3D</tt></td><td>Array of 3D points to transform.</td></tr>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Transformation matrix.</td></tr>
<tr valign=top><td><tt>outPoints3D</tt></td><td>Array of points to receive output (may be the same as inPoints3D).</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many points are in each array.</td></tr>
<tr valign=top><td><tt>inStructSize</tt></td><td>Size of one element of the input array, typically sizeof(TQ3Point3D).</td></tr>
<tr valign=top><td><tt>outStructSize</tt></td><td>Size of one element of the output array, typically sizeof(TQ3Point3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> kQ3Success or some error code.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_To4D"></a>
<h3><a name="Q3Point3D_To4D">Q3Point3D_To4D</a></h3>
<blockquote><pre><tt>TQ3RationalPoint4D * 
Q3Point3D_To4D (
    const TQ3Point3D              *point3D,
    TQ3RationalPoint4D            *result
);
</tt><br>
</pre></blockquote>
<p>Convert 3D point to rational 4D, setting w to 1.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point3D</tt></td><td>Address of 3D point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of rational 4D point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_To4DTransformArray"></a>
<h3><a name="Q3Point3D_To4DTransformArray">Q3Point3D_To4DTransformArray</a></h3>
<blockquote><pre><tt>TQ3Status  
Q3Point3D_To4DTransformArray (
    const TQ3Point3D              *inPoints3D,
    const TQ3Matrix4x4            *matrix4x4,
    TQ3RationalPoint4D            *outRationalPoints4D,
    TQ3Int32                      numPoints,
    TQ3Uns32                      inStructSize,
    TQ3Uns32                      outStructSize
);
</tt><br>
</pre></blockquote>
<p>Transform an array of 3D points by a 4x4 matrix into 4D rational points.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>inPoints3D</tt></td><td>Array of 3D points to transform.</td></tr>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Transformation matrix.</td></tr>
<tr valign=top><td><tt>outRationalPoints4D</tt></td><td>Array of points to receive output.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many points are in each array.</td></tr>
<tr valign=top><td><tt>inStructSize</tt></td><td>Size of one element of the input array, typically sizeof(TQ3Point3D).</td></tr>
<tr valign=top><td><tt>outStructSize</tt></td><td>Size of one element of the output array, typically sizeof(TQ3RationalPoint4D).</td></tr>
</table>
</blockquote>
<b>Result:</b> kQ3Success or some error code.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_ToSpherical"></a>
<h3><a name="Q3Point3D_ToSpherical">Q3Point3D_ToSpherical</a></h3>
<blockquote><pre><tt>TQ3SphericalPoint * 
Q3Point3D_ToSpherical (
    const TQ3Point3D              *point3D,
    TQ3SphericalPoint             *result
);
</tt><br>
</pre></blockquote>
<p>Convert 3D cartesian point to spherical coordinates.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point3D</tt></td><td>Address of 3D cartesian point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of spherical-coordinates point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_Transform"></a>
<h3><a name="Q3Point3D_Transform">Q3Point3D_Transform</a></h3>
<blockquote><pre><tt>TQ3Point3D * 
Q3Point3D_Transform (
    const TQ3Point3D              *point3D,
    const TQ3Matrix4x4            *matrix4x4,
    TQ3Point3D                    *result
);
</tt><br>
</pre></blockquote>
<p>Transform a 3D point by a 4x4 matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point3D</tt></td><td>Address of a point to transform.</td></tr>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of a 4x4 transformation matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as point3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_TransformQuaternion"></a>
<h3><a name="Q3Point3D_TransformQuaternion">Q3Point3D_TransformQuaternion</a></h3>
<blockquote><pre><tt>TQ3Point3D * 
Q3Point3D_TransformQuaternion (
    const TQ3Point3D              *point3D,
    const TQ3Quaternion           *quaternion,
    TQ3Point3D                    *result
);
</tt><br>
</pre></blockquote>
<p>Transform a 3D point by a quaternion.
<br><br>
Note that for correct results, the quaternion should be normalized.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point3D</tt></td><td>Address of a point to transform.</td></tr>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to transform by.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of a point to set (may be the same as point3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_Vector3D_Add"></a>
<h3><a name="Q3Point3D_Vector3D_Add">Q3Point3D_Vector3D_Add</a></h3>
<blockquote><pre><tt>TQ3Point3D * 
Q3Point3D_Vector3D_Add (
    const TQ3Point3D              *point3D,
    const TQ3Vector3D             *vector3D,
    TQ3Point3D                    *result
);
</tt><br>
</pre></blockquote>
<p>Add a 3D vector to a point.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point3D</tt></td><td>Address of a point.</td></tr>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of a vector to add.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as point3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_Vector3D_Subtract"></a>
<h3><a name="Q3Point3D_Vector3D_Subtract">Q3Point3D_Vector3D_Subtract</a></h3>
<blockquote><pre><tt>TQ3Point3D * 
Q3Point3D_Vector3D_Subtract (
    const TQ3Point3D              *point3D,
    const TQ3Vector3D             *vector3D,
    TQ3Point3D                    *result
);
</tt><br>
</pre></blockquote>
<p>Subtract 3D vector from point.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point3D</tt></td><td>Address of a point.</td></tr>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of a vector to subtract.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as point3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3PolarPoint_Set"></a>
<h3><a name="Q3PolarPoint_Set">Q3PolarPoint_Set</a></h3>
<blockquote><pre><tt>TQ3PolarPoint * 
Q3PolarPoint_Set (
    TQ3PolarPoint                 *polarPoint,
    float                         r,
    float                         theta
);
</tt><br>
</pre></blockquote>
<p>Set a 2D polar-coordinates point.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>polarPoint</tt></td><td>Address of point to set (may be NULL).</td></tr>
<tr valign=top><td><tt>r</tt></td><td>Radius coordinate to set into polarPoint.</td></tr>
<tr valign=top><td><tt>theta</tt></td><td>Angle coordinate (in radians) to set into polarPoint.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of polarPoint parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3PolarPoint_ToPoint2D"></a>
<h3><a name="Q3PolarPoint_ToPoint2D">Q3PolarPoint_ToPoint2D</a></h3>
<blockquote><pre><tt>TQ3Point2D * 
Q3PolarPoint_ToPoint2D (
    const TQ3PolarPoint           *polarPoint,
    TQ3Point2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Convert 2D polar point to cartesian coordinates.
<br><br>
The angle (theta) here is measured counter-clockwise from the +x axis.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>polarPoint</tt></td><td>Address of polar point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 2D cartesian point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_Copy"></a>
<h3><a name="Q3Quaternion_Copy">Q3Quaternion_Copy</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_Copy (
    const TQ3Quaternion           *quaternion,
    TQ3Quaternion                 *result
);
</tt><br>
</pre></blockquote>
<p>Copy a quaternion.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of source quaternion.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of destination quaternion (may be the same as the first parameter).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_Dot"></a>
<h3><a name="Q3Quaternion_Dot">Q3Quaternion_Dot</a></h3>
<blockquote><pre><tt>float  
Q3Quaternion_Dot (
    const TQ3Quaternion           *q1,
    const TQ3Quaternion           *q2
);
</tt><br>
</pre></blockquote>
<p>Return the dot product of q1 and q2.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>q1</tt></td><td>Address of one quaternion.</td></tr>
<tr valign=top><td><tt>q2</tt></td><td>Address of another quaternion (may be the same as q1).</td></tr>
</table>
</blockquote>
<b>Result:</b> Dot product of q1 and q2.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_InterpolateFast"></a>
<h3><a name="Q3Quaternion_InterpolateFast">Q3Quaternion_InterpolateFast</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_InterpolateFast (
    const TQ3Quaternion           *q1,
    const TQ3Quaternion           *q2,
    float                         t,
    TQ3Quaternion                 *result
);
</tt><br>
</pre></blockquote>
<p>Compute a straight linear interpolation between two quaternions.
<br><br>
This does a true linear, not spherical, interpolation between
q1 and q2.  It's fast, but not very proper for most uses.
<br><br>
The result is automatically normalized, so there is no need to
do so yourself.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>q1</tt></td><td>Address of first quaternion.</td></tr>
<tr valign=top><td><tt>q2</tt></td><td>Address of second quaternion.</td></tr>
<tr valign=top><td><tt>t</tt></td><td>Fraction (0-1) of the way from q1 to q2.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of quaternion to set (may be the same as q1 and/or q2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_InterpolateLinear"></a>
<h3><a name="Q3Quaternion_InterpolateLinear">Q3Quaternion_InterpolateLinear</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_InterpolateLinear (
    const TQ3Quaternion           *q1,
    const TQ3Quaternion           *q2,
    float                         t,
    TQ3Quaternion                 *result
);
</tt><br>
</pre></blockquote>
<p>Compute a spherical linear interpolation between two quaternions.
<br><br>
Despite the name, this function does a SLERP (spherical linear
interpolation) from q1 to q2.
It falls back on a straight linear interpolation only when the
cosine of the angle between them is less than 0.01.
<br><br>
The cut-off point was chosen arbitrarily, and may not match
that of QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>q1</tt></td><td>Address of first quaternion.</td></tr>
<tr valign=top><td><tt>q2</tt></td><td>Address of second quaternion.</td></tr>
<tr valign=top><td><tt>t</tt></td><td>Fraction (0-1) of the way from q1 to q2.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of quaternion to set (may be the same as q1 and/or q2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_Invert"></a>
<h3><a name="Q3Quaternion_Invert">Q3Quaternion_Invert</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_Invert (
    const TQ3Quaternion           *quaternion,
    TQ3Quaternion                 *result
);
</tt><br>
</pre></blockquote>
<p>Invert a quaternion.
<br><br>
For correct results, the quaternion should be normalized
before inverting.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to invert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of quaternion to set (may be the same as the first parameter).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_IsIdentity"></a>
<h3><a name="Q3Quaternion_IsIdentity">Q3Quaternion_IsIdentity</a></h3>
<blockquote><pre><tt>TQ3Boolean  
Q3Quaternion_IsIdentity (
    const TQ3Quaternion           *quaternion
);
</tt><br>
</pre></blockquote>
<p>Return whether a quaternion is (roughly) the identity,
i.e., (1,0,0,0).
<br><br>
Values for x, y, and z are considered close enough to 0
if they are within FLT_EPSILON (a small number).
<br><br>
For correct results, the quaternion should first be normalized.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of quaternion to test.</td></tr>
</table>
</blockquote>
<b>Result:</b> True if quaternion is the identity.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_MatchReflection"></a>
<h3><a name="Q3Quaternion_MatchReflection">Q3Quaternion_MatchReflection</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_MatchReflection (
    const TQ3Quaternion           *q1,
    const TQ3Quaternion           *q2,
    TQ3Quaternion                 *result
);
</tt><br>
</pre></blockquote>
<p>Set result to either q1 or -q1, whichever produces a positive dot
product with q2 (i.e., whichever is "closer" to q2 in orientation).
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>q1</tt></td><td>Address of source quaternion.</td></tr>
<tr valign=top><td><tt>q2</tt></td><td>Address of quaternion to match.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of quaternion to set (may be the same as q1 and/or q2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_Multiply"></a>
<h3><a name="Q3Quaternion_Multiply">Q3Quaternion_Multiply</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_Multiply (
    const TQ3Quaternion           *q1,
    const TQ3Quaternion           *q2,
    TQ3Quaternion                 *result
);
</tt><br>
</pre></blockquote>
<p>Compute the product of two quaternions.
<br><br>
This is a very useful operation, since the rotation represented
by q1*q2 is exactly the same as rotating by q1 and then by q2.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>q1</tt></td><td>Address of first quaternion.</td></tr>
<tr valign=top><td><tt>q2</tt></td><td>Address of second quaternion.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of quaternion to set (may be the same as q1 and/or q2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_Normalize"></a>
<h3><a name="Q3Quaternion_Normalize">Q3Quaternion_Normalize</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_Normalize (
    const TQ3Quaternion           *quaternion,
    TQ3Quaternion                 *result
);
</tt><br>
</pre></blockquote>
<p>Scale a quaternion to length 1.
<br><br>
This is often needed when combining or interpolating between
quaternions, to keep accumulated error from causing your
quaternion values to "blow up".
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to normalize.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of quaternion to set (may be the same as the first parameter).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_Set"></a>
<h3><a name="Q3Quaternion_Set">Q3Quaternion_Set</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_Set (
    TQ3Quaternion                 *quaternion,
    float                         w,
    float                         x,
    float                         y,
    float                         z
);
</tt><br>
</pre></blockquote>
<p>Set a quaternion with its individual w, x, y, and z components.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to set.</td></tr>
<tr valign=top><td><tt>w</tt></td><td>Value for w component.</td></tr>
<tr valign=top><td><tt>x</tt></td><td>Value for x component.</td></tr>
<tr valign=top><td><tt>y</tt></td><td>Value for y component.</td></tr>
<tr valign=top><td><tt>z</tt></td><td>Value for z component.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of quaternion parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_SetIdentity"></a>
<h3><a name="Q3Quaternion_SetIdentity">Q3Quaternion_SetIdentity</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_SetIdentity (
    TQ3Quaternion                 *quaternion
);
</tt><br>
</pre></blockquote>
<p>Set a quaternion to the identity value (1,0,0,0).
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_SetMatrix"></a>
<h3><a name="Q3Quaternion_SetMatrix">Q3Quaternion_SetMatrix</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_SetMatrix (
    TQ3Quaternion                 *quaternion,
    const TQ3Matrix4x4            *matrix4x4
);
</tt><br>
</pre></blockquote>
<p>Set a quaternion from a 4x4 rotation matrix.
<br><br>
Note: The QD3D implementation of this function appears to be buggy.
This can be demonstrated by starting with an arbitrary
quaternion, converting to a matrix, then converting back (with
this function).
<br><br>
QD3D's result is something ridiculous; in Quesa, this function 
returns the original quaternion (or something equivalent).
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to set.</td></tr>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of a rotation matrix to imitate.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of quaternion parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_SetRotateAboutAxis"></a>
<h3><a name="Q3Quaternion_SetRotateAboutAxis">Q3Quaternion_SetRotateAboutAxis</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_SetRotateAboutAxis (
    TQ3Quaternion                 *quaternion,
    const TQ3Vector3D             *axis,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set quaternion to rotate about arbitrary axis.
<br><br>
Note that for correct results, the axis should be normalized
(i.e. have length = 1).
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to set.</td></tr>
<tr valign=top><td><tt>axis</tt></td><td>Address of a 3D vector to use as the rotation axis.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of quaternion parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_SetRotateVectorToVector"></a>
<h3><a name="Q3Quaternion_SetRotateVectorToVector">Q3Quaternion_SetRotateVectorToVector</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_SetRotateVectorToVector (
    TQ3Quaternion                 *quaternion,
    const TQ3Vector3D             *v1,
    const TQ3Vector3D             *v2
);
</tt><br>
</pre></blockquote>
<p>Set a quaternion to rotate vector 'v1' to 'v2'.
<br><br>
Note that for correct results, both vectors should be normalized
(i.e. have length = 1).
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to set.</td></tr>
<tr valign=top><td><tt>v1</tt></td><td>Address of "starting" vector.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of "ending" vector.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of quaternion parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_SetRotate_X"></a>
<h3><a name="Q3Quaternion_SetRotate_X">Q3Quaternion_SetRotate_X</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_SetRotate_X (
    TQ3Quaternion                 *quaternion,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set a quaternion to rotate about the X axis.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to set.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_SetRotate_XYZ"></a>
<h3><a name="Q3Quaternion_SetRotate_XYZ">Q3Quaternion_SetRotate_XYZ</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_SetRotate_XYZ (
    TQ3Quaternion                 *quaternion,
    float                         xAngle,
    float                         yAngle,
    float                         zAngle
);
</tt><br>
</pre></blockquote>
<p>Set a quaternion to rotate about the X, Y, and Z axes (in that order).
<br><br>
This order of rotations is rarely useful, but it's kept for backwards
compatibility with QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to set.</td></tr>
<tr valign=top><td><tt>xAngle</tt></td><td>Angle to rotate about the X axis (in radians).</td></tr>
<tr valign=top><td><tt>yAngle</tt></td><td>Angle to rotate about the Y axis (in radians).</td></tr>
<tr valign=top><td><tt>zAngle</tt></td><td>Angle to rotate about the Z axis (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of quaternion parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_SetRotate_Y"></a>
<h3><a name="Q3Quaternion_SetRotate_Y">Q3Quaternion_SetRotate_Y</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_SetRotate_Y (
    TQ3Quaternion                 *quaternion,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set a quaternion to rotate about the Y axis.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to set.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of quaternion parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_SetRotate_Z"></a>
<h3><a name="Q3Quaternion_SetRotate_Z">Q3Quaternion_SetRotate_Z</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_SetRotate_Z (
    TQ3Quaternion                 *quaternion,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set a quaternion to rotate about the Z axis.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to set.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of quaternion parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint3D_AffineComb"></a>
<h3><a name="Q3RationalPoint3D_AffineComb">Q3RationalPoint3D_AffineComb</a></h3>
<blockquote><pre><tt>TQ3RationalPoint3D * 
Q3RationalPoint3D_AffineComb (
    const TQ3RationalPoint3D      *rationalPoints3D,
    const float                   *weights,
    TQ3Uns32                      numPoints,
    TQ3RationalPoint3D            *result
);
</tt><br>
</pre></blockquote>
<p>Compute the weighted combination of several 3D rational points.
<br><br>
This operation makes no sense mathematically, but is included
for compatibility with QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoints3D</tt></td><td>Array of 3D rational points.</td></tr>
<tr valign=top><td><tt>weights</tt></td><td>Array of weights.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many elements there are in each array.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set with the weighted combination.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint3D_Distance"></a>
<h3><a name="Q3RationalPoint3D_Distance">Q3RationalPoint3D_Distance</a></h3>
<blockquote><pre><tt>float  
Q3RationalPoint3D_Distance (
    const TQ3RationalPoint3D      *p1,
    const TQ3RationalPoint3D      *p2
);
</tt><br>
</pre></blockquote>
<p>Returns the Euclidian distance between two rational 3D points.
<br><br>
This operation makes no sense mathematically, but is included
for backwards compatibility with QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Distance between the given points, treating
w as a spatial coordinate.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint3D_DistanceSquared"></a>
<h3><a name="Q3RationalPoint3D_DistanceSquared">Q3RationalPoint3D_DistanceSquared</a></h3>
<blockquote><pre><tt>float  
Q3RationalPoint3D_DistanceSquared (
    const TQ3RationalPoint3D      *p1,
    const TQ3RationalPoint3D      *p2
);
</tt><br>
</pre></blockquote>
<p>Returns the squared Euclidian distance between two rational 3D points.
<br><br>
This operation makes no sense mathematically, but is included
for backwards compatibility with QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Square of the distance between the given points, 
treating w as a spatial coordinate.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint3D_Set"></a>
<h3><a name="Q3RationalPoint3D_Set">Q3RationalPoint3D_Set</a></h3>
<blockquote><pre><tt>TQ3RationalPoint3D * 
Q3RationalPoint3D_Set (
    TQ3RationalPoint3D            *rationalPoint3D,
    float                         x,
    float                         y,
    float                         w
);
</tt><br>
</pre></blockquote>
<p>Set a 3D rational point (x,y,w).
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoint3D</tt></td><td>Address of rational point to set (may be NULL).</td></tr>
<tr valign=top><td><tt>x</tt></td><td>X coordinate to set into rationalPoint3D.</td></tr>
<tr valign=top><td><tt>y</tt></td><td>Y coordinate to set into rationalPoint3D.</td></tr>
<tr valign=top><td><tt>w</tt></td><td>W coordinate to set into rationalPoint3D.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of rationalPoint3D parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint3D_To2D"></a>
<h3><a name="Q3RationalPoint3D_To2D">Q3RationalPoint3D_To2D</a></h3>
<blockquote><pre><tt>TQ3Point2D * 
Q3RationalPoint3D_To2D (
    const TQ3RationalPoint3D      *rationalPoint3D,
    TQ3Point2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Convert rational 3D point to 2D, dividing by w.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoint3D</tt></td><td>Address of rational 3D point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 2D point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint3D_To3DTransformArray"></a>
<h3><a name="Q3RationalPoint3D_To3DTransformArray">Q3RationalPoint3D_To3DTransformArray</a></h3>
<blockquote><pre><tt>TQ3Status  
Q3RationalPoint3D_To3DTransformArray (
    const TQ3RationalPoint3D      *inRationalPoints3D,
    const TQ3Matrix3x3            *matrix3x3,
    TQ3RationalPoint3D            *outRationalPoints3D,
    TQ3Int32                      numPoints,
    TQ3Uns32                      inStructSize,
    TQ3Uns32                      outStructSize
);
</tt><br>
</pre></blockquote>
<p>Transform an array of 3D rational points by a 3x3 matrix.
<br><br>
When you have many points to transform, this is a more efficient
alternative to calling Q3RationalPoint3D_Transform repeatedly.
<br><br>
Not supported by QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>inRationalPoints3D</tt></td><td>Array of 3D rational points to transform.</td></tr>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Transformation matrix.</td></tr>
<tr valign=top><td><tt>outRationalPoints3D</tt></td><td>Array of points to receive output (may be the same as inRationalPoints3D).</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many points are in each array.</td></tr>
<tr valign=top><td><tt>inStructSize</tt></td><td>Size of one element of the input array, typically sizeof(TQ3RationalPoint3D).</td></tr>
<tr valign=top><td><tt>outStructSize</tt></td><td>Size of one element of the output array, typically sizeof(TQ3RationalPoint3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> kQ3Success or some error code.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint3D_ToVector2D"></a>
<h3><a name="Q3RationalPoint3D_ToVector2D">Q3RationalPoint3D_ToVector2D</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3RationalPoint3D_ToVector2D (
    const TQ3RationalPoint3D      *rationalPoint3D,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Convert 3D rational point to 2D vector, discarding w.
<br><br>
Not supported by QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoint3D</tt></td><td>Address of 3D rational point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 2D vector to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint3D_Transform"></a>
<h3><a name="Q3RationalPoint3D_Transform">Q3RationalPoint3D_Transform</a></h3>
<blockquote><pre><tt>TQ3RationalPoint3D * 
Q3RationalPoint3D_Transform (
    const TQ3RationalPoint3D      *rationalPoint3D,
    const TQ3Matrix3x3            *matri3x3,
    TQ3RationalPoint3D            *result
);
</tt><br>
</pre></blockquote>
<p>Transform 3D rational point by 3x3 matrix.
<br><br>
Not supported by QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoint3D</tt></td><td>Address of a point to transform.</td></tr>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of a 3x3 transformation matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as rationalPoint3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint4D_AffineComb"></a>
<h3><a name="Q3RationalPoint4D_AffineComb">Q3RationalPoint4D_AffineComb</a></h3>
<blockquote><pre><tt>TQ3RationalPoint4D * 
Q3RationalPoint4D_AffineComb (
    const TQ3RationalPoint4D      *rationalPoints4D,
    const float                   *weights,
    TQ3Uns32                      numPoints,
    TQ3RationalPoint4D            *result
);
</tt><br>
</pre></blockquote>
<p>Compute the weighted combination of several 4D rational points.
<br><br>
This operation makes no sense mathematically, but is included
for compatibility with QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoints4D</tt></td><td>Array of 4D rational points.</td></tr>
<tr valign=top><td><tt>weights</tt></td><td>Array of weights.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many elements there are in each array.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set with the weighted combination.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint4D_Distance"></a>
<h3><a name="Q3RationalPoint4D_Distance">Q3RationalPoint4D_Distance</a></h3>
<blockquote><pre><tt>float  
Q3RationalPoint4D_Distance (
    const TQ3RationalPoint4D      *p1,
    const TQ3RationalPoint4D      *p2
);
</tt><br>
</pre></blockquote>
<p>Returns the Euclidian distance between two rational 4D points.
<br><br>
This operation makes no sense mathematically, but is included
for backwards compatibility with QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Distance between the given points, treating
w as a spatial coordinate.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint4D_DistanceSquared"></a>
<h3><a name="Q3RationalPoint4D_DistanceSquared">Q3RationalPoint4D_DistanceSquared</a></h3>
<blockquote><pre><tt>float  
Q3RationalPoint4D_DistanceSquared (
    const TQ3RationalPoint4D      *p1,
    const TQ3RationalPoint4D      *p2
);
</tt><br>
</pre></blockquote>
<p>Returns the squared Euclidian distance between two rational 4D points.
<br><br>
This operation makes no sense mathematically, but is included
for backwards compatibility with QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Square of the distance between the given points, 
treating w as a spatial coordinate.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint4D_RRatio"></a>
<h3><a name="Q3RationalPoint4D_RRatio">Q3RationalPoint4D_RRatio</a></h3>
<blockquote><pre><tt>TQ3RationalPoint4D * 
Q3RationalPoint4D_RRatio (
    const TQ3RationalPoint4D      *p1,
    const TQ3RationalPoint4D      *p2,
    float                         r1,
    float                         r2,
    TQ3RationalPoint4D            *result
);
</tt><br>
</pre></blockquote>
<p>Return the point at ratio r2/(r1+r2) along the line segment from p1 to p2.
<br><br>
Put another way, this function gives you the weighted average of points
p1 and p2, with the weights given by r1 and r2.  (Note that r1+r2 must
be nonzero.)
<br><br>
NOTE: The QD3D docs claim that the ratio used is r1/(r1+r2), but
it was found by direct experimentation that the QD3D library (1.6)
in fact uses r2/(r1+r2) instead.  This is as it should be, if r1 is
the weight of p1, and r2 is the weight of p2.
<br><br>
As usual, we do as QD3D does, not as the docs say.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of one end of a line segment.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of the other end of a line segment.</td></tr>
<tr valign=top><td><tt>r1</tt></td><td>Weight given to point p1.</td></tr>
<tr valign=top><td><tt>r2</tt></td><td>Weight given to point p2.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as p1 and/or p2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint4D_Set"></a>
<h3><a name="Q3RationalPoint4D_Set">Q3RationalPoint4D_Set</a></h3>
<blockquote><pre><tt>TQ3RationalPoint4D * 
Q3RationalPoint4D_Set (
    TQ3RationalPoint4D            *rationalPoint4D,
    float                         x,
    float                         y,
    float                         z,
    float                         w
);
</tt><br>
</pre></blockquote>
<p>Set a 4D rational point (x,y,z,w).
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoint4D</tt></td><td>Address of rational point to set.</td></tr>
<tr valign=top><td><tt>x</tt></td><td>X coordinate to set into rationalPoint4D.</td></tr>
<tr valign=top><td><tt>y</tt></td><td>Y coordinate to set into rationalPoint4D.</td></tr>
<tr valign=top><td><tt>z</tt></td><td>Z coordinate to set into rationalPoint4D.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of rationalPoint4D parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint4D_To3D"></a>
<h3><a name="Q3RationalPoint4D_To3D">Q3RationalPoint4D_To3D</a></h3>
<blockquote><pre><tt>TQ3Point3D * 
Q3RationalPoint4D_To3D (
    const TQ3RationalPoint4D      *rationalPoint4D,
    TQ3Point3D                    *result
);
</tt><br>
</pre></blockquote>
<p>Convert rational 4D point to 3D, dividing by w.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoint4D</tt></td><td>Address of rational 4D point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 3D point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint4D_To4DTransformArray"></a>
<h3><a name="Q3RationalPoint4D_To4DTransformArray">Q3RationalPoint4D_To4DTransformArray</a></h3>
<blockquote><pre><tt>TQ3Status  
Q3RationalPoint4D_To4DTransformArray (
    const TQ3RationalPoint4D      *inRationalPoints4D,
    const TQ3Matrix4x4            *matrix4x4,
    TQ3RationalPoint4D            *outRationalPoints4D,
    TQ3Int32                      numPoints,
    TQ3Uns32                      inStructSize,
    TQ3Uns32                      outStructSize
);
</tt><br>
</pre></blockquote>
<p>Transform an array of 4D points by a 4x4 matrix.
<br><br>
When you have many points to transform, this is a more efficient
alternative to calling Q3RationalPoint4D_Transform repeatedly.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>inRationalPoints4D</tt></td><td>Array of 4D points to transform.</td></tr>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Transformation matrix.</td></tr>
<tr valign=top><td><tt>outRationalPoints4D</tt></td><td>Array of points to receive output (may be the same as inRationalPoints4D).</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many points are in each array.</td></tr>
<tr valign=top><td><tt>inStructSize</tt></td><td>Size of one element of the input array, typically sizeof(TQ3RationalPoint4D).</td></tr>
<tr valign=top><td><tt>outStructSize</tt></td><td>Size of one element of the output array, typically sizeof(TQ3RationalPoint4D).</td></tr>
</table>
</blockquote>
<b>Result:</b> kQ3Success or some error code.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint4D_ToVector3D"></a>
<h3><a name="Q3RationalPoint4D_ToVector3D">Q3RationalPoint4D_ToVector3D</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3RationalPoint4D_ToVector3D (
    const TQ3RationalPoint4D      *rationalPoint4D,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Convert 4D rational point to 3D vector, discarding w.
<br><br>
Not supported by QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoint4D</tt></td><td>Address of 4D rational point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 3D vector to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint4D_Transform"></a>
<h3><a name="Q3RationalPoint4D_Transform">Q3RationalPoint4D_Transform</a></h3>
<blockquote><pre><tt>TQ3RationalPoint4D * 
Q3RationalPoint4D_Transform (
    const TQ3RationalPoint4D      *rationalPoint4D,
    const TQ3Matrix4x4            *matrix4x4,
    TQ3RationalPoint4D            *result
);
</tt><br>
</pre></blockquote>
<p>Transform a 4D rational point by a 4x4 matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoint4D</tt></td><td>Address of a point to transform.</td></tr>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of a 4x4 transformation matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as rationalPoint4D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Ray3D_IntersectBoundingBox"></a>
<h3><a name="Q3Ray3D_IntersectBoundingBox">Q3Ray3D_IntersectBoundingBox</a></h3>
<blockquote><pre><tt>TQ3Boolean  
Q3Ray3D_IntersectBoundingBox (
    const TQ3Ray3D                *theRay,
    const TQ3BoundingBox          *theBounds,
    TQ3Point3D                    *hitPoint
);
</tt><br>
</pre></blockquote>
<p>Test a ray for intersection against a bounding box. If an
intersection occurs, the point of intersection is returned.
<br><br>
The direction vector of the ray must be normalised.
<br><br>
Not supported by QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>theRay</tt></td><td>The ray to test.</td></tr>
<tr valign=top><td><tt>theBounds</tt></td><td>The bounding box to test against.</td></tr>
<tr valign=top><td><tt>hitPoint</tt></td><td>Receives the intersection point, if found.</td></tr>
</table>
</blockquote>
<b>Result:</b> Indicates if the ray intersects the bounding box.
 
<hr>
<a name="//apple_ref/c/func/Q3Ray3D_IntersectSphere"></a>
<h3><a name="Q3Ray3D_IntersectSphere">Q3Ray3D_IntersectSphere</a></h3>
<blockquote><pre><tt>TQ3Boolean  
Q3Ray3D_IntersectSphere (
    const TQ3Ray3D                *theRay,
    const TQ3Sphere               *theSphere,
    TQ3Point3D                    *hitPoint
);
</tt><br>
</pre></blockquote>
<p>Test a ray for intersection against a sphere, and return the point
of intersection if found.
<br><br>
The direction vector of the ray must be normalised.
<br><br>
Not supported by QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>theRay</tt></td><td>The ray to test.</td></tr>
<tr valign=top><td><tt>theSphere</tt></td><td>The sphere to test against.</td></tr>
<tr valign=top><td><tt>hitPoint</tt></td><td>Receives the intersection point, if found.</td></tr>
</table>
</blockquote>
<b>Result:</b> Indicates if the ray intersects the sphere.
 
<hr>
<a name="//apple_ref/c/func/Q3Ray3D_IntersectTriangle"></a>
<h3><a name="Q3Ray3D_IntersectTriangle">Q3Ray3D_IntersectTriangle</a></h3>
<blockquote><pre><tt>TQ3Boolean  
Q3Ray3D_IntersectTriangle (
    const TQ3Ray3D                *theRay,
    const TQ3Point3D              *point1,
    const TQ3Point3D              *point2,
    const TQ3Point3D              *point3,
    TQ3Boolean                    cullBackfacing,
    TQ3Param3D                    *hitPoint
);
</tt><br>
</pre></blockquote>
<p>Test a ray for intersection against a triangle formed by three
points. If an intersection occurs, returns the barycentric
coordinates of the point of intersection and the distance along
the ray.
<br><br>
Triangles may optionally be subject to backface culling, in
which case a hit on the reverse side of the triangle will fail
to result in an intersection.
<br><br>
Barycentric coordinates can be used to interpolate the triangle
vertices to obtain the exact point of intersection, like so:
<br><br>
t = (1.0f - hitPoint.u - hitPoint.v);
x = (point1.x * t) + (point2.x * hitPoint.u) + (point3.x * hitPoint.v);
y = (point1.y * t) + (point2.y * hitPoint.u) + (point3.y * hitPoint.v);
z = (point1.z * t) + (point2.z * hitPoint.u) + (point3.z * hitPoint.v);
<br><br>
Similar calculations can be made for vertex normals, UVs, or any
other vertex attribute. The w component of hitPoint is set to the
distance along the ray at which the intersection occurs.
<br><br>
Not supported by QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>theRay</tt></td><td>The ray to test.</td></tr>
<tr valign=top><td><tt>point1</tt></td><td>The first triangle vertex.</td></tr>
<tr valign=top><td><tt>point2</tt></td><td>The second triangle vertex.</td></tr>
<tr valign=top><td><tt>point3</tt></td><td>The third triangle vertex.</td></tr>
<tr valign=top><td><tt>cullBackfacing</tt></td><td>Controls if back-facing triangles should be skipped.</td></tr>
<tr valign=top><td><tt>hitPoint</tt></td><td>Receives the barycentric coordinates of the intersection, and the distance along the ray.</td></tr>
</table>
</blockquote>
<b>Result:</b> Indicates if the ray intersects the triangle.
 
<hr>
<a name="//apple_ref/c/func/Q3SphericalPoint_Set"></a>
<h3><a name="Q3SphericalPoint_Set">Q3SphericalPoint_Set</a></h3>
<blockquote><pre><tt>TQ3SphericalPoint * 
Q3SphericalPoint_Set (
    TQ3SphericalPoint             *sphericalPoint,
    float                         rho,
    float                         theta,
    float                         phi
);
</tt><br>
</pre></blockquote>
<p>Set a 3D spherical-coordinates point.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>sphericalPoint</tt></td><td>Address of point to set (may be NULL).</td></tr>
<tr valign=top><td><tt>rho</tt></td><td>Rho coordinate to set into sphericalPoint.</td></tr>
<tr valign=top><td><tt>theta</tt></td><td>Theta coordinate to set into sphericalPoint.</td></tr>
<tr valign=top><td><tt>phi</tt></td><td>Phi coordinate to set into sphericalPoint.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of polarPoint parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3SphericalPoint_ToPoint3D"></a>
<h3><a name="Q3SphericalPoint_ToPoint3D">Q3SphericalPoint_ToPoint3D</a></h3>
<blockquote><pre><tt>TQ3Point3D * 
Q3SphericalPoint_ToPoint3D (
    const TQ3SphericalPoint       *sphericalPoint,
    TQ3Point3D                    *result
);
</tt><br>
</pre></blockquote>
<p>Convert 3D spherical point to cartesian coordinates.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>sphericalPoint</tt></td><td>Address of spherical-coordinates point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 3D cartesian point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Add"></a>
<h3><a name="Q3Vector2D_Add">Q3Vector2D_Add</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Vector2D_Add (
    const TQ3Vector2D             *v1,
    const TQ3Vector2D             *v2,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Add two 2D vectors.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>v1</tt></td><td>Address of first vector to add.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of second vector to add.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as v1 and/or v2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Cross"></a>
<h3><a name="Q3Vector2D_Cross">Q3Vector2D_Cross</a></h3>
<blockquote><pre><tt>float  
Q3Vector2D_Cross (
    const TQ3Vector2D             *v1,
    const TQ3Vector2D             *v2
);
</tt><br>
</pre></blockquote>
<p>Return the length of the cross product of two 2D vectors.
<br><br>
Equivalently, we assume that the 2D vectors are really 3D vectors with
z=0, then return the z coordinate of the cross product (0,0,z).
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>v1</tt></td><td>Address of first vector.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of second vector.</td></tr>
</table>
</blockquote>
<b>Result:</b> Length of the 2D cross product.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Dot"></a>
<h3><a name="Q3Vector2D_Dot">Q3Vector2D_Dot</a></h3>
<blockquote><pre><tt>float  
Q3Vector2D_Dot (
    const TQ3Vector2D             *v1,
    const TQ3Vector2D             *v2
);
</tt><br>
</pre></blockquote>
<p>Return the dot product of two 2D vectors.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>v1</tt></td><td>Address of first vector.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of second vector.</td></tr>
</table>
</blockquote>
<b>Result:</b> Dot product of the two vectors.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Length"></a>
<h3><a name="Q3Vector2D_Length">Q3Vector2D_Length</a></h3>
<blockquote><pre><tt>float  
Q3Vector2D_Length (
    const TQ3Vector2D             *vector2D
);
</tt><br>
</pre></blockquote>
<p>Return length of 2D vector.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of vector to get length of.</td></tr>
</table>
</blockquote>
<b>Result:</b> Length of the given vector.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_LengthSquared"></a>
<h3><a name="Q3Vector2D_LengthSquared">Q3Vector2D_LengthSquared</a></h3>
<blockquote><pre><tt>float  
Q3Vector2D_LengthSquared (
    const TQ3Vector2D             *vector2D
);
</tt><br>
</pre></blockquote>
<p>Return squared length of 2D vector.
<br><br>
For many operations, knowing the squared length of a vector is just
as good as knowing the actual length (e.g., when sorting a set of
vectors by length, or comparing a vector to a cut-off length).  But
finding the squared length is much faster, since it avoids a costly
square root computation.
<br><br>
Not supported by QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of vector to get length of.</td></tr>
</table>
</blockquote>
<b>Result:</b> Squared length of the given vector.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Negate"></a>
<h3><a name="Q3Vector2D_Negate">Q3Vector2D_Negate</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Vector2D_Negate (
    const TQ3Vector2D             *vector2D,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Scale a 2D vector by a factor of -1.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of vector to negate.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as vector2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Normalize"></a>
<h3><a name="Q3Vector2D_Normalize">Q3Vector2D_Normalize</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Vector2D_Normalize (
    const TQ3Vector2D             *vector2D,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Scale a 2D vector to length 1.
<br><br>
To obtain valid results, the length of vector2D must not be 0.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of vector to normalize.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as vector2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Scale"></a>
<h3><a name="Q3Vector2D_Scale">Q3Vector2D_Scale</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Vector2D_Scale (
    const TQ3Vector2D             *vector2D,
    float                         scalar,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Scale a 2D vector by the given factor.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of vector to scale.</td></tr>
<tr valign=top><td><tt>scalar</tt></td><td>Scaling factor.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as vector2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Set"></a>
<h3><a name="Q3Vector2D_Set">Q3Vector2D_Set</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Vector2D_Set (
    TQ3Vector2D                   *vector2D,
    float                         x,
    float                         y
);
</tt><br>
</pre></blockquote>
<p>Set a 2D vector.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of vector to set (may be NULL).</td></tr>
<tr valign=top><td><tt>x</tt></td><td>X coordinate to set into vector2D.</td></tr>
<tr valign=top><td><tt>y</tt></td><td>Y coordinate to set into vector2D.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of vector2D parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Subtract"></a>
<h3><a name="Q3Vector2D_Subtract">Q3Vector2D_Subtract</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Vector2D_Subtract (
    const TQ3Vector2D             *v1,
    const TQ3Vector2D             *v2,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Subtract 2D vector v2 from v1.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>v1</tt></td><td>Address of first vector.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of vector to subtract from v1.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as v1 and/or v2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_To2DTransformArray"></a>
<h3><a name="Q3Vector2D_To2DTransformArray">Q3Vector2D_To2DTransformArray</a></h3>
<blockquote><pre><tt>TQ3Status  
Q3Vector2D_To2DTransformArray (
    const TQ3Vector2D             *inVectors2D,
    const TQ3Matrix3x3            *matrix3x3,
    TQ3Vector2D                   *outVectors2D,
    TQ3Int32                      numVectors,
    TQ3Uns32                      inStructSize,
    TQ3Uns32                      outStructSize
);
</tt><br>
</pre></blockquote>
<p>Transform an array of 2D vectors by a 3x3 matrix.
<br><br>
When you have many vectors to transform, this is a more efficient
alternative to calling Q3Vector2D_Transform repeatedly.
<br><br>
Not supported by QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>inVectors2D</tt></td><td>Array of 2D vectors to transform.</td></tr>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Transformation matrix.</td></tr>
<tr valign=top><td><tt>outVectors2D</tt></td><td>Array of vectors to receive output (may be the same as inVectors2D).</td></tr>
<tr valign=top><td><tt>numVectors</tt></td><td>How many vectors are in each array.</td></tr>
<tr valign=top><td><tt>inStructSize</tt></td><td>Size of one element of the input array, typically sizeof(TQ3Vector2D).</td></tr>
<tr valign=top><td><tt>outStructSize</tt></td><td>Size of one element of the output array, typically sizeof(TQ3Vector2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> kQ3Success or some error code.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_To3D"></a>
<h3><a name="Q3Vector2D_To3D">Q3Vector2D_To3D</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector2D_To3D (
    const TQ3Vector2D             *vector2D,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Convert 2D vector to 3D, by setting z to 1.
<br><br>
Note: this operation makes no sense mathematically, but is included
for backward-compatibility with QD3D.  Perhaps the QD3D
implementation was really intended to convert a 2D vector into a 3D
rational point -- see QDPoint2D_To3D, which does exactly that.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of 2D vector to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 3D vector to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_ToRationalPoint3D"></a>
<h3><a name="Q3Vector2D_ToRationalPoint3D">Q3Vector2D_ToRationalPoint3D</a></h3>
<blockquote><pre><tt>TQ3RationalPoint3D * 
Q3Vector2D_ToRationalPoint3D (
    const TQ3Vector2D             *vector2D,
    TQ3RationalPoint3D            *result
);
</tt><br>
</pre></blockquote>
<p>Convert 2D vector to 3D rational point, setting w to 0.
<br><br>
Not supported by QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of 2D vector to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 3D rational point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Transform"></a>
<h3><a name="Q3Vector2D_Transform">Q3Vector2D_Transform</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Vector2D_Transform (
    const TQ3Vector2D             *vector2D,
    const TQ3Matrix3x3            *matrix3x3,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Transform a 2D vector by a 3x3 matrix.
<br><br>
Note that the translation and perspective components of the
matrix is ignored (as if it were really a 2x2 matrix).
<br><br>
Contrast with E3Point2D_Transform, which does the full 3x3
transformation.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of a vector to transform.</td></tr>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of a 3x3 transformation matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as vector2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Add"></a>
<h3><a name="Q3Vector3D_Add">Q3Vector3D_Add</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector3D_Add (
    const TQ3Vector3D             *v1,
    const TQ3Vector3D             *v2,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Add two 3D vectors.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>v1</tt></td><td>Address of first vector to add.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of second vector to add.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as v1 and/or v2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Cross"></a>
<h3><a name="Q3Vector3D_Cross">Q3Vector3D_Cross</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector3D_Cross (
    const TQ3Vector3D             *v1,
    const TQ3Vector3D             *v2,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Return 3D cross product of two 3D vectors.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>v1</tt></td><td>Address of first vector.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of second vector.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set with the result;
may be the same address as v1 and/or v2.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Dot"></a>
<h3><a name="Q3Vector3D_Dot">Q3Vector3D_Dot</a></h3>
<blockquote><pre><tt>float  
Q3Vector3D_Dot (
    const TQ3Vector3D             *v1,
    const TQ3Vector3D             *v2
);
</tt><br>
</pre></blockquote>
<p>Return the dot product of two 3D vectors.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>v1</tt></td><td>Address of first vector.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of second vector.</td></tr>
</table>
</blockquote>
<b>Result:</b> Dot product of the two vectors.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Length"></a>
<h3><a name="Q3Vector3D_Length">Q3Vector3D_Length</a></h3>
<blockquote><pre><tt>float  
Q3Vector3D_Length (
    const TQ3Vector3D             *vector3D
);
</tt><br>
</pre></blockquote>
<p>Return length of 2D vector.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of vector to get length of.</td></tr>
</table>
</blockquote>
<b>Result:</b> Length of the given vector.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_LengthSquared"></a>
<h3><a name="Q3Vector3D_LengthSquared">Q3Vector3D_LengthSquared</a></h3>
<blockquote><pre><tt>float  
Q3Vector3D_LengthSquared (
    const TQ3Vector3D             *vector3D
);
</tt><br>
</pre></blockquote>
<p>Return squared length of 2D vector.
<br><br>
For many operations, knowing the squared length of a vector is just
as good as knowing the actual length (e.g., when sorting a set of
vectors by length, or comparing a vector to a cut-off length).  But
finding the squared length is much faster, since it avoids a costly
square root computation.
<br><br>
Not supported by QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of vector to get length of.</td></tr>
</table>
</blockquote>
<b>Result:</b> Squared length of the given vector.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Negate"></a>
<h3><a name="Q3Vector3D_Negate">Q3Vector3D_Negate</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector3D_Negate (
    const TQ3Vector3D             *vector3D,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Scale a 3D vector by a factor of -1.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of vector to negate.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as vector3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Normalize"></a>
<h3><a name="Q3Vector3D_Normalize">Q3Vector3D_Normalize</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector3D_Normalize (
    const TQ3Vector3D             *vector3D,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Scale a 3D vector to length 1.
<br><br>
To obtain valid results, the length of vector3D must not be 0.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of vector to normalize.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as vector3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Scale"></a>
<h3><a name="Q3Vector3D_Scale">Q3Vector3D_Scale</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector3D_Scale (
    const TQ3Vector3D             *vector3D,
    float                         scalar,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Scale a 3D vector by the given factor.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of vector to scale.</td></tr>
<tr valign=top><td><tt>scalar</tt></td><td>Scaling factor.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as vector3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Set"></a>
<h3><a name="Q3Vector3D_Set">Q3Vector3D_Set</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector3D_Set (
    TQ3Vector3D                   *vector3D,
    float                         x,
    float                         y,
    float                         z
);
</tt><br>
</pre></blockquote>
<p>Set a 3D vector.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of vector to set (may be NULL).</td></tr>
<tr valign=top><td><tt>x</tt></td><td>X coordinate to set into vector3D.</td></tr>
<tr valign=top><td><tt>y</tt></td><td>Y coordinate to set into vector3D.</td></tr>
<tr valign=top><td><tt>z</tt></td><td>Z coordinate to set into vector3D.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of vector3D parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Subtract"></a>
<h3><a name="Q3Vector3D_Subtract">Q3Vector3D_Subtract</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector3D_Subtract (
    const TQ3Vector3D             *v1,
    const TQ3Vector3D             *v2,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Subtract 3D vector v2 from v1.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>v1</tt></td><td>Address of first vector.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of vector to subtract from v1.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as v1 and/or v2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_To2D"></a>
<h3><a name="Q3Vector3D_To2D">Q3Vector3D_To2D</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Vector3D_To2D (
    const TQ3Vector3D             *vector3D,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Convert 3D vector to 2D, dividing by z.
<br><br>
Note: this operation makes no sense mathematically, but is included
for backward-compatibility with QD3D.  It's possible that the QD3D
function was really intended to convert a 3D rational point to a
2D vector -- see E3RationalPoint3D_To2D, which does the same thing
for a 2D point.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of 3D vector to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 2D vector to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_To3DTransformArray"></a>
<h3><a name="Q3Vector3D_To3DTransformArray">Q3Vector3D_To3DTransformArray</a></h3>
<blockquote><pre><tt>TQ3Status  
Q3Vector3D_To3DTransformArray (
    const TQ3Vector3D             *inVectors3D,
    const TQ3Matrix4x4            *matrix4x4,
    TQ3Vector3D                   *outVectors3D,
    TQ3Int32                      numVectors,
    TQ3Uns32                      inStructSize,
    TQ3Uns32                      outStructSize
);
</tt><br>
</pre></blockquote>
<p>Transform an array of 3D vectors by a 4x4 matrix.
<br><br>
When you have many vectors to transform, this is a more efficient
alternative to calling Q3Vector3D_Transform repeatedly.
<br><br>
Not supported by QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>inVectors3D</tt></td><td>Array of 3D vectors to transform.</td></tr>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Transformation matrix.</td></tr>
<tr valign=top><td><tt>outVectors3D</tt></td><td>Array of vectors to receive output (may be the same as inVectors3D).</td></tr>
<tr valign=top><td><tt>numVectors</tt></td><td>How many vectors are in each array.</td></tr>
<tr valign=top><td><tt>inStructSize</tt></td><td>Size of one element of the input array, typically sizeof(TQ3Vector3D).</td></tr>
<tr valign=top><td><tt>outStructSize</tt></td><td>Size of one element of the output array, typically sizeof(TQ3Vector3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> kQ3Success or some error code.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_ToRationalPoint4D"></a>
<h3><a name="Q3Vector3D_ToRationalPoint4D">Q3Vector3D_ToRationalPoint4D</a></h3>
<blockquote><pre><tt>TQ3RationalPoint4D * 
Q3Vector3D_ToRationalPoint4D (
    const TQ3Vector3D             *vector3D,
    TQ3RationalPoint4D            *result
);
</tt><br>
</pre></blockquote>
<p>Convert 3D vector to 4D rational point, setting w to 0.
<br><br>
Not supported by QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of 3D vector to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 4D rational point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Transform"></a>
<h3><a name="Q3Vector3D_Transform">Q3Vector3D_Transform</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector3D_Transform (
    const TQ3Vector3D             *vector3D,
    const TQ3Matrix4x4            *matrix4x4,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Transform a 3D vector by a 4x4 matrix.
<br><br>
Note that the translation and perspective components of the
matrix is ignored (as if it were really a 3x3 matrix).
<br><br>
Contrast with E3Point3D_Transform, which does the full 4x4
transformation.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of a vector to transform.</td></tr>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of a 4x4 transformation matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as vector3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_TransformQuaternion"></a>
<h3><a name="Q3Vector3D_TransformQuaternion">Q3Vector3D_TransformQuaternion</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector3D_TransformQuaternion (
    const TQ3Vector3D             *vector3D,
    const TQ3Quaternion           *quaternion,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Transform a 3D vector by a quaternion.
<br><br>
Note that for correct results, the quaternion should be normalized.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of a vector to transform.</td></tr>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to transform by.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of a vector to set (may be the same as vector3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<p align=center><font size="-1"><a href="http://www.quesa.org/">Copyright &#169; 1999-2001 Quesa Developers &#151; last updated on 8/9/2001 </a></font></p>
</body></html>
