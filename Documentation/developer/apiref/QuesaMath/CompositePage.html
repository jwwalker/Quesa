<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd">
<html><style type="text/css"><!--a:link {text-decoration: none; font-family: Verdana, Geneva, Helvetica, Arial, sans-serif; font-size: small}a:visited {text-decoration: none; font-family: Verdana, Geneva, Helvetica, Arial, sans-serif; font-size: small}a:active {text-decoration: none; font-family: Verdana, Geneva, Helvetica, Arial, sans-serif; font-size: small}a:hover {text-decoration: underline; font-family: Verdana, Geneva, Helvetica, Arial, sans-serif; font-size: small}h4 {text-decoration: none; font-family: Verdana,Geneva,Arial,Helvetica,sans-serif; size: tiny; font-weight: bold}--></style><head>
    <title>QuesaMath.h</title>
	 <meta name="generator" content="HeaderDoc">
</head><body bgcolor="#ffffff">
<h1><font face="Geneva,Arial,Helvtica">QuesaMath.h</font></h1><br>
<h2>Discussion</h2>
Declares the Quesa math utilities.
 <hr><br><h2>Functions</h2>
<hr><a name="//Quesa/c/func/Q3BoundingBox_Copy"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3BoundingBox_Copy">Q3BoundingBox_Copy</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3BoundingBox * ) Q3BoundingBox_Copy (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3BoundingBox *bBox,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3BoundingBox *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Copy a bounding box.
<br><br>
Available in inline form as Q3BFastoundingBox_Copy.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>bBox</em></tt></dt><dd>Address of source bounding box.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of bounding box to set (may be the same as bBox).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3BoundingBox_Reset"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3BoundingBox_Reset">Q3BoundingBox_Reset</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3BoundingBox * ) Q3BoundingBox_Reset (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3BoundingBox *bBox
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Reset (set to empty) a bounding box.
<br><br>
Available in inline form as Q3FastBoundingBox_Reset.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>bBox</em></tt></dt><dd>Address of bounding box to reset.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of bBox parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3BoundingBox_Set"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3BoundingBox_Set">Q3BoundingBox_Set</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3BoundingBox * ) Q3BoundingBox_Set (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3BoundingBox *bBox,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *min,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *max,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Boolean isEmpty
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a bounding box.
<br><br>
Available in inline form as Q3FastBoundingBox_Set.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>bBox</em></tt></dt><dd>Address of bounding box to set.</dd>
<dt><tt><em>min</em></tt></dt><dd>Address of point indicating minimum X, Y, and Z.</dd>
<dt><tt><em>max</em></tt></dt><dd>Address of point indicating maximum X, Y, and Z.</dd>
<dt><tt><em>isEmpty</em></tt></dt><dd>True if the bounding box is empty, false otherwise.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of bBox parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3BoundingBox_SetFromPoints3D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3BoundingBox_SetFromPoints3D">Q3BoundingBox_SetFromPoints3D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3BoundingBox * ) Q3BoundingBox_SetFromPoints3D (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3BoundingBox *bBox,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *points3D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 numPoints,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 structSize
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a bounding box to just enclose a set of 3D points.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>bBox</em></tt></dt><dd>Address of bounding box to set.</dd>
<dt><tt><em>points3D</em></tt></dt><dd>Array of 3D points.</dd>
<dt><tt><em>numPoints</em></tt></dt><dd>How many points are in the array.</dd>
<dt><tt><em>structSize</em></tt></dt><dd>Size of each array element, typically sizeof(TQ3Point3D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of bBox parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3BoundingBox_SetFromRationalPoints4D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3BoundingBox_SetFromRationalPoints4D">Q3BoundingBox_SetFromRationalPoints4D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3BoundingBox * ) Q3BoundingBox_SetFromRationalPoints4D (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3BoundingBox *bBox,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint4D *rationalPoints4D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 numPoints,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 structSize
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a bounding box to just enclose a set of 4D rational points.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>bBox</em></tt></dt><dd>Address of bounding box to set.</dd>
<dt><tt><em>rationalPoints4D</em></tt></dt><dd>Array of 4D rational points.</dd>
<dt><tt><em>numPoints</em></tt></dt><dd>How many points are in the array.</dd>
<dt><tt><em>structSize</em></tt></dt><dd>Size of each array element, typically sizeof(TQ3RationalPoint4D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of bBox parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3BoundingBox_Union"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3BoundingBox_Union">Q3BoundingBox_Union</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3BoundingBox * ) Q3BoundingBox_Union (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3BoundingBox *b1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3BoundingBox *b2,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3BoundingBox *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Compute the minimum bounding box that encloses both 'b1' and 'b2'.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>b1</em></tt></dt><dd>Address of one bounding box.</dd>
<dt><tt><em>b2</em></tt></dt><dd>Address of another bounding box.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of bounding box to set (may be the same as b1 and/or b2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3BoundingBox_UnionPoint3D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3BoundingBox_UnionPoint3D">Q3BoundingBox_UnionPoint3D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3BoundingBox * ) Q3BoundingBox_UnionPoint3D (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3BoundingBox *bBox,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *point3D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3BoundingBox *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return the minimum bounding box that encloses both 'bBox' and 'point3D'.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>bBox</em></tt></dt><dd>Address of initial bounding box.</dd>
<dt><tt><em>point3D</em></tt></dt><dd>Address of a point to enclose.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of bounding box to set (may be the same as bBox).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3BoundingBox_UnionRationalPoint4D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3BoundingBox_UnionRationalPoint4D">Q3BoundingBox_UnionRationalPoint4D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3BoundingBox * ) Q3BoundingBox_UnionRationalPoint4D (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3BoundingBox *bBox,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint4D *rationalPoint4D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3BoundingBox *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return the minimum bounding box that encloses both 'bBox' and 'rationalPoint4D'.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>bBox</em></tt></dt><dd>Address of initial bounding box.</dd>
<dt><tt><em>rationalPoint4D</em></tt></dt><dd>Address of a point to enclose.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of bounding box to set (may be the same as bBox).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3BoundingSphere_Copy"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3BoundingSphere_Copy">Q3BoundingSphere_Copy</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3BoundingSphere * ) Q3BoundingSphere_Copy (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3BoundingSphere *bSphere,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3BoundingSphere *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Copy a bounding sphere.
<br><br>
Available in inline form as Q3FastBoundingSphere_Copy.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>bSphere</em></tt></dt><dd>Address of source bounding sphere.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of bounding sphere to set (may be the same as bSphere).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3BoundingSphere_Reset"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3BoundingSphere_Reset">Q3BoundingSphere_Reset</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3BoundingSphere * ) Q3BoundingSphere_Reset (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3BoundingSphere *bSphere
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Reset (set to empty) a bounding sphere.
<br><br>
Available in inline form as Q3FastBoundingSphere_Reset.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>bSphere</em></tt></dt><dd>Address of bounding sphere to reset.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of bSphere parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3BoundingSphere_Set"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3BoundingSphere_Set">Q3BoundingSphere_Set</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3BoundingSphere * ) Q3BoundingSphere_Set (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3BoundingSphere *bSphere,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *origin,
&nbsp;&nbsp;&nbsp;&nbsp;float radius,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Boolean isEmpty
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a bounding sphere.
<br><br>
Available in inline form as Q3FastBoundingSphere_Set.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>bSphere</em></tt></dt><dd>Address of bounding sphere to set.</dd>
<dt><tt><em>origin</em></tt></dt><dd>Address of point indicating sphere origin.</dd>
<dt><tt><em>radius</em></tt></dt><dd>Sphere radius.</dd>
<dt><tt><em>isEmpty</em></tt></dt><dd>True if the bounding sphere is empty, false otherwise.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of bSphere parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3BoundingSphere_SetFromPoints3D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3BoundingSphere_SetFromPoints3D">Q3BoundingSphere_SetFromPoints3D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3BoundingSphere * ) Q3BoundingSphere_SetFromPoints3D (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3BoundingSphere *bSphere,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *points3D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 numPoints,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 structSize
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a bounding sphere to just enclose a set of 3D points.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>bSphere</em></tt></dt><dd>The bounding sphere to update.</dd>
<dt><tt><em>points3D</em></tt></dt><dd>Array of 3D points.</dd>
<dt><tt><em>numPoints</em></tt></dt><dd>How many points are in the array.</dd>
<dt><tt><em>structSize</em></tt></dt><dd>Size of each array element, typically sizeof(TQ3Point3D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of bSphere parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3BoundingSphere_SetFromRationalPoints4D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3BoundingSphere_SetFromRationalPoints4D">Q3BoundingSphere_SetFromRationalPoints4D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3BoundingSphere * ) Q3BoundingSphere_SetFromRationalPoints4D (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3BoundingSphere *bSphere,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint4D *rationalPoints4D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 numPoints,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 structSize
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a bounding sphere to just enclose a set of 4D rational points.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>bSphere</em></tt></dt><dd>Address of bounding sphere to set.</dd>
<dt><tt><em>rationalPoints4D</em></tt></dt><dd>Array of 4D rational points.</dd>
<dt><tt><em>numPoints</em></tt></dt><dd>How many points are in the array.</dd>
<dt><tt><em>structSize</em></tt></dt><dd>Size of each array element, typically sizeof(TQ3RationalPoint4D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of bSphere parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3BoundingSphere_Union"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3BoundingSphere_Union">Q3BoundingSphere_Union</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3BoundingSphere * ) Q3BoundingSphere_Union (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3BoundingSphere *s1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3BoundingSphere *s2,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3BoundingSphere *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Compute the minimum bounding sphere that encloses both 's1' and 's2'.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>s1</em></tt></dt><dd>Address of one bounding sphere.</dd>
<dt><tt><em>s2</em></tt></dt><dd>Address of another bounding sphere.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of bounding sphere to set (may be the same as s1 and/or s2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3BoundingSphere_UnionPoint3D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3BoundingSphere_UnionPoint3D">Q3BoundingSphere_UnionPoint3D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3BoundingSphere * ) Q3BoundingSphere_UnionPoint3D (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3BoundingSphere *bSphere,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *point3D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3BoundingSphere *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return the minimum bounding sphere that encloses both 'bSphere' and 'point3D'.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>bSphere</em></tt></dt><dd>Address of initial bounding sphere.</dd>
<dt><tt><em>point3D</em></tt></dt><dd>Address of a point to enclose.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of bounding sphere to set (may be the same as bSphere).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3BoundingSphere_UnionRationalPoint4D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3BoundingSphere_UnionRationalPoint4D">Q3BoundingSphere_UnionRationalPoint4D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3BoundingSphere * ) Q3BoundingSphere_UnionRationalPoint4D (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3BoundingSphere *bSphere,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint4D *rationalPoint4D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3BoundingSphere *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return the minimum bounding sphere that encloses both 'bSphere' and 'rationalPoint4D'.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>bSphere</em></tt></dt><dd>Address of initial bounding sphere.</dd>
<dt><tt><em>rationalPoint4D</em></tt></dt><dd>Address of a point to enclose.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of bounding sphere to set (may be the same as bSphere).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Math_InvSquareRoot"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Math_InvSquareRoot">Q3Math_InvSquareRoot</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3Math_InvSquareRoot (
&nbsp;&nbsp;&nbsp;&nbsp;float x
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Obtain a fast, but possibly inaccurate, inverse square root.
<br><br>
The available precision depends on the current architecture, but will
suffice for most non-accumulating 3D operations. If a reliable degree
of precision is required, 1.0/sqrt() should be used instead.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>x</em></tt></dt><dd>The number whose inverse square root should be returned.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Approximate inverse square root of x.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Math_SquareRoot"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Math_SquareRoot">Q3Math_SquareRoot</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3Math_SquareRoot (
&nbsp;&nbsp;&nbsp;&nbsp;float x
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Obtain a fast, but possibly inaccurate, square root.
<br><br>
The available precision depends on the current architecture, but will
suffice for most non-accumulating 3D operations. If a reliable degree
of precision is required, sqrt() should be used instead.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>x</em></tt></dt><dd>The number whose square root should be returned.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Approximate square root of x.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix3x3_Adjoint"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix3x3_Adjoint">Q3Matrix3x3_Adjoint</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix3x3 * ) Q3Matrix3x3_Adjoint (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix3x3 *matrix3x3,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix3x3 *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Calculate adjoint of 3x3 matrix.
<br><br>
The adjoint of a matrix is a scalar multiple of the inverse of
the matrix. For some applications, the adjoint can be used in
place of the inverse. In particular:
<br><br>
adjoint(A) = determinant(A) * inverse(A)
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix3x3</em></tt></dt><dd>Address of a matrix to calculate the adjoint of.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of matrix to set (may be the same as matrix3x3).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix3x3_Copy"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix3x3_Copy">Q3Matrix3x3_Copy</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix3x3 * ) Q3Matrix3x3_Copy (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix3x3 *matrix3x3,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix3x3 *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Copy a 3x3 matrix.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix3x3</em></tt></dt><dd>Address of source matrix.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of destination matrix (may be the same as matrix3x3).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix3x3_Determinant"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix3x3_Determinant">Q3Matrix3x3_Determinant</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3Matrix3x3_Determinant (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix3x3 *matrix3x3
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return the determinant of 3x3 matrix.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix3x3</em></tt></dt><dd>Address of a matrix.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Determinant of that matrix.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix3x3_Invert"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix3x3_Invert">Q3Matrix3x3_Invert</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix3x3 * ) Q3Matrix3x3_Invert (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix3x3 *matrix3x3,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix3x3 *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Calculate the inverse of a 3x3 non-singular matrix.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix3x3</em></tt></dt><dd>Address of non-singular matrix to invert.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of matrix to set (may be the same as matrix3x3).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix3x3_Multiply"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix3x3_Multiply">Q3Matrix3x3_Multiply</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix3x3 * ) Q3Matrix3x3_Multiply (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix3x3 *m1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix3x3 *m2,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix3x3 *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Multiply two 3x3 matrices.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>m1</em></tt></dt><dd>Address of first matrix.</dd>
<dt><tt><em>m2</em></tt></dt><dd>Address of second matrix.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of matrix to set with m1*m2 (may be the same as m1 and/or m2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix3x3_SetIdentity"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix3x3_SetIdentity">Q3Matrix3x3_SetIdentity</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix3x3 * ) Q3Matrix3x3_SetIdentity (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix3x3 *matrix3x3
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 3x3 matrix to the identity matrix.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix3x3</em></tt></dt><dd>Address of matrix to set.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of matrix3x3 parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix3x3_SetRotate"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix3x3_SetRotate">Q3Matrix3x3_SetRotate</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix3x3 * ) Q3Matrix3x3_SetRotate (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix3x3 *matrix3x3,
&nbsp;&nbsp;&nbsp;&nbsp;float angle
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 3x3 matrix to rotate about the origin.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix3x3</em></tt></dt><dd>Address of matrix to set.</dd>
<dt><tt><em>angle</em></tt></dt><dd>Angle to rotate (in radians).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of matrix3x3 parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix3x3_SetRotateAboutPoint"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix3x3_SetRotateAboutPoint">Q3Matrix3x3_SetRotateAboutPoint</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix3x3 * ) Q3Matrix3x3_SetRotateAboutPoint (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix3x3 *matrix3x3,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *origin,
&nbsp;&nbsp;&nbsp;&nbsp;float angle
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 3x3 matrix to rotate about a point.
<br><br>
This is equivalent to translating the point to the origin,
doing a rotation about the origin, and translating back.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix3x3</em></tt></dt><dd>Address of matrix to set.</dd>
<dt><tt><em>origin</em></tt></dt><dd>Address of a 2D point about which to rotate.</dd>
<dt><tt><em>angle</em></tt></dt><dd>Angle to rotate (in radians).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of matrix3x3 parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix3x3_SetScale"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix3x3_SetScale">Q3Matrix3x3_SetScale</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix3x3 * ) Q3Matrix3x3_SetScale (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix3x3 *matrix3x3,
&nbsp;&nbsp;&nbsp;&nbsp;float xScale,
&nbsp;&nbsp;&nbsp;&nbsp;float yScale
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set 3x3 matrix to scale in x, y.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix3x3</em></tt></dt><dd>Address of matrix to set.</dd>
<dt><tt><em>xScale</em></tt></dt><dd>Amount to scale in x.</dd>
<dt><tt><em>yScale</em></tt></dt><dd>Amount to scale in y.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of matrix3x3 parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix3x3_SetTranslate"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix3x3_SetTranslate">Q3Matrix3x3_SetTranslate</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix3x3 * ) Q3Matrix3x3_SetTranslate (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix3x3 *matrix3x3,
&nbsp;&nbsp;&nbsp;&nbsp;float xTrans,
&nbsp;&nbsp;&nbsp;&nbsp;float yTrans
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 3x3 matrix to translate in x, y.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix3x3</em></tt></dt><dd>Address of matrix to set.</dd>
<dt><tt><em>xTrans</em></tt></dt><dd>Amount to translate in x.</dd>
<dt><tt><em>yTrans</em></tt></dt><dd>Amount to translate in y.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of matrix3x3 parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix3x3_Transpose"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix3x3_Transpose">Q3Matrix3x3_Transpose</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix3x3 * ) Q3Matrix3x3_Transpose (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix3x3 *matrix3x3,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix3x3 *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Transpose a 3x3 matrix.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix3x3</em></tt></dt><dd>Address of a matrix to transpose.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of matrix to set (may be the same as matrix3x3).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix4x4_Copy"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix4x4_Copy">Q3Matrix4x4_Copy</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix4x4 * ) Q3Matrix4x4_Copy (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix4x4 *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Copy a 4x4 matrix.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Address of source matrix.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of destination matrix (may be the same as matrix4x4).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix4x4_Determinant"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix4x4_Determinant">Q3Matrix4x4_Determinant</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3Matrix4x4_Determinant (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix4x4 *matrix4x4
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return the determinant of 4x4 matrix.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Address of a matrix.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Determinant of that matrix.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix4x4_Invert"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix4x4_Invert">Q3Matrix4x4_Invert</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix4x4 * ) Q3Matrix4x4_Invert (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix4x4 *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Calculate the inverse of a 4x4 non-singular matrix.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Address of non-singular matrix to invert.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of matrix to set (may be the same as matrix4x4).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix4x4_Multiply"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix4x4_Multiply">Q3Matrix4x4_Multiply</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix4x4 * ) Q3Matrix4x4_Multiply (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix4x4 *m1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix4x4 *m2,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix4x4 *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Multiply two 4x4 matrices.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>m1</em></tt></dt><dd>Address of first matrix.</dd>
<dt><tt><em>m2</em></tt></dt><dd>Address of second matrix.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of matrix to set with m1*m2 (may be the same as m1 and/or m2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix4x4_SetIdentity"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix4x4_SetIdentity">Q3Matrix4x4_SetIdentity</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix4x4 * ) Q3Matrix4x4_SetIdentity (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix4x4 *matrix4x4
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 4x4 matrix to the identity matrix.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Address of matrix to set.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of matrix4x4 parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix4x4_SetQuaternion"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix4x4_SetQuaternion">Q3Matrix4x4_SetQuaternion</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix4x4 * ) Q3Matrix4x4_SetQuaternion (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Quaternion *quaternion
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 4x4 matrix from to the rotation represented by a quaternion.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Address of matrix to set.</dd>
<dt><tt><em>quaternion</em></tt></dt><dd>Address of the quaternion to imitate.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of matrix4x4 parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix4x4_SetRotateAboutAxis"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix4x4_SetRotateAboutAxis">Q3Matrix4x4_SetRotateAboutAxis</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix4x4 * ) Q3Matrix4x4_SetRotateAboutAxis (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *origin,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *axis,
&nbsp;&nbsp;&nbsp;&nbsp;float angle
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set 4x4 matrix to rotate about an arbitrary origin and axis.
<br><br>
Note that for correct results, the axis should be normalized
(i.e. have length = 1).
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Address of matrix to set.</dd>
<dt><tt><em>origin</em></tt></dt><dd>Address of a 2D point about which to rotate.</dd>
<dt><tt><em>axis</em></tt></dt><dd>Address of a 3D vector to use as the rotation axis.</dd>
<dt><tt><em>angle</em></tt></dt><dd>Angle to rotate (in radians).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of matrix4x4 parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix4x4_SetRotateAboutPoint"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix4x4_SetRotateAboutPoint">Q3Matrix4x4_SetRotateAboutPoint</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix4x4 * ) Q3Matrix4x4_SetRotateAboutPoint (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *origin,
&nbsp;&nbsp;&nbsp;&nbsp;float xAngle,
&nbsp;&nbsp;&nbsp;&nbsp;float yAngle,
&nbsp;&nbsp;&nbsp;&nbsp;float zAngle
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 4x4 matrix to rotate about axes through a point and
parallel to the X, Y, and Z axes (in that order).
<br><br>
This order of rotations is rarely useful, but it's kept for backwards
compatibility with QD3D.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Address of matrix to set.</dd>
<dt><tt><em>origin</em></tt></dt><dd>Address of a 3D point about which to rotate.</dd>
<dt><tt><em>xAngle</em></tt></dt><dd>Angle to rotate about the translated X axis (in radians).</dd>
<dt><tt><em>yAngle</em></tt></dt><dd>Angle to rotate about the translated Y axis (in radians).</dd>
<dt><tt><em>zAngle</em></tt></dt><dd>Angle to rotate about the translated Z axis (in radians).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of matrix4x4 parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix4x4_SetRotateVectorToVector"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix4x4_SetRotateVectorToVector">Q3Matrix4x4_SetRotateVectorToVector</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix4x4 * ) Q3Matrix4x4_SetRotateVectorToVector (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *v1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *v2
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 4x4 matrix to rotate vector 'v1' to 'v2'.
<br><br>
Note that for correct results, both vectors should be normalized
(i.e. have length = 1).
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Address of matrix to set.</dd>
<dt><tt><em>v1</em></tt></dt><dd>Address of "starting" vector.</dd>
<dt><tt><em>v2</em></tt></dt><dd>Address of "ending" vector.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of matrix4x4 parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix4x4_SetRotate_X"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix4x4_SetRotate_X">Q3Matrix4x4_SetRotate_X</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix4x4 * ) Q3Matrix4x4_SetRotate_X (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;float angle
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 4x4 matrix to rotate about the X axis.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Address of matrix to set.</dd>
<dt><tt><em>angle</em></tt></dt><dd>Angle to rotate (in radians).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of matrix4x4 parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix4x4_SetRotate_XYZ"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix4x4_SetRotate_XYZ">Q3Matrix4x4_SetRotate_XYZ</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix4x4 * ) Q3Matrix4x4_SetRotate_XYZ (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;float xAngle,
&nbsp;&nbsp;&nbsp;&nbsp;float yAngle,
&nbsp;&nbsp;&nbsp;&nbsp;float zAngle
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 4x4 matrix to rotate about the X, Y, Z axes (in that order).
<br><br>
This order of rotations is rarely useful, but it's kept for backwards
compatibility with QD3D.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Address of matrix to set.</dd>
<dt><tt><em>xAngle</em></tt></dt><dd>Angle to rotate about the X axis (in radians).</dd>
<dt><tt><em>yAngle</em></tt></dt><dd>Angle to rotate about the Y axis (in radians).</dd>
<dt><tt><em>zAngle</em></tt></dt><dd>Angle to rotate about the Z axis (in radians).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of matrix4x4 parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix4x4_SetRotate_Y"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix4x4_SetRotate_Y">Q3Matrix4x4_SetRotate_Y</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix4x4 * ) Q3Matrix4x4_SetRotate_Y (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;float angle
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 4x4 matrix to rotate about the Y axis.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Address of matrix to set.</dd>
<dt><tt><em>angle</em></tt></dt><dd>Angle to rotate (in radians).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of matrix4x4 parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix4x4_SetRotate_Z"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix4x4_SetRotate_Z">Q3Matrix4x4_SetRotate_Z</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix4x4 * ) Q3Matrix4x4_SetRotate_Z (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;float angle
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 4x4 matrix to rotate about the Z axis.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Address of matrix to set.</dd>
<dt><tt><em>angle</em></tt></dt><dd>Angle to rotate (in radians).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of matrix4x4 parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix4x4_SetScale"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix4x4_SetScale">Q3Matrix4x4_SetScale</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix4x4 * ) Q3Matrix4x4_SetScale (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;float xScale,
&nbsp;&nbsp;&nbsp;&nbsp;float yScale,
&nbsp;&nbsp;&nbsp;&nbsp;float zScale
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 4x4 matrix to scale in x, y, z.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Address of matrix to set.</dd>
<dt><tt><em>xScale</em></tt></dt><dd>Amount to scale in x.</dd>
<dt><tt><em>yScale</em></tt></dt><dd>Amount to scale in y.</dd>
<dt><tt><em>zScale</em></tt></dt><dd>Amount to scale in z.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of matrix4x4 parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix4x4_SetTranslate"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix4x4_SetTranslate">Q3Matrix4x4_SetTranslate</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix4x4 * ) Q3Matrix4x4_SetTranslate (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;float xTrans,
&nbsp;&nbsp;&nbsp;&nbsp;float yTrans,
&nbsp;&nbsp;&nbsp;&nbsp;float zTrans
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 4x4 matrix to translate in x, y, z.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Address of matrix to set.</dd>
<dt><tt><em>xTrans</em></tt></dt><dd>Amount to translate in x.</dd>
<dt><tt><em>yTrans</em></tt></dt><dd>Amount to translate in y.</dd>
<dt><tt><em>zTrans</em></tt></dt><dd>Amount to translate in z.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of matrix4x4 parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Matrix4x4_Transpose"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Matrix4x4_Transpose">Q3Matrix4x4_Transpose</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Matrix4x4 * ) Q3Matrix4x4_Transpose (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Matrix4x4 *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Transpose a 4x4 matrix.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Address of a matrix to transpose.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of matrix to set (may be the same as matrix4x4).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Param2D_AffineComb"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Param2D_AffineComb">Q3Param2D_AffineComb</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Param2D * ) Q3Param2D_AffineComb (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Param2D *params2D,
&nbsp;&nbsp;&nbsp;&nbsp;const float *weights,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 numPoints,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Param2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return weighted combination of several 2D parameter points.
<br><br>
Provide an array of points and a parallel array of weights, and
this function will compute the weighted combination.
<br><br>
Although the mathematical definition of an affine combination requires
that the weights sum to 1, this function does not.  It divides by the
sum of the weights, so it only requires that the sum is nonzero.
<br><br>
If you have only two points, use Q3Param2D_RRatio instead.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>params2D</em></tt></dt><dd>Array of 2D parameter points.</dd>
<dt><tt><em>weights</em></tt></dt><dd>Array of weights.</dd>
<dt><tt><em>numPoints</em></tt></dt><dd>How many elements there are in each array.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set with the weighted combination.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Param2D_Distance"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Param2D_Distance">Q3Param2D_Distance</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3Param2D_Distance (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Param2D *p1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Param2D *p2
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return Euclidean distance between two UV parameter points.
<br><br>
Available in inline form as Q3FastParam2D_Distance.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>p1</em></tt></dt><dd>Address of first point of interest.</dd>
<dt><tt><em>p2</em></tt></dt><dd>Address of second point of interest.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Distance between the given points.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Param2D_DistanceSquared"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Param2D_DistanceSquared">Q3Param2D_DistanceSquared</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3Param2D_DistanceSquared (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Param2D *p1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Param2D *p2
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return the squared Euclidean distance between two UV parameter points.
<br><br>
Available in inline form as Q3FastParam2D_DistanceSquared.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>p1</em></tt></dt><dd>Address of first point of interest.</dd>
<dt><tt><em>p2</em></tt></dt><dd>Address of second point of interest.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Square of the distance between the given points.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Param2D_RRatio"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Param2D_RRatio">Q3Param2D_RRatio</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Param2D * ) Q3Param2D_RRatio (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Param2D *p1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Param2D *p2,
&nbsp;&nbsp;&nbsp;&nbsp;float r1,
&nbsp;&nbsp;&nbsp;&nbsp;float r2,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Param2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return the point at ratio r2/(r1+r2) along the line segment is
parameter (UV) space from p1 to p2.
<br><br>
Put another way, this function gives you the weighted average of points
p1 and p2, with the weights given by r1 and r2.  (Note that r1+r2 must
be nonzero.)
<br><br>
Available in inline form as Q3FastParam2D_RRatio.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>p1</em></tt></dt><dd>Address of one end of a line segment.</dd>
<dt><tt><em>p2</em></tt></dt><dd>Address of the other end of a line segment.</dd>
<dt><tt><em>r1</em></tt></dt><dd>Weight given to point p1.</dd>
<dt><tt><em>r2</em></tt></dt><dd>Weight given to point p2.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set (may be the same as p1 and/or p2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Param2D_Set"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Param2D_Set">Q3Param2D_Set</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Param2D * ) Q3Param2D_Set (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Param2D *param2D,
&nbsp;&nbsp;&nbsp;&nbsp;float u,
&nbsp;&nbsp;&nbsp;&nbsp;float v
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 2D parameterization value (i.e., a UV coordinate).
<br><br>
Available in inline form as Q3FastParam2D_Set.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>param2D</em></tt></dt><dd>Address of param2D to set (may be NULL).</dd>
<dt><tt><em>u</em></tt></dt><dd>U coordinate to set into param2D.</dd>
<dt><tt><em>v</em></tt></dt><dd>V coordinate to set into param2D.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of param2D parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Param2D_Subtract"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Param2D_Subtract">Q3Param2D_Subtract</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector2D * ) Q3Param2D_Subtract (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Param2D *p1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Param2D *p2,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Subtract 2D parametric point p2 from p1.
<br><br>
Available in inline form as Q3FastParam2D_Subtract.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>p1</em></tt></dt><dd>Address of a point.</dd>
<dt><tt><em>p2</em></tt></dt><dd>Address of point to subtract.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of a vector to set with (p1-p2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Param2D_Transform"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Param2D_Transform">Q3Param2D_Transform</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Param2D * ) Q3Param2D_Transform (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Param2D *param2D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix3x3 *matrix3x3,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Param2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Transform a 2D parametric point by a 3x3 matrix.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>point2D</em></tt></dt><dd>Address of a point to transform.</dd>
<dt><tt><em>matrix3x3</em></tt></dt><dd>Address of a 3x3 transformation matrix.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set (may be the same as point2D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Param2D_Vector2D_Add"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Param2D_Vector2D_Add">Q3Param2D_Vector2D_Add</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Param2D * ) Q3Param2D_Vector2D_Add (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Param2D *param2D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *vector2D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Param2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Add a 2D vector to a parametric (UV) point.
<br><br>
Available in inline form as Q3FastParam2D_Vector2D_Add.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>param2D</em></tt></dt><dd>Address of a 2D parametric point.</dd>
<dt><tt><em>vector2D</em></tt></dt><dd>Address of a vector to add.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set (may be the same as param2D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Param2D_Vector2D_Subtract"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Param2D_Vector2D_Subtract">Q3Param2D_Vector2D_Subtract</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Param2D * ) Q3Param2D_Vector2D_Subtract (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Param2D *param2D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *vector2D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Param2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Subtract a 2D vector from a parametric (UV) point.
<br><br>
Available in inline form as Q3FastParam2D_Vector2D_Subtract.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>param2D</em></tt></dt><dd>Address of a 2D parametric point.</dd>
<dt><tt><em>vector2D</em></tt></dt><dd>Address of a vector to subtract.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set (may be the same as param2D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point2D_AffineComb"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point2D_AffineComb">Q3Point2D_AffineComb</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Point2D * ) Q3Point2D_AffineComb (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *points2D,
&nbsp;&nbsp;&nbsp;&nbsp;const float *weights,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 numPoints,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return weighted combination of several 2D points.
<br><br>
Provide an array of points and a parallel array of weights, and
this function will compute the weighted combination.
<br><br>
Although the mathematical definition of an affine combination requires
that the weights sum to 1, this function does not.  It divides by the
sum of the weights, so it only requires that the sum is nonzero.
<br><br>
If you have only two points, use Q3Point2D_RRatio instead.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>points2D</em></tt></dt><dd>Array of 2D points.</dd>
<dt><tt><em>weights</em></tt></dt><dd>Array of weights.</dd>
<dt><tt><em>numPoints</em></tt></dt><dd>How many elements there are in each array.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set with the weighted combination.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point2D_CrossProductTri"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point2D_CrossProductTri">Q3Point2D_CrossProductTri</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3Point2D_CrossProductTri (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *p1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *p2,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *p3
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return the length of the cross product of a triangle specified by
three 2D points, that is, of the vectors p2-p1 and p3-p2.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
Available in inline form as Q3FastPoint2D_CrossProductTri.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>p1</em></tt></dt><dd>Address of one point in the triangle.</dd>
<dt><tt><em>p2</em></tt></dt><dd>Address of a second point in the triangle.</dd>
<dt><tt><em>p3</em></tt></dt><dd>Address of a third point in the triangle.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Length of (p2-p1) x (p3-p2).
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point2D_Distance"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point2D_Distance">Q3Point2D_Distance</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3Point2D_Distance (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *p1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *p2
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return Euclidean distance between two 2D points.
<br><br>
Available in inline form as Q3FastPoint2D_Distance.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>p1</em></tt></dt><dd>Address of first point of interest.</dd>
<dt><tt><em>p2</em></tt></dt><dd>Address of second point of interest.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Distance between the given points.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point2D_DistanceSquared"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point2D_DistanceSquared">Q3Point2D_DistanceSquared</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3Point2D_DistanceSquared (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *p1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *p2
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return the squared Euclidean distance between two 2D points.
<br><br>
Available in inline form as Q3FastPoint2D_DistanceSquared.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>p1</em></tt></dt><dd>Address of first point of interest.</dd>
<dt><tt><em>p2</em></tt></dt><dd>Address of second point of interest.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Square of the distance between the given points.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point2D_RRatio"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point2D_RRatio">Q3Point2D_RRatio</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Point2D * ) Q3Point2D_RRatio (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *p1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *p2,
&nbsp;&nbsp;&nbsp;&nbsp;float r1,
&nbsp;&nbsp;&nbsp;&nbsp;float r2,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return the point at ratio r2/(r1+r2) along the line segment from p1 to p2.
<br><br>
Put another way, this function gives you the weighted average of points
p1 and p2, with the weights given by r1 and r2.  (Note that r1+r2 must
be nonzero.)
<br><br>
NOTE: The QD3D docs claim that the ratio used is r1/(r1+r2), but
it was found by direct experimentation that the QD3D library (1.6)
in fact uses r2/(r1+r2) instead.  This is as it should be, if r1 is
the weight of p1, and r2 is the weight of p2.
<br><br>
As usual, we do as QD3D does, not as the docs say.
<br><br>
Available in inline form as Q3FastPoint2D_RRatio.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>p1</em></tt></dt><dd>Address of one end of a line segment.</dd>
<dt><tt><em>p2</em></tt></dt><dd>Address of the other end of a line segment.</dd>
<dt><tt><em>r1</em></tt></dt><dd>Weight given to point p1.</dd>
<dt><tt><em>r2</em></tt></dt><dd>Weight given to point p2.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set (may be the same as p1 and/or p2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point2D_Set"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point2D_Set">Q3Point2D_Set</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Point2D * ) Q3Point2D_Set (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point2D *point2D,
&nbsp;&nbsp;&nbsp;&nbsp;float x,
&nbsp;&nbsp;&nbsp;&nbsp;float y
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 2D point.
<br><br>
Available in inline form as Q3FastPoint2D_Set.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>point2D</em></tt></dt><dd>Address of point to set (may be NULL).</dd>
<dt><tt><em>x</em></tt></dt><dd>X coordinate to set into vector2D.</dd>
<dt><tt><em>y</em></tt></dt><dd>Y coordinate to set into vector2D.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of point2D parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point2D_Subtract"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point2D_Subtract">Q3Point2D_Subtract</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector2D * ) Q3Point2D_Subtract (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *p1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *p2,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Subtract the 2D point p2 from p1.
<br><br>
Available in inline form as Q3FastPoint2D_Subtract.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>p1</em></tt></dt><dd>Address of a point.</dd>
<dt><tt><em>p2</em></tt></dt><dd>Address of point to subtract.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of a vector to set with (p1-p2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point2D_To2DTransformArray"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point2D_To2DTransformArray">Q3Point2D_To2DTransformArray</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Status ) Q3Point2D_To2DTransformArray (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *inPoints2D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix3x3 *matrix3x3,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point2D *outPoints2D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 numPoints,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 inStructSize,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 outStructSize
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Transform an array of 2D points by a 3x3 matrix.
<br><br>
When you have many points to transform, this is a more efficient
alternative to calling Q3Point2D_Transform repeatedly.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>inPoints2D</em></tt></dt><dd>Array of 2D points to transform.</dd>
<dt><tt><em>matrix3x3</em></tt></dt><dd>Transformation matrix.</dd>
<dt><tt><em>outPoints2D</em></tt></dt><dd>Array of points to receive output (may be the same as inPoints2D).</dd>
<dt><tt><em>numPoints</em></tt></dt><dd>How many points are in each array.</dd>
<dt><tt><em>inStructSize</em></tt></dt><dd>Size of one element of the input array, typically sizeof(TQ3Point2D).</dd>
<dt><tt><em>outStructSize</em></tt></dt><dd>Size of one element of the output array, typically sizeof(TQ3Point2D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>kQ3Success or some error code.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point2D_To3D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point2D_To3D">Q3Point2D_To3D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3RationalPoint3D * ) Q3Point2D_To3D (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *point2D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3RationalPoint3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Convert 2D point to rational 3D, setting w to 1.
<br><br>
The Apple version incorrectly declares the type of 'result' to
be TQ3Point3D rather than TQ3RationalPoint3D. At a binary level
there is no difference, but at the source code level the Apple
version forces the use of the incorrect type or type casting.
<br><br>
Available in inline form as Q3FastPoint2D_To3D.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>point2D</em></tt></dt><dd>Address of 2D point to convert.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of 3D rational point to set.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point2D_To3DTransformArray"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point2D_To3DTransformArray">Q3Point2D_To3DTransformArray</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Status ) Q3Point2D_To3DTransformArray (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *inPoints2D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix3x3 *matrix3x3,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3RationalPoint3D *outRationalPoints3D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 numPoints,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 inStructSize,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 outStructSize
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Transform an array of 2D points by a 3x3 matrix into 3D rational points.
<br><br>
When you have many vectors to transform, this is a more efficient
alternative to calling Q3Point2D_To3D and Q3RationalPoint3D_Transform repeatedly.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>inPoints2D</em></tt></dt><dd>Array of 2D points to transform.</dd>
<dt><tt><em>matrix3x3</em></tt></dt><dd>Transformation matrix.</dd>
<dt><tt><em>outRationalPoints3D</em></tt></dt><dd>Array of points to receive output.</dd>
<dt><tt><em>numPoints</em></tt></dt><dd>How many points are in each array.</dd>
<dt><tt><em>inStructSize</em></tt></dt><dd>Size of one element of the input array, typically sizeof(TQ3Point2D).</dd>
<dt><tt><em>outStructSize</em></tt></dt><dd>Size of one element of the output array, typically sizeof(TQ3RationalPoint3D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>kQ3Success or some error code.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point2D_ToPolar"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point2D_ToPolar">Q3Point2D_ToPolar</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3PolarPoint * ) Q3Point2D_ToPolar (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *point2D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3PolarPoint *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Convert 2D cartesian point to polar coordinates.
<br><br>
The angle (theta) here is measured counter-clockwise from the +x axis.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>point2D</em></tt></dt><dd>Address of 2D point to convert.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of polar point to set.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point2D_Transform"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point2D_Transform">Q3Point2D_Transform</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Point2D * ) Q3Point2D_Transform (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *point2D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix3x3 *matrix3x3,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Transform a 2D point by a 3x3 matrix.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>point2D</em></tt></dt><dd>Address of a point to transform.</dd>
<dt><tt><em>matrix3x3</em></tt></dt><dd>Address of a 3x3 transformation matrix.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set (may be the same as point2D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point2D_Vector2D_Add"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point2D_Vector2D_Add">Q3Point2D_Vector2D_Add</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Point2D * ) Q3Point2D_Vector2D_Add (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *point2D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *vector2D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Add a 2D vector to a point.
<br><br>
Available in inline form as Q3FastPoint2D_Vector2D_Add.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>point2D</em></tt></dt><dd>Address of a point.</dd>
<dt><tt><em>vector2D</em></tt></dt><dd>Address of a vector to add.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set (may be the same as point2D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point2D_Vector2D_Subtract"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point2D_Vector2D_Subtract">Q3Point2D_Vector2D_Subtract</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Point2D * ) Q3Point2D_Vector2D_Subtract (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point2D *point2D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *vector2D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Subtract a 2D vector from a point.
<br><br>
Available in inline form as Q3FastPoint2D_Vector2D_Subtract.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>point2D</em></tt></dt><dd>Address of a point.</dd>
<dt><tt><em>vector2D</em></tt></dt><dd>Address of a vector to subtract.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set (may be the same as point2D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point3D_AffineComb"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point3D_AffineComb">Q3Point3D_AffineComb</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Point3D * ) Q3Point3D_AffineComb (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *points3D,
&nbsp;&nbsp;&nbsp;&nbsp;const float *weights,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 numPoints,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return weighted combination of several 3D points.
<br><br>
Provide an array of points and a parallel array of weights, and
this function will compute the weighted combination.
<br><br>
Although the mathematical definition of an affine combination requires
that the weights sum to 1, this function does not.  It divides by the
sum of the weights, so it only requires that the sum is nonzero.
<br><br>
If you have only two points, use Q3Point3D_RRatio instead.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>points3D</em></tt></dt><dd>Array of 3D points.</dd>
<dt><tt><em>weights</em></tt></dt><dd>Array of weights.</dd>
<dt><tt><em>numPoints</em></tt></dt><dd>How many elements there are in each array.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set with the weighted combination.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point3D_CrossProductTri"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point3D_CrossProductTri">Q3Point3D_CrossProductTri</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector3D * ) Q3Point3D_CrossProductTri (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *p1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *p2,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *p3,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return the cross product of triangle triangle defined by three
3D points, that is, of the vectors p2-p1 and p3-p2.
<br><br>
Available in inline form as Q3FastPoint3D_CrossProductTri.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>p1</em></tt></dt><dd>Address of one point in the triangle.</dd>
<dt><tt><em>p2</em></tt></dt><dd>Address of a second point in the triangle.</dd>
<dt><tt><em>p3</em></tt></dt><dd>Address of a third point in the triangle.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of vector to set with cross product (p2-p1) x (p3-p2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point3D_Distance"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point3D_Distance">Q3Point3D_Distance</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3Point3D_Distance (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *p1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *p2
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return Euclidean distance between two 3D points.
<br><br>
Available in inline form as Q3FastPoint3D_Distance.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>p1</em></tt></dt><dd>Address of first point of interest.</dd>
<dt><tt><em>p2</em></tt></dt><dd>Address of second point of interest.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Distance between the given points.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point3D_DistanceSquared"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point3D_DistanceSquared">Q3Point3D_DistanceSquared</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3Point3D_DistanceSquared (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *p1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *p2
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return the squared Euclidean distance between two 3D points.
<br><br>
Available in inline form as Q3FastPoint3D_DistanceSquared.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>p1</em></tt></dt><dd>Address of first point of interest.</dd>
<dt><tt><em>p2</em></tt></dt><dd>Address of second point of interest.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Square of the distance between the given points.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point3D_RRatio"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point3D_RRatio">Q3Point3D_RRatio</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Point3D * ) Q3Point3D_RRatio (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *p1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *p2,
&nbsp;&nbsp;&nbsp;&nbsp;float r1,
&nbsp;&nbsp;&nbsp;&nbsp;float r2,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return the point at ratio r2/(r1+r2) along the line segment from p1 to p2.
<br><br>
Put another way, this function gives you the weighted average of points
p1 and p2, with the weights given by r1 and r2.  (Note that r1+r2 must
be nonzero.)
<br><br>
NOTE: The QD3D docs claim that the ratio used is r1/(r1+r2), but
it was found by direct experimentation that the QD3D library (1.6)
in fact uses r2/(r1+r2) instead.  This is as it should be, if r1 is
the weight of p1, and r2 is the weight of p2.
<br><br>
As usual, we do as QD3D does, not as the docs say.
<br><br>
Available in inline form as Q3FastPoint3D_RRatio.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>p1</em></tt></dt><dd>Address of one end of a line segment.</dd>
<dt><tt><em>p2</em></tt></dt><dd>Address of the other end of a line segment.</dd>
<dt><tt><em>r1</em></tt></dt><dd>Weight given to point p1.</dd>
<dt><tt><em>r2</em></tt></dt><dd>Weight given to point p2.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set (may be the same as p1 and/or p2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point3D_Set"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point3D_Set">Q3Point3D_Set</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Point3D * ) Q3Point3D_Set (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point3D *point3D,
&nbsp;&nbsp;&nbsp;&nbsp;float x,
&nbsp;&nbsp;&nbsp;&nbsp;float y,
&nbsp;&nbsp;&nbsp;&nbsp;float z
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 3D point.
<br><br>
Available in inline form as Q3FastPoint3D_Set.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>point3D</em></tt></dt><dd>Address of point to set (may be NULL).</dd>
<dt><tt><em>x</em></tt></dt><dd>X coordinate to set into point3D.</dd>
<dt><tt><em>y</em></tt></dt><dd>Y coordinate to set into point3D.</dd>
<dt><tt><em>z</em></tt></dt><dd>Z coordinate to set into point3D.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of point3D parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point3D_Subtract"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point3D_Subtract">Q3Point3D_Subtract</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector3D * ) Q3Point3D_Subtract (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *p1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *p2,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Subtract 3D point p2 from p1.
<br><br>
Available in inline form as Q3FastPoint3D_Subtract.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>p1</em></tt></dt><dd>Address of a point.</dd>
<dt><tt><em>p2</em></tt></dt><dd>Address of a point to subtract.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set (may be the same as p1 and/or p2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point3D_To3DTransformArray"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point3D_To3DTransformArray">Q3Point3D_To3DTransformArray</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Status ) Q3Point3D_To3DTransformArray (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *inPoints3D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point3D *outPoints3D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 numPoints,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 inStructSize,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 outStructSize
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Transform an array of 3D points by a 4x4 matrix.
<br><br>
When you have many points to transform, this is a more efficient
alternative to calling Q3Point3D_Transform repeatedly.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>inPoints3D</em></tt></dt><dd>Array of 3D points to transform.</dd>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Transformation matrix.</dd>
<dt><tt><em>outPoints3D</em></tt></dt><dd>Array of points to receive output (may be the same as inPoints3D).</dd>
<dt><tt><em>numPoints</em></tt></dt><dd>How many points are in each array.</dd>
<dt><tt><em>inStructSize</em></tt></dt><dd>Size of one element of the input array, typically sizeof(TQ3Point3D).</dd>
<dt><tt><em>outStructSize</em></tt></dt><dd>Size of one element of the output array, typically sizeof(TQ3Point3D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>kQ3Success or some error code.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point3D_To4D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point3D_To4D">Q3Point3D_To4D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3RationalPoint4D * ) Q3Point3D_To4D (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *point3D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3RationalPoint4D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Convert 3D point to rational 4D, setting w to 1.
<br><br>
Available in inline form as Q3FastPoint3D_To4D.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>point3D</em></tt></dt><dd>Address of 3D point to convert.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of rational 4D point to set.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point3D_To4DTransformArray"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point3D_To4DTransformArray">Q3Point3D_To4DTransformArray</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Status ) Q3Point3D_To4DTransformArray (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *inPoints3D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3RationalPoint4D *outRationalPoints4D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 numPoints,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 inStructSize,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 outStructSize
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Transform an array of 3D points by a 4x4 matrix into 4D rational points.
<br><br>
When you have many vectors to transform, this is a more efficient
alternative to calling Q3Point3D_To4D and Q3RationalPoint4D_Transform repeatedly.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>inPoints3D</em></tt></dt><dd>Array of 3D points to transform.</dd>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Transformation matrix.</dd>
<dt><tt><em>outRationalPoints4D</em></tt></dt><dd>Array of points to receive output.</dd>
<dt><tt><em>numPoints</em></tt></dt><dd>How many points are in each array.</dd>
<dt><tt><em>inStructSize</em></tt></dt><dd>Size of one element of the input array, typically sizeof(TQ3Point3D).</dd>
<dt><tt><em>outStructSize</em></tt></dt><dd>Size of one element of the output array, typically sizeof(TQ3RationalPoint4D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>kQ3Success or some error code.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point3D_ToSpherical"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point3D_ToSpherical">Q3Point3D_ToSpherical</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3SphericalPoint * ) Q3Point3D_ToSpherical (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *point3D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3SphericalPoint *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Convert 3D cartesian point to spherical coordinates.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>point3D</em></tt></dt><dd>Address of 3D cartesian point to convert.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of spherical-coordinates point to set.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point3D_Transform"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point3D_Transform">Q3Point3D_Transform</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Point3D * ) Q3Point3D_Transform (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *point3D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Transform a 3D point by a 4x4 matrix.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>point3D</em></tt></dt><dd>Address of a point to transform.</dd>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Address of a 4x4 transformation matrix.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set (may be the same as point3D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point3D_TransformQuaternion"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point3D_TransformQuaternion">Q3Point3D_TransformQuaternion</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Point3D * ) Q3Point3D_TransformQuaternion (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *point3D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Quaternion *quaternion,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Transform a 3D point by a quaternion.
<br><br>
Note that for correct results, the quaternion should be normalized.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>point3D</em></tt></dt><dd>Address of a point to transform.</dd>
<dt><tt><em>quaternion</em></tt></dt><dd>Address of a quaternion to transform by.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of a point to set (may be the same as point3D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point3D_Vector3D_Add"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point3D_Vector3D_Add">Q3Point3D_Vector3D_Add</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Point3D * ) Q3Point3D_Vector3D_Add (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *point3D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *vector3D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Add a 3D vector to a point.
<br><br>
Available in inline form as Q3FastPoint3D_Vector3D_Add.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>point3D</em></tt></dt><dd>Address of a point.</dd>
<dt><tt><em>vector3D</em></tt></dt><dd>Address of a vector to add.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set (may be the same as point3D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Point3D_Vector3D_Subtract"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Point3D_Vector3D_Subtract">Q3Point3D_Vector3D_Subtract</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Point3D * ) Q3Point3D_Vector3D_Subtract (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *point3D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *vector3D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Subtract 3D vector from point.
<br><br>
Available in inline form as Q3FastPoint3D_Vector3D_Subtract.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>point3D</em></tt></dt><dd>Address of a point.</dd>
<dt><tt><em>vector3D</em></tt></dt><dd>Address of a vector to subtract.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set (may be the same as point3D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3PolarPoint_Set"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3PolarPoint_Set">Q3PolarPoint_Set</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3PolarPoint * ) Q3PolarPoint_Set (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3PolarPoint *polarPoint,
&nbsp;&nbsp;&nbsp;&nbsp;float r,
&nbsp;&nbsp;&nbsp;&nbsp;float theta
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 2D polar-coordinates point.
<br><br>
Available in inline form as Q3FastPolarPoint_Set.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>polarPoint</em></tt></dt><dd>Address of point to set (may be NULL).</dd>
<dt><tt><em>r</em></tt></dt><dd>Radius coordinate to set into polarPoint.</dd>
<dt><tt><em>theta</em></tt></dt><dd>Angle coordinate (in radians) to set into polarPoint.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of polarPoint parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3PolarPoint_ToPoint2D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3PolarPoint_ToPoint2D">Q3PolarPoint_ToPoint2D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Point2D * ) Q3PolarPoint_ToPoint2D (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3PolarPoint *polarPoint,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Convert 2D polar point to cartesian coordinates.
<br><br>
The angle (theta) here is measured counter-clockwise from the +x axis.
<br><br>
Available in inline form as Q3FastPolarPoint_ToPoint2D.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>polarPoint</em></tt></dt><dd>Address of polar point to convert.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of 2D cartesian point to set.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Quaternion_Copy"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Quaternion_Copy">Q3Quaternion_Copy</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Quaternion * ) Q3Quaternion_Copy (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Quaternion *quaternion,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Quaternion *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Copy a quaternion.
<br><br>
Available in inline form as Q3FastQuaternion_Copy.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>quaternion</em></tt></dt><dd>Address of source quaternion.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of destination quaternion (may be the same as the first parameter).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Quaternion_Dot"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Quaternion_Dot">Q3Quaternion_Dot</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3Quaternion_Dot (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Quaternion *q1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Quaternion *q2
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return the dot product of q1 and q2.
<br><br>
Available in inline form as Q3FastQuaternion_Dot.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>q1</em></tt></dt><dd>Address of one quaternion.</dd>
<dt><tt><em>q2</em></tt></dt><dd>Address of another quaternion (may be the same as q1).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Dot product of q1 and q2.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Quaternion_GetAxisAndAngle"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Quaternion_GetAxisAndAngle">Q3Quaternion_GetAxisAndAngle</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector3D * ) Q3Quaternion_GetAxisAndAngle (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Quaternion *quaternion,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector3D *outAxis,
&nbsp;&nbsp;&nbsp;&nbsp;float *outAngle
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Get the rotation axis and/or angle represented by a quaternion.
<br><br>
Note that for correct results, the quaternion should be normalized.
<br><br>
If the quaternion represents a null rotation, then outAngle will be
set to 0.0 and outAxis will be set to <0, 1, 0> (since in this case
the rotation axis is undefined, but we want to always give you a
valid axis).
<br><br>
The returned angle in radians will be in the range [0, 2*pi].
<br><br>
Either outAxis or outAngle may be null if you are not interested in
that result.  (You could even pass null for both, but that would be
rather pointless.)
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>quaternion</em></tt></dt><dd>Address of a quaternion to inspect.</dd>
<dt><tt><em>outAxis</em></tt></dt><dd>Address of a vector to set to the rotation axis (may be null).</dd>
<dt><tt><em>outAngle</em></tt></dt><dd>Address of a float to set to the rotation angle (may be null).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of outAxis parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Quaternion_InterpolateFast"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Quaternion_InterpolateFast">Q3Quaternion_InterpolateFast</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Quaternion * ) Q3Quaternion_InterpolateFast (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Quaternion *q1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Quaternion *q2,
&nbsp;&nbsp;&nbsp;&nbsp;float t,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Quaternion *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Compute a straight linear interpolation between two quaternions.
<br><br>
This does a true linear, not spherical, interpolation between
q1 and q2.  It's fast, but not very proper for most uses.
<br><br>
The result is automatically normalized, so there is no need to
do so yourself.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>q1</em></tt></dt><dd>Address of first quaternion.</dd>
<dt><tt><em>q2</em></tt></dt><dd>Address of second quaternion.</dd>
<dt><tt><em>t</em></tt></dt><dd>Fraction (0-1) of the way from q1 to q2.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of quaternion to set (may be the same as q1 and/or q2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Quaternion_InterpolateLinear"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Quaternion_InterpolateLinear">Q3Quaternion_InterpolateLinear</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Quaternion * ) Q3Quaternion_InterpolateLinear (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Quaternion *q1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Quaternion *q2,
&nbsp;&nbsp;&nbsp;&nbsp;float t,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Quaternion *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Compute a spherical linear interpolation between two quaternions.
<br><br>
Despite the name, this function does a SLERP (spherical linear
interpolation) from q1 to q2.
It falls back on a straight linear interpolation only when the
cosine of the angle between them is less than 0.01.
<br><br>
The cut-off point was chosen arbitrarily, and may not match
that of QD3D.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>q1</em></tt></dt><dd>Address of first quaternion.</dd>
<dt><tt><em>q2</em></tt></dt><dd>Address of second quaternion.</dd>
<dt><tt><em>t</em></tt></dt><dd>Fraction (0-1) of the way from q1 to q2.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of quaternion to set (may be the same as q1 and/or q2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Quaternion_Invert"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Quaternion_Invert">Q3Quaternion_Invert</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Quaternion * ) Q3Quaternion_Invert (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Quaternion *quaternion,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Quaternion *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Invert a quaternion.
<br><br>
For correct results, the quaternion should be normalized
before inverting.
<br><br>
Available in inline form as Q3FastQuaternion_Invert.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>quaternion</em></tt></dt><dd>Address of a quaternion to invert.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of quaternion to set (may be the same as the first parameter).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Quaternion_IsIdentity"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Quaternion_IsIdentity">Q3Quaternion_IsIdentity</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Boolean ) Q3Quaternion_IsIdentity (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Quaternion *quaternion
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return whether a quaternion is (roughly) the identity,
i.e., (1,0,0,0).
<br><br>
Values for x, y, and z are considered close enough to 0
if they are within FLT_EPSILON (a small number).
<br><br>
For correct results, the quaternion should first be normalized.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>quaternion</em></tt></dt><dd>Address of quaternion to test.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>True if quaternion is the identity.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Quaternion_MatchReflection"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Quaternion_MatchReflection">Q3Quaternion_MatchReflection</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Quaternion * ) Q3Quaternion_MatchReflection (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Quaternion *q1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Quaternion *q2,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Quaternion *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set result to either q1 or -q1, whichever produces a positive dot
product with q2 (i.e., whichever is "closer" to q2 in orientation).
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>q1</em></tt></dt><dd>Address of source quaternion.</dd>
<dt><tt><em>q2</em></tt></dt><dd>Address of quaternion to match.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of quaternion to set (may be the same as q1 and/or q2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Quaternion_Multiply"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Quaternion_Multiply">Q3Quaternion_Multiply</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Quaternion * ) Q3Quaternion_Multiply (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Quaternion *q1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Quaternion *q2,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Quaternion *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Compute the product of two quaternions.
<br><br>
This is a very useful operation, since the rotation represented
by q1*q2 is exactly the same as rotating by q1 and then by q2.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>q1</em></tt></dt><dd>Address of first quaternion.</dd>
<dt><tt><em>q2</em></tt></dt><dd>Address of second quaternion.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of quaternion to set (may be the same as q1 and/or q2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Quaternion_Normalize"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Quaternion_Normalize">Q3Quaternion_Normalize</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Quaternion * ) Q3Quaternion_Normalize (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Quaternion *quaternion,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Quaternion *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Scale a quaternion to length 1.
<br><br>
This is often needed when combining or interpolating between
quaternions, to keep accumulated error from causing your
quaternion values to "blow up".
<br><br>
Available in inline form as Q3FastQuaternion_Normalize.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>quaternion</em></tt></dt><dd>Address of a quaternion to normalize.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of quaternion to set (may be the same as the first parameter).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Quaternion_Set"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Quaternion_Set">Q3Quaternion_Set</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Quaternion * ) Q3Quaternion_Set (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Quaternion *quaternion,
&nbsp;&nbsp;&nbsp;&nbsp;float w,
&nbsp;&nbsp;&nbsp;&nbsp;float x,
&nbsp;&nbsp;&nbsp;&nbsp;float y,
&nbsp;&nbsp;&nbsp;&nbsp;float z
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a quaternion with its individual w, x, y, and z components.
<br><br>
Available in inline form as Q3FastQuaternion_Set.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>quaternion</em></tt></dt><dd>Address of a quaternion to set.</dd>
<dt><tt><em>w</em></tt></dt><dd>Value for w component.</dd>
<dt><tt><em>x</em></tt></dt><dd>Value for x component.</dd>
<dt><tt><em>y</em></tt></dt><dd>Value for y component.</dd>
<dt><tt><em>z</em></tt></dt><dd>Value for z component.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of quaternion parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Quaternion_SetIdentity"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Quaternion_SetIdentity">Q3Quaternion_SetIdentity</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Quaternion * ) Q3Quaternion_SetIdentity (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Quaternion *quaternion
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a quaternion to the identity value (1,0,0,0).
<br><br>
Available in inline form as Q3FastQuaternion_SetIdentity.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>quaternion</em></tt></dt><dd>Address of a quaternion to set.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Quaternion_SetMatrix"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Quaternion_SetMatrix">Q3Quaternion_SetMatrix</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Quaternion * ) Q3Quaternion_SetMatrix (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Quaternion *quaternion,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix4x4 *matrix4x4
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a quaternion from a 4x4 rotation matrix.
<br><br>
Note: The QD3D implementation of this function appears to be buggy.
This can be demonstrated by starting with an arbitrary
quaternion, converting to a matrix, then converting back (with
this function).
<br><br>
QD3D's result is something ridiculous; in Quesa, this function
returns the original quaternion (or something equivalent).
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>quaternion</em></tt></dt><dd>Address of a quaternion to set.</dd>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Address of a rotation matrix to imitate.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of quaternion parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Quaternion_SetRotateAboutAxis"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Quaternion_SetRotateAboutAxis">Q3Quaternion_SetRotateAboutAxis</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Quaternion * ) Q3Quaternion_SetRotateAboutAxis (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Quaternion *quaternion,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *axis,
&nbsp;&nbsp;&nbsp;&nbsp;float angle
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set quaternion to rotate about arbitrary axis.
<br><br>
Note that for correct results, the axis should be normalized
(i.e. have length = 1).
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>quaternion</em></tt></dt><dd>Address of a quaternion to set.</dd>
<dt><tt><em>axis</em></tt></dt><dd>Address of a 3D vector to use as the rotation axis.</dd>
<dt><tt><em>angle</em></tt></dt><dd>Angle to rotate (in radians).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of quaternion parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Quaternion_SetRotateVectorToVector"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Quaternion_SetRotateVectorToVector">Q3Quaternion_SetRotateVectorToVector</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Quaternion * ) Q3Quaternion_SetRotateVectorToVector (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Quaternion *quaternion,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *v1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *v2
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a quaternion to rotate vector 'v1' to 'v2'.
<br><br>
Note that for correct results, both vectors should be normalized
(i.e. have length = 1).
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>quaternion</em></tt></dt><dd>Address of a quaternion to set.</dd>
<dt><tt><em>v1</em></tt></dt><dd>Address of "starting" vector.</dd>
<dt><tt><em>v2</em></tt></dt><dd>Address of "ending" vector.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of quaternion parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Quaternion_SetRotate_X"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Quaternion_SetRotate_X">Q3Quaternion_SetRotate_X</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Quaternion * ) Q3Quaternion_SetRotate_X (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Quaternion *quaternion,
&nbsp;&nbsp;&nbsp;&nbsp;float angle
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a quaternion to rotate about the X axis.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>quaternion</em></tt></dt><dd>Address of a quaternion to set.</dd>
<dt><tt><em>angle</em></tt></dt><dd>Angle to rotate (in radians).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Quaternion_SetRotate_XYZ"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Quaternion_SetRotate_XYZ">Q3Quaternion_SetRotate_XYZ</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Quaternion * ) Q3Quaternion_SetRotate_XYZ (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Quaternion *quaternion,
&nbsp;&nbsp;&nbsp;&nbsp;float xAngle,
&nbsp;&nbsp;&nbsp;&nbsp;float yAngle,
&nbsp;&nbsp;&nbsp;&nbsp;float zAngle
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a quaternion to rotate about the X, Y, and Z axes (in that order).
<br><br>
This order of rotations is rarely useful, but it's kept for backwards
compatibility with QD3D.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>quaternion</em></tt></dt><dd>Address of a quaternion to set.</dd>
<dt><tt><em>xAngle</em></tt></dt><dd>Angle to rotate about the X axis (in radians).</dd>
<dt><tt><em>yAngle</em></tt></dt><dd>Angle to rotate about the Y axis (in radians).</dd>
<dt><tt><em>zAngle</em></tt></dt><dd>Angle to rotate about the Z axis (in radians).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of quaternion parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Quaternion_SetRotate_Y"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Quaternion_SetRotate_Y">Q3Quaternion_SetRotate_Y</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Quaternion * ) Q3Quaternion_SetRotate_Y (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Quaternion *quaternion,
&nbsp;&nbsp;&nbsp;&nbsp;float angle
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a quaternion to rotate about the Y axis.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>quaternion</em></tt></dt><dd>Address of a quaternion to set.</dd>
<dt><tt><em>angle</em></tt></dt><dd>Angle to rotate (in radians).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of quaternion parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Quaternion_SetRotate_Z"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Quaternion_SetRotate_Z">Q3Quaternion_SetRotate_Z</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Quaternion * ) Q3Quaternion_SetRotate_Z (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Quaternion *quaternion,
&nbsp;&nbsp;&nbsp;&nbsp;float angle
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a quaternion to rotate about the Z axis.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>quaternion</em></tt></dt><dd>Address of a quaternion to set.</dd>
<dt><tt><em>angle</em></tt></dt><dd>Angle to rotate (in radians).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of quaternion parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3RationalPoint3D_AffineComb"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3RationalPoint3D_AffineComb">Q3RationalPoint3D_AffineComb</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3RationalPoint3D * ) Q3RationalPoint3D_AffineComb (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint3D *rationalPoints3D,
&nbsp;&nbsp;&nbsp;&nbsp;const float *weights,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 numPoints,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3RationalPoint3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Compute the weighted combination of several 3D rational points.
<br><br>
Although the mathematical definition of an affine combination requires
that the weights sum to 1, this function does not.  It divides by the
sum of the weights, so it only requires that the sum is nonzero.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>rationalPoints3D</em></tt></dt><dd>Array of 3D rational points.</dd>
<dt><tt><em>weights</em></tt></dt><dd>Array of weights.</dd>
<dt><tt><em>numPoints</em></tt></dt><dd>How many elements there are in each array.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set with the weighted combination.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3RationalPoint3D_Distance"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3RationalPoint3D_Distance">Q3RationalPoint3D_Distance</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3RationalPoint3D_Distance (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint3D *p1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint3D *p2
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Returns the Euclidian distance between two rational 3D points.
<br><br>
This operation makes no sense mathematically, but is included
for backwards compatibility with QD3D.
<br><br>
Available in inline form as Q3FastRationalPoint3D_Distance.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>p1</em></tt></dt><dd>Address of first point of interest.</dd>
<dt><tt><em>p2</em></tt></dt><dd>Address of second point of interest.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Distance between the given points, treating
w as a spatial coordinate.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3RationalPoint3D_DistanceSquared"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3RationalPoint3D_DistanceSquared">Q3RationalPoint3D_DistanceSquared</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3RationalPoint3D_DistanceSquared (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint3D *p1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint3D *p2
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Returns the squared Euclidian distance between two rational 3D points.
<br><br>
This operation makes no sense mathematically, but is included
for backwards compatibility with QD3D.
<br><br>
Available in inline form as Q3FastRationalPoint3D_DistanceSquared.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>p1</em></tt></dt><dd>Address of first point of interest.</dd>
<dt><tt><em>p2</em></tt></dt><dd>Address of second point of interest.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Square of the distance between the given points,
treating w as a spatial coordinate.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3RationalPoint3D_Set"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3RationalPoint3D_Set">Q3RationalPoint3D_Set</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3RationalPoint3D * ) Q3RationalPoint3D_Set (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3RationalPoint3D *rationalPoint3D,
&nbsp;&nbsp;&nbsp;&nbsp;float x,
&nbsp;&nbsp;&nbsp;&nbsp;float y,
&nbsp;&nbsp;&nbsp;&nbsp;float w
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 3D rational point (x,y,w).
<br><br>
Available in inline form as Q3FastRationalPoint3D_Set.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>rationalPoint3D</em></tt></dt><dd>Address of rational point to set (may be NULL).</dd>
<dt><tt><em>x</em></tt></dt><dd>X coordinate to set into rationalPoint3D.</dd>
<dt><tt><em>y</em></tt></dt><dd>Y coordinate to set into rationalPoint3D.</dd>
<dt><tt><em>w</em></tt></dt><dd>W coordinate to set into rationalPoint3D.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of rationalPoint3D parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3RationalPoint3D_To2D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3RationalPoint3D_To2D">Q3RationalPoint3D_To2D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Point2D * ) Q3RationalPoint3D_To2D (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint3D *rationalPoint3D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Convert rational 3D point to 2D, dividing by w.
<br><br>
Available in inline form as Q3FastRationalPoint3D_To2D.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>rationalPoint3D</em></tt></dt><dd>Address of rational 3D point to convert.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of 2D point to set.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3RationalPoint3D_To3DTransformArray"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3RationalPoint3D_To3DTransformArray">Q3RationalPoint3D_To3DTransformArray</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Status ) Q3RationalPoint3D_To3DTransformArray (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint3D *inRationalPoints3D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix3x3 *matrix3x3,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3RationalPoint3D *outRationalPoints3D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 numPoints,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 inStructSize,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 outStructSize
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Transform an array of 3D rational points by a 3x3 matrix.
<br><br>
When you have many points to transform, this is a more efficient
alternative to calling Q3RationalPoint3D_Transform repeatedly.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>inRationalPoints3D</em></tt></dt><dd>Array of 3D rational points to transform.</dd>
<dt><tt><em>matrix3x3</em></tt></dt><dd>Transformation matrix.</dd>
<dt><tt><em>outRationalPoints3D</em></tt></dt><dd>Array of points to receive output (may be the same as inRationalPoints3D).</dd>
<dt><tt><em>numPoints</em></tt></dt><dd>How many points are in each array.</dd>
<dt><tt><em>inStructSize</em></tt></dt><dd>Size of one element of the input array, typically sizeof(TQ3RationalPoint3D).</dd>
<dt><tt><em>outStructSize</em></tt></dt><dd>Size of one element of the output array, typically sizeof(TQ3RationalPoint3D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>kQ3Success or some error code.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3RationalPoint3D_ToVector2D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3RationalPoint3D_ToVector2D">Q3RationalPoint3D_ToVector2D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector2D * ) Q3RationalPoint3D_ToVector2D (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint3D *rationalPoint3D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Convert 3D rational point to 2D vector, discarding w.
<br><br>
Available in inline form as Q3FastRationalPoint3D_ToVector2D.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>rationalPoint3D</em></tt></dt><dd>Address of 3D rational point to convert.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of 2D vector to set.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3RationalPoint3D_Transform"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3RationalPoint3D_Transform">Q3RationalPoint3D_Transform</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3RationalPoint3D * ) Q3RationalPoint3D_Transform (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint3D *rationalPoint3D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix3x3 *matri3x3,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3RationalPoint3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Transform a 3D rational point by 3x3 matrix.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>rationalPoint3D</em></tt></dt><dd>Address of a point to transform.</dd>
<dt><tt><em>matrix3x3</em></tt></dt><dd>Address of a 3x3 transformation matrix.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set (may be the same as rationalPoint3D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3RationalPoint4D_AffineComb"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3RationalPoint4D_AffineComb">Q3RationalPoint4D_AffineComb</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3RationalPoint4D * ) Q3RationalPoint4D_AffineComb (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint4D *rationalPoints4D,
&nbsp;&nbsp;&nbsp;&nbsp;const float *weights,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 numPoints,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3RationalPoint4D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Compute the weighted combination of several 4D rational points.
<br><br>
Although the mathematical definition of an affine combination requires
that the weights sum to 1, this function does not.  It divides by the
sum of the weights, so it only requires that the sum is nonzero.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>rationalPoints4D</em></tt></dt><dd>Array of 4D rational points.</dd>
<dt><tt><em>weights</em></tt></dt><dd>Array of weights.</dd>
<dt><tt><em>numPoints</em></tt></dt><dd>How many elements there are in each array.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set with the weighted combination.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3RationalPoint4D_Distance"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3RationalPoint4D_Distance">Q3RationalPoint4D_Distance</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3RationalPoint4D_Distance (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint4D *p1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint4D *p2
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Returns the Euclidian distance between two rational 4D points.
<br><br>
This operation makes no sense mathematically, but is included
for backwards compatibility with QD3D.
<br><br>
Available in inline form as Q3FastRationalPoint4D_Distance.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>p1</em></tt></dt><dd>Address of first point of interest.</dd>
<dt><tt><em>p2</em></tt></dt><dd>Address of second point of interest.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Distance between the given points, treating
w as a spatial coordinate.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3RationalPoint4D_DistanceSquared"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3RationalPoint4D_DistanceSquared">Q3RationalPoint4D_DistanceSquared</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3RationalPoint4D_DistanceSquared (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint4D *p1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint4D *p2
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Returns the squared Euclidian distance between two rational 4D points.
<br><br>
This operation makes no sense mathematically, but is included
for backwards compatibility with QD3D.
<br><br>
Available in inline form as Q3FastRationalPoint4D_DistanceSquared.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>p1</em></tt></dt><dd>Address of first point of interest.</dd>
<dt><tt><em>p2</em></tt></dt><dd>Address of second point of interest.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Square of the distance between the given points,
treating w as a spatial coordinate.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3RationalPoint4D_RRatio"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3RationalPoint4D_RRatio">Q3RationalPoint4D_RRatio</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3RationalPoint4D * ) Q3RationalPoint4D_RRatio (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint4D *p1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint4D *p2,
&nbsp;&nbsp;&nbsp;&nbsp;float r1,
&nbsp;&nbsp;&nbsp;&nbsp;float r2,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3RationalPoint4D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return the point at ratio r2/(r1+r2) along the line segment from p1 to p2.
<br><br>
Put another way, this function gives you the weighted average of points
p1 and p2, with the weights given by r1 and r2.  (Note that r1+r2 must
be nonzero.)
<br><br>
NOTE: The QD3D docs claim that the ratio used is r1/(r1+r2), but
it was found by direct experimentation that the QD3D library (1.6)
in fact uses r2/(r1+r2) instead.  This is as it should be, if r1 is
the weight of p1, and r2 is the weight of p2.
<br><br>
As usual, we do as QD3D does, not as the docs say.
<br><br>
Available in inline form as Q3FastRationalPoint4D_RRatio.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>p1</em></tt></dt><dd>Address of one end of a line segment.</dd>
<dt><tt><em>p2</em></tt></dt><dd>Address of the other end of a line segment.</dd>
<dt><tt><em>r1</em></tt></dt><dd>Weight given to point p1.</dd>
<dt><tt><em>r2</em></tt></dt><dd>Weight given to point p2.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set (may be the same as p1 and/or p2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3RationalPoint4D_Set"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3RationalPoint4D_Set">Q3RationalPoint4D_Set</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3RationalPoint4D * ) Q3RationalPoint4D_Set (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3RationalPoint4D *rationalPoint4D,
&nbsp;&nbsp;&nbsp;&nbsp;float x,
&nbsp;&nbsp;&nbsp;&nbsp;float y,
&nbsp;&nbsp;&nbsp;&nbsp;float z,
&nbsp;&nbsp;&nbsp;&nbsp;float w
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 4D rational point (x,y,z,w).
<br><br>
Available in inline form as Q3FastRationalPoint4D_Set.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>rationalPoint4D</em></tt></dt><dd>Address of rational point to set.</dd>
<dt><tt><em>x</em></tt></dt><dd>X coordinate to set into rationalPoint4D.</dd>
<dt><tt><em>y</em></tt></dt><dd>Y coordinate to set into rationalPoint4D.</dd>
<dt><tt><em>z</em></tt></dt><dd>Z coordinate to set into rationalPoint4D.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of rationalPoint4D parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3RationalPoint4D_To3D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3RationalPoint4D_To3D">Q3RationalPoint4D_To3D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Point3D * ) Q3RationalPoint4D_To3D (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint4D *rationalPoint4D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Convert rational 4D point to 3D, dividing by w.
<br><br>
Available in inline form as Q3FastRationalPoint4D_To3D.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>rationalPoint4D</em></tt></dt><dd>Address of rational 4D point to convert.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of 3D point to set.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3RationalPoint4D_To4DTransformArray"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3RationalPoint4D_To4DTransformArray">Q3RationalPoint4D_To4DTransformArray</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Status ) Q3RationalPoint4D_To4DTransformArray (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint4D *inRationalPoints4D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3RationalPoint4D *outRationalPoints4D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 numPoints,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 inStructSize,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 outStructSize
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Transform an array of 4D points by a 4x4 matrix.
<br><br>
When you have many points to transform, this is a more efficient
alternative to calling Q3RationalPoint4D_Transform repeatedly.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>inRationalPoints4D</em></tt></dt><dd>Array of 4D points to transform.</dd>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Transformation matrix.</dd>
<dt><tt><em>outRationalPoints4D</em></tt></dt><dd>Array of points to receive output (may be the same as inRationalPoints4D).</dd>
<dt><tt><em>numPoints</em></tt></dt><dd>How many points are in each array.</dd>
<dt><tt><em>inStructSize</em></tt></dt><dd>Size of one element of the input array, typically sizeof(TQ3RationalPoint4D).</dd>
<dt><tt><em>outStructSize</em></tt></dt><dd>Size of one element of the output array, typically sizeof(TQ3RationalPoint4D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>kQ3Success or some error code.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3RationalPoint4D_ToVector3D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3RationalPoint4D_ToVector3D">Q3RationalPoint4D_ToVector3D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector3D * ) Q3RationalPoint4D_ToVector3D (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint4D *rationalPoint4D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Convert 4D rational point to 3D vector, discarding w.
<br><br>
Available in inline form as Q3FastRationalPoint4D_ToVector3D.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>rationalPoint4D</em></tt></dt><dd>Address of 4D rational point to convert.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of 3D vector to set.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3RationalPoint4D_Transform"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3RationalPoint4D_Transform">Q3RationalPoint4D_Transform</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3RationalPoint4D * ) Q3RationalPoint4D_Transform (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3RationalPoint4D *rationalPoint4D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3RationalPoint4D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Transform a 4D rational point by a 4x4 matrix.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>rationalPoint4D</em></tt></dt><dd>Address of a point to transform.</dd>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Address of a 4x4 transformation matrix.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of point to set (may be the same as rationalPoint4D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Ray3D_IntersectBoundingBox"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Ray3D_IntersectBoundingBox">Q3Ray3D_IntersectBoundingBox</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Boolean ) Q3Ray3D_IntersectBoundingBox (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Ray3D *theRay,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3BoundingBox *theBounds,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point3D *hitPoint
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Test a ray for intersection against a bounding box. If an
intersection occurs, the point of intersection is returned.
<br><br>
The direction vector of the ray must be normalised.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>theRay</em></tt></dt><dd>The ray to test.</dd>
<dt><tt><em>theBounds</em></tt></dt><dd>The bounding box to test against.</dd>
<dt><tt><em>hitPoint</em></tt></dt><dd>Receives the intersection point, if found.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Indicates if the ray intersects the bounding box.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Ray3D_IntersectSphere"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Ray3D_IntersectSphere">Q3Ray3D_IntersectSphere</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Boolean ) Q3Ray3D_IntersectSphere (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Ray3D *theRay,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Sphere *theSphere,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point3D *hitPoint
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Test a ray for intersection against a sphere, and return the point
of intersection if found.
<br><br>
The direction vector of the ray must be normalised.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>theRay</em></tt></dt><dd>The ray to test.</dd>
<dt><tt><em>theSphere</em></tt></dt><dd>The sphere to test against.</dd>
<dt><tt><em>hitPoint</em></tt></dt><dd>Receives the intersection point, if found.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Indicates if the ray intersects the sphere.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Ray3D_IntersectTriangle"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Ray3D_IntersectTriangle">Q3Ray3D_IntersectTriangle</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Boolean ) Q3Ray3D_IntersectTriangle (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Ray3D *theRay,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *point1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *point2,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *point3,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Boolean cullBackfacing,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Param3D *hitPoint
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Test a ray for intersection against a triangle formed by three
points. If an intersection occurs, returns the barycentric
coordinates of the point of intersection and the distance along
the ray.
<br><br>
Triangles may optionally be subject to backface culling, in
which case a hit on the reverse side of the triangle will fail
to result in an intersection.
<br><br>
Barycentric coordinates can be used to interpolate the triangle
vertices to obtain the exact point of intersection, like so:
<br><br>
t = (1.0f - hitPoint.u - hitPoint.v);
x = (point1.x * t) + (point2.x * hitPoint.u) + (point3.x * hitPoint.v);
y = (point1.y * t) + (point2.y * hitPoint.u) + (point3.y * hitPoint.v);
z = (point1.z * t) + (point2.z * hitPoint.u) + (point3.z * hitPoint.v);
<br><br>
Similar calculations can be made for vertex normals, UVs, or any
other vertex attribute. The w component of hitPoint is set to the
distance along the ray at which the intersection occurs.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>theRay</em></tt></dt><dd>The ray to test.</dd>
<dt><tt><em>point1</em></tt></dt><dd>The first triangle vertex.</dd>
<dt><tt><em>point2</em></tt></dt><dd>The second triangle vertex.</dd>
<dt><tt><em>point3</em></tt></dt><dd>The third triangle vertex.</dd>
<dt><tt><em>cullBackfacing</em></tt></dt><dd>Controls if back-facing triangles should be skipped.</dd>
<dt><tt><em>hitPoint</em></tt></dt><dd>Receives the barycentric coordinates of the intersection, and the distance along the ray.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Indicates if the ray intersects the triangle.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3SphericalPoint_Set"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3SphericalPoint_Set">Q3SphericalPoint_Set</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3SphericalPoint * ) Q3SphericalPoint_Set (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3SphericalPoint *sphericalPoint,
&nbsp;&nbsp;&nbsp;&nbsp;float rho,
&nbsp;&nbsp;&nbsp;&nbsp;float theta,
&nbsp;&nbsp;&nbsp;&nbsp;float phi
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 3D spherical-coordinates point.
<br><br>
Available in inline form as Q3FastSphericalPoint_Set.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>sphericalPoint</em></tt></dt><dd>Address of point to set (may be NULL).</dd>
<dt><tt><em>rho</em></tt></dt><dd>Rho coordinate to set into sphericalPoint.</dd>
<dt><tt><em>theta</em></tt></dt><dd>Theta coordinate to set into sphericalPoint.</dd>
<dt><tt><em>phi</em></tt></dt><dd>Phi coordinate to set into sphericalPoint.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of polarPoint parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3SphericalPoint_ToPoint3D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3SphericalPoint_ToPoint3D">Q3SphericalPoint_ToPoint3D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Point3D * ) Q3SphericalPoint_ToPoint3D (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3SphericalPoint *sphericalPoint,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Point3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Convert 3D spherical point to cartesian coordinates.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>sphericalPoint</em></tt></dt><dd>Address of spherical-coordinates point to convert.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of 3D cartesian point to set.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Triangle_CrossProductArray"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Triangle_CrossProductArray">Q3Triangle_CrossProductArray</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Status ) Q3Triangle_CrossProductArray (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 numTriangles,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Uns8 *usageFlags,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Uns32 *theIndices,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Point3D *thePoints,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector3D *theNormals
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Calculate an array of triangle normals.
<br><br>
Triangles are specified as a contiguous array of triangle indices,
and a contiguous array of points. The result is a contiguous array
of triangle normals.
<br><br>
Triangles may be omitted from processing with the usageFlags parameter,
which should point to an array of TQ3Uns8 flags. If usageFlags is not
NULL, only triangles whose corresponding entry in this array is 0 will
be processed.
<br><br>
The returning vectors are normalized.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>numTriangles</em></tt></dt><dd>The number of triangles to process.</dd>
<dt><tt><em>usageFlags</em></tt></dt><dd>The optional usage flags, indicating the triangles to process.</dd>
<dt><tt><em>theIndices</em></tt></dt><dd>The triangle indices.</dd>
<dt><tt><em>thePoints</em></tt></dt><dd>The triangle points.</dd>
<dt><tt><em>theNormals</em></tt></dt><dd>Receives the triangle normals.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Success or failure of the operation.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector2D_Add"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector2D_Add">Q3Vector2D_Add</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector2D * ) Q3Vector2D_Add (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *v1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *v2,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Add two 2D vectors.
<br><br>
Available in inline form as Q3FastVector2D_Add.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>v1</em></tt></dt><dd>Address of first vector to add.</dd>
<dt><tt><em>v2</em></tt></dt><dd>Address of second vector to add.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of vector to set (may be the same as v1 and/or v2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector2D_Cross"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector2D_Cross">Q3Vector2D_Cross</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3Vector2D_Cross (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *v1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *v2
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return the length of the cross product of two 2D vectors.
<br><br>
Equivalently, we assume that the 2D vectors are really 3D vectors with
z=0, then return the z coordinate of the cross product (0,0,z).
<br><br>
Available in inline form as Q3FastVector2D_Cross.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>v1</em></tt></dt><dd>Address of first vector.</dd>
<dt><tt><em>v2</em></tt></dt><dd>Address of second vector.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Length of the 2D cross product.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector2D_Dot"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector2D_Dot">Q3Vector2D_Dot</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3Vector2D_Dot (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *v1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *v2
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return the dot product of two 2D vectors.
<br><br>
Available in inline form as Q3FastVector2D_Dot.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>v1</em></tt></dt><dd>Address of first vector.</dd>
<dt><tt><em>v2</em></tt></dt><dd>Address of second vector.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Dot product of the two vectors.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector2D_Length"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector2D_Length">Q3Vector2D_Length</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3Vector2D_Length (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *vector2D
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return length of 2D vector.
<br><br>
Available in inline form as Q3FastVector2D_Length.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>vector2D</em></tt></dt><dd>Address of vector to get length of.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Length of the given vector.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector2D_LengthSquared"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector2D_LengthSquared">Q3Vector2D_LengthSquared</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3Vector2D_LengthSquared (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *vector2D
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return squared length of 2D vector.
<br><br>
For many operations, knowing the squared length of a vector is just
as good as knowing the actual length (e.g., when sorting a set of
vectors by length, or comparing a vector to a cut-off length).  But
finding the squared length is much faster, since it avoids a costly
square root computation.
<br><br>
Available in inline form as Q3FastVector2D_LengthSquared.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>vector2D</em></tt></dt><dd>Address of vector to get length of.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Squared length of the given vector.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector2D_Negate"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector2D_Negate">Q3Vector2D_Negate</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector2D * ) Q3Vector2D_Negate (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *vector2D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Scale a 2D vector by a factor of -1.
<br><br>
Available in inline form as Q3FastVector2D_Negate.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>vector2D</em></tt></dt><dd>Address of vector to negate.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of vector to set (may be the same as vector2D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector2D_Normalize"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector2D_Normalize">Q3Vector2D_Normalize</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector2D * ) Q3Vector2D_Normalize (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *vector2D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Scale a 2D vector to length 1.
<br><br>
To obtain valid results, the length of vector2D must not be 0.
<br><br>
Available in inline form as Q3FastVector2D_Normalize.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>vector2D</em></tt></dt><dd>Address of vector to normalize.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of vector to set (may be the same as vector2D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector2D_Scale"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector2D_Scale">Q3Vector2D_Scale</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector2D * ) Q3Vector2D_Scale (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *vector2D,
&nbsp;&nbsp;&nbsp;&nbsp;float scalar,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Scale a 2D vector by the given factor.
<br><br>
Available in inline form as Q3FastVector2D_Scale.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>vector2D</em></tt></dt><dd>Address of vector to scale.</dd>
<dt><tt><em>scalar</em></tt></dt><dd>Scaling factor.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of vector to set (may be the same as vector2D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector2D_Set"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector2D_Set">Q3Vector2D_Set</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector2D * ) Q3Vector2D_Set (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector2D *vector2D,
&nbsp;&nbsp;&nbsp;&nbsp;float x,
&nbsp;&nbsp;&nbsp;&nbsp;float y
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 2D vector.
<br><br>
Available in inline form as Q3FastVector2D_Set.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>vector2D</em></tt></dt><dd>Address of vector to set (may be NULL).</dd>
<dt><tt><em>x</em></tt></dt><dd>X coordinate to set into vector2D.</dd>
<dt><tt><em>y</em></tt></dt><dd>Y coordinate to set into vector2D.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of vector2D parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector2D_Subtract"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector2D_Subtract">Q3Vector2D_Subtract</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector2D * ) Q3Vector2D_Subtract (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *v1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *v2,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Subtract 2D vector v2 from v1.
<br><br>
Available in inline form as Q3FastVector2D_Subtract.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>v1</em></tt></dt><dd>Address of first vector.</dd>
<dt><tt><em>v2</em></tt></dt><dd>Address of vector to subtract from v1.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of vector to set (may be the same as v1 and/or v2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector2D_To2DTransformArray"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector2D_To2DTransformArray">Q3Vector2D_To2DTransformArray</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Status ) Q3Vector2D_To2DTransformArray (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *inVectors2D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix3x3 *matrix3x3,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector2D *outVectors2D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 numVectors,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 inStructSize,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 outStructSize
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Transform an array of 2D vectors by a 3x3 matrix.
<br><br>
When you have many vectors to transform, this is a more efficient
alternative to calling Q3Vector2D_Transform repeatedly.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>inVectors2D</em></tt></dt><dd>Array of 2D vectors to transform.</dd>
<dt><tt><em>matrix3x3</em></tt></dt><dd>Transformation matrix.</dd>
<dt><tt><em>outVectors2D</em></tt></dt><dd>Array of vectors to receive output (may be the same as inVectors2D).</dd>
<dt><tt><em>numVectors</em></tt></dt><dd>How many vectors are in each array.</dd>
<dt><tt><em>inStructSize</em></tt></dt><dd>Size of one element of the input array, typically sizeof(TQ3Vector2D).</dd>
<dt><tt><em>outStructSize</em></tt></dt><dd>Size of one element of the output array, typically sizeof(TQ3Vector2D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>kQ3Success or some error code.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector2D_To3D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector2D_To3D">Q3Vector2D_To3D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector3D * ) Q3Vector2D_To3D (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *vector2D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Convert 2D vector to 3D, by setting z to 1.
<br><br>
Note: this operation makes no sense mathematically, but is included
for backward-compatibility with QD3D.  Perhaps the QD3D
implementation was really intended to convert a 2D vector into a 3D
rational point -- see QDPoint2D_To3D, which does exactly that.
<br><br>
Available in inline form as Q3FastVector2D_To3D.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>vector2D</em></tt></dt><dd>Address of 2D vector to convert.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of 3D vector to set.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector2D_ToRationalPoint3D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector2D_ToRationalPoint3D">Q3Vector2D_ToRationalPoint3D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3RationalPoint3D * ) Q3Vector2D_ToRationalPoint3D (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *vector2D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3RationalPoint3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Convert 2D vector to 3D rational point, setting w to 0.
<br><br>
Available in inline form as Q3FastVector2D_ToRationalPoint3D.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>vector2D</em></tt></dt><dd>Address of 2D vector to convert.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of 3D rational point to set.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector2D_Transform"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector2D_Transform">Q3Vector2D_Transform</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector2D * ) Q3Vector2D_Transform (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector2D *vector2D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix3x3 *matrix3x3,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Transform a 2D vector by a 3x3 matrix.
<br><br>
Note that the translation and perspective components of the
matrix is ignored (as if it were really a 2x2 matrix).
<br><br>
Contrast with Q3Point2D_Transform, which does the full 3x3
transformation.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>vector2D</em></tt></dt><dd>Address of a vector to transform.</dd>
<dt><tt><em>matrix3x3</em></tt></dt><dd>Address of a 3x3 transformation matrix.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of vector to set (may be the same as vector2D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector3D_Add"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector3D_Add">Q3Vector3D_Add</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector3D * ) Q3Vector3D_Add (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *v1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *v2,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Add two 3D vectors.
<br><br>
Available in inline form as Q3FastVector3D_Add.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>v1</em></tt></dt><dd>Address of first vector to add.</dd>
<dt><tt><em>v2</em></tt></dt><dd>Address of second vector to add.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of vector to set (may be the same as v1 and/or v2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector3D_Cross"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector3D_Cross">Q3Vector3D_Cross</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector3D * ) Q3Vector3D_Cross (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *v1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *v2,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return 3D cross product of two 3D vectors.
<br><br>
Available in inline form as Q3FastVector3D_Cross.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>v1</em></tt></dt><dd>Address of first vector.</dd>
<dt><tt><em>v2</em></tt></dt><dd>Address of second vector.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of vector to set with the result;
may be the same address as v1 and/or v2.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector3D_Dot"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector3D_Dot">Q3Vector3D_Dot</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3Vector3D_Dot (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *v1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *v2
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return the dot product of two 3D vectors.
<br><br>
Available in inline form as Q3FastVector3D_Dot.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>v1</em></tt></dt><dd>Address of first vector.</dd>
<dt><tt><em>v2</em></tt></dt><dd>Address of second vector.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Dot product of the two vectors.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector3D_DotArray"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector3D_DotArray">Q3Vector3D_DotArray</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Status ) Q3Vector3D_DotArray (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *inFirstVectors3D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *inSecondVectors3D,
&nbsp;&nbsp;&nbsp;&nbsp;float *outDotProducts,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Boolean *outDotLessThanZeros,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 numVectors,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 inStructSize,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 outDotProductStructSize,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 outDotLessThanZeroStructSize
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Calculate an array of dot products.
<br><br>
Given two arrays of vectors, an array of dot products is returned along
with an array of TQ3Booleans indicating which dot products are less than
zero.
<br><br>
At least one of dotProducts or dotLessThanZero must be non-NULL, however
one parameter may be set to NULL if that information is not required.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>inFirstVectors3D</em></tt></dt><dd>First array of 3D vectors to dot.</dd>
<dt><tt><em>inSecondVectors3D</em></tt></dt><dd>Second array of 3D vectors to dot.</dd>
<dt><tt><em>outDotProducts</em></tt></dt><dd>Array of scalars to receive the dot products.</dd>
<dt><tt><em>outDotLessThanZeros</em></tt></dt><dd>Array of booleans to receive the "< 0.0" status of the dot products.</dd>
<dt><tt><em>numVectors</em></tt></dt><dd>How many elements are in each array.</dd>
<dt><tt><em>inStructSize</em></tt></dt><dd>Size of one element of input arrays, typically sizeof(TQ3Vector3D).</dd>
<dt><tt><em>outDotProductStructSize</em></tt></dt><dd>Size of one element of the outDotProducts array, typically sizeof(float).</dd>
<dt><tt><em>outDotLessThanZeroStructSize</em></tt></dt><dd>Size of one element of the outDotLessThanZeros array, typically sizeof(TQ3Boolean).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>kQ3Success or some error code.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector3D_Length"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector3D_Length">Q3Vector3D_Length</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3Vector3D_Length (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *vector3D
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return length of 2D vector.
<br><br>
Available in inline form as Q3FastVector3D_Length.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>vector3D</em></tt></dt><dd>Address of vector to get length of.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Length of the given vector.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector3D_LengthSquared"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector3D_LengthSquared">Q3Vector3D_LengthSquared</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( float ) Q3Vector3D_LengthSquared (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *vector3D
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Return squared length of 2D vector.
<br><br>
For many operations, knowing the squared length of a vector is just
as good as knowing the actual length (e.g., when sorting a set of
vectors by length, or comparing a vector to a cut-off length).  But
finding the squared length is much faster, since it avoids a costly
square root computation.
<br><br>
Available in inline form as Q3FastVector3D_LengthSquared.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>vector3D</em></tt></dt><dd>Address of vector to get length of.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Squared length of the given vector.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector3D_Negate"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector3D_Negate">Q3Vector3D_Negate</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector3D * ) Q3Vector3D_Negate (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *vector3D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Scale a 3D vector by a factor of -1.
<br><br>
Available in inline form as Q3FastVector3D_Negate.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>vector3D</em></tt></dt><dd>Address of vector to negate.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of vector to set (may be the same as vector3D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector3D_Normalize"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector3D_Normalize">Q3Vector3D_Normalize</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector3D * ) Q3Vector3D_Normalize (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *vector3D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Scale a 3D vector to length 1.
<br><br>
To obtain valid results, the length of vector3D must not be 0.
<br><br>
Available in inline form as Q3FastVector3D_Normalize.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>vector3D</em></tt></dt><dd>Address of vector to normalize.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of vector to set (may be the same as vector3D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector3D_Scale"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector3D_Scale">Q3Vector3D_Scale</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector3D * ) Q3Vector3D_Scale (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *vector3D,
&nbsp;&nbsp;&nbsp;&nbsp;float scalar,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Scale a 3D vector by the given factor.
<br><br>
Available in inline form as Q3FastVector3D_Scale.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>vector3D</em></tt></dt><dd>Address of vector to scale.</dd>
<dt><tt><em>scalar</em></tt></dt><dd>Scaling factor.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of vector to set (may be the same as vector3D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector3D_Set"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector3D_Set">Q3Vector3D_Set</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector3D * ) Q3Vector3D_Set (
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector3D *vector3D,
&nbsp;&nbsp;&nbsp;&nbsp;float x,
&nbsp;&nbsp;&nbsp;&nbsp;float y,
&nbsp;&nbsp;&nbsp;&nbsp;float z
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Set a 3D vector.
<br><br>
Available in inline form as Q3FastVector3D_Set.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>vector3D</em></tt></dt><dd>Address of vector to set (may be NULL).</dd>
<dt><tt><em>x</em></tt></dt><dd>X coordinate to set into vector3D.</dd>
<dt><tt><em>y</em></tt></dt><dd>Y coordinate to set into vector3D.</dd>
<dt><tt><em>z</em></tt></dt><dd>Z coordinate to set into vector3D.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of vector3D parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector3D_Subtract"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector3D_Subtract">Q3Vector3D_Subtract</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector3D * ) Q3Vector3D_Subtract (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *v1,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *v2,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Subtract 3D vector v2 from v1.
<br><br>
Available in inline form as Q3FastVector3D_Subtract.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>v1</em></tt></dt><dd>Address of first vector.</dd>
<dt><tt><em>v2</em></tt></dt><dd>Address of vector to subtract from v1.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of vector to set (may be the same as v1 and/or v2).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector3D_To2D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector3D_To2D">Q3Vector3D_To2D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector2D * ) Q3Vector3D_To2D (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *vector3D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector2D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Convert 3D vector to 2D, dividing by z.
<br><br>
Note: this operation makes no sense mathematically, but is included
for backward-compatibility with QD3D.  It's possible that the QD3D
function was really intended to convert a 3D rational point to a
2D vector -- see E3RationalPoint3D_To2D, which does the same thing
for a 2D point.
<br><br>
Available in inline form as Q3FastVector3D_To2D.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>vector3D</em></tt></dt><dd>Address of 3D vector to convert.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of 2D vector to set.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector3D_To3DTransformArray"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector3D_To3DTransformArray">Q3Vector3D_To3DTransformArray</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Status ) Q3Vector3D_To3DTransformArray (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *inVectors3D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector3D *outVectors3D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 numVectors,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 inStructSize,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Uns32 outStructSize
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Transform an array of 3D vectors by a 4x4 matrix.
<br><br>
When you have many vectors to transform, this is a more efficient
alternative to calling Q3Vector3D_Transform repeatedly.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>inVectors3D</em></tt></dt><dd>Array of 3D vectors to transform.</dd>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Transformation matrix.</dd>
<dt><tt><em>outVectors3D</em></tt></dt><dd>Array of vectors to receive output (may be the same as inVectors3D).</dd>
<dt><tt><em>numVectors</em></tt></dt><dd>How many vectors are in each array.</dd>
<dt><tt><em>inStructSize</em></tt></dt><dd>Size of one element of the input array, typically sizeof(TQ3Vector3D).</dd>
<dt><tt><em>outStructSize</em></tt></dt><dd>Size of one element of the output array, typically sizeof(TQ3Vector3D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>kQ3Success or some error code.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector3D_ToRationalPoint4D"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector3D_ToRationalPoint4D">Q3Vector3D_ToRationalPoint4D</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3RationalPoint4D * ) Q3Vector3D_ToRationalPoint4D (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *vector3D,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3RationalPoint4D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Convert 3D vector to 4D rational point, setting w to 0.
<br><br>
Available in inline form as Q3FastVector3D_ToRationalPoint4D.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>vector3D</em></tt></dt><dd>Address of 3D vector to convert.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of 4D rational point to set.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector3D_Transform"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector3D_Transform">Q3Vector3D_Transform</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector3D * ) Q3Vector3D_Transform (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *vector3D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Matrix4x4 *matrix4x4,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Transform a 3D vector by a 4x4 matrix.
<br><br>
Note that the translation and perspective components of the
matrix is ignored (as if it were really a 3x3 matrix).
<br><br>
Contrast with Q3Point3D_Transform, which does the full 4x4
transformation.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>vector3D</em></tt></dt><dd>Address of a vector to transform.</dd>
<dt><tt><em>matrix4x4</em></tt></dt><dd>Address of a 4x4 transformation matrix.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of vector to set (may be the same as vector3D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<hr><a name="//Quesa/c/func/Q3Vector3D_TransformQuaternion"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Q3Vector3D_TransformQuaternion">Q3Vector3D_TransformQuaternion</a></h2>
</td></tr></table><hr><blockquote><pre><tt>( TQ3Vector3D * ) Q3Vector3D_TransformQuaternion (
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Vector3D *vector3D,
&nbsp;&nbsp;&nbsp;&nbsp;const TQ3Quaternion *quaternion,
&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vector3D *result
);</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Transform a 3D vector by a quaternion.
<br><br>
Note that for correct results, the quaternion should be normalized.
<br><br>
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>vector3D</em></tt></dt><dd>Address of a vector to transform.</dd>
<dt><tt><em>quaternion</em></tt></dt><dd>Address of a quaternion to transform by.</dd>
<dt><tt><em>result</em></tt></dt><dd>Address of a vector to set (may be the same as vector3D).</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Convenience copy of result parameter.
 </dd></dl>
<p><p>&#169; 1999-2006 Quesa Developers (Last Updated 4/22/2006)
</p></body></html>
