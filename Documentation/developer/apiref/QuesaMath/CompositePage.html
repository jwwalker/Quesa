<html><head><title>QuesaMath.h</title></head><body background="../../../images/logo_gray.gif" bgcolor="#ffffff"><font face="Geneva,Arial,Helvtica"><h1>QuesaMath.h</h1></font><hr><br>
<h2>Discussion</h2>
Declares the Quesa math utilities.
 <hr><br><h2>Functions</h2>
<a name="//apple_ref/c/func/Q3BoundingBox_Copy"></a>
<h3><a name="Q3BoundingBox_Copy">Q3BoundingBox_Copy</a></h3>
<blockquote><pre><tt>TQ3BoundingBox * 
Q3BoundingBox_Copy (
    const TQ3BoundingBox          *bBox,
    TQ3BoundingBox                *result
);
</tt><br>
</pre></blockquote>
<p>Copy a bounding box.
<br><br>
Available in inline form as Q3BFastoundingBox_Copy.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bBox</tt></td><td>Address of source bounding box.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of bounding box to set (may be the same as bBox).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingBox_Set"></a>
<h3><a name="Q3BoundingBox_Set">Q3BoundingBox_Set</a></h3>
<blockquote><pre><tt>TQ3BoundingBox * 
Q3BoundingBox_Set (
    TQ3BoundingBox                *bBox,
    const TQ3Point3D              *min,
    const TQ3Point3D              *max,
    TQ3Boolean                    isEmpty
);
</tt><br>
</pre></blockquote>
<p>Set a bounding box.
<br><br>
Available in inline form as Q3FastBoundingBox_Set.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bBox</tt></td><td>Address of bounding box to set.</td></tr>
<tr valign=top><td><tt>min</tt></td><td>Address of point indicating minimum X, Y, and Z.</td></tr>
<tr valign=top><td><tt>max</tt></td><td>Address of point indicating maximum X, Y, and Z.</td></tr>
<tr valign=top><td><tt>isEmpty</tt></td><td>True of the bounding box is empty, false otherwise.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of bBox parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingBox_SetFromPoints3D"></a>
<h3><a name="Q3BoundingBox_SetFromPoints3D">Q3BoundingBox_SetFromPoints3D</a></h3>
<blockquote><pre><tt>TQ3BoundingBox * 
Q3BoundingBox_SetFromPoints3D (
    TQ3BoundingBox                *bBox,
    const TQ3Point3D              *points3D,
    TQ3Uns32                      numPoints,
    TQ3Uns32                      structSize
);
</tt><br>
</pre></blockquote>
<p>Set a bounding box to just enclose a set of 3D points.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bBox</tt></td><td>Address of bounding box to set.</td></tr>
<tr valign=top><td><tt>points3D</tt></td><td>Array of 3D points.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many points are in the array.</td></tr>
<tr valign=top><td><tt>structSize</tt></td><td>Size of each array element, typically sizeof(TQ3Point3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of bBox parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingBox_SetFromRationalPoints4D"></a>
<h3><a name="Q3BoundingBox_SetFromRationalPoints4D">Q3BoundingBox_SetFromRationalPoints4D</a></h3>
<blockquote><pre><tt>TQ3BoundingBox * 
Q3BoundingBox_SetFromRationalPoints4D (
    TQ3BoundingBox                *bBox,
    const TQ3RationalPoint4D      *rationalPoints4D,
    TQ3Uns32                      numPoints,
    TQ3Uns32                      structSize
);
</tt><br>
</pre></blockquote>
<p>Set a bounding box to just enclose a set of 4D rational points.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bBox</tt></td><td>Address of bounding box to set.</td></tr>
<tr valign=top><td><tt>rationalPoints4D</tt></td><td>Array of 4D rational points.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many points are in the array.</td></tr>
<tr valign=top><td><tt>structSize</tt></td><td>Size of each array element, typically sizeof(TQ3RationalPoint4D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of bBox parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingBox_Union"></a>
<h3><a name="Q3BoundingBox_Union">Q3BoundingBox_Union</a></h3>
<blockquote><pre><tt>TQ3BoundingBox * 
Q3BoundingBox_Union (
    const TQ3BoundingBox          *b1,
    const TQ3BoundingBox          *b2,
    TQ3BoundingBox                *result
);
</tt><br>
</pre></blockquote>
<p>Compute the minimum bounding box that encloses both 'b1' and 'b2'.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>b1</tt></td><td>Address of one bounding box.</td></tr>
<tr valign=top><td><tt>b2</tt></td><td>Address of another bounding box.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of bounding box to set (may be the same as b1 and/or b2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingBox_UnionPoint3D"></a>
<h3><a name="Q3BoundingBox_UnionPoint3D">Q3BoundingBox_UnionPoint3D</a></h3>
<blockquote><pre><tt>TQ3BoundingBox * 
Q3BoundingBox_UnionPoint3D (
    const TQ3BoundingBox          *bBox,
    const TQ3Point3D              *point3D,
    TQ3BoundingBox                *result
);
</tt><br>
</pre></blockquote>
<p>Return the minimum bounding box that encloses both 'bBox' and 'point3D'.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bBox</tt></td><td>Address of initial bounding box.</td></tr>
<tr valign=top><td><tt>point3D</tt></td><td>Address of a point to enclose.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of bounding box to set (may be the same as bBox).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingBox_UnionRationalPoint4D"></a>
<h3><a name="Q3BoundingBox_UnionRationalPoint4D">Q3BoundingBox_UnionRationalPoint4D</a></h3>
<blockquote><pre><tt>TQ3BoundingBox * 
Q3BoundingBox_UnionRationalPoint4D (
    const TQ3BoundingBox          *bBox,
    const TQ3RationalPoint4D      *rationalPoint4D,
    TQ3BoundingBox                *result
);
</tt><br>
</pre></blockquote>
<p>Return the minimum bounding box that encloses both 'bBox' and 'rationalPoint4D'.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bBox</tt></td><td>Address of initial bounding box.</td></tr>
<tr valign=top><td><tt>rationalPoint4D</tt></td><td>Address of a point to enclose.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of bounding box to set (may be the same as bBox).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingSphere_Copy"></a>
<h3><a name="Q3BoundingSphere_Copy">Q3BoundingSphere_Copy</a></h3>
<blockquote><pre><tt>TQ3BoundingSphere * 
Q3BoundingSphere_Copy (
    const TQ3BoundingSphere       *bSphere,
    TQ3BoundingSphere             *result
);
</tt><br>
</pre></blockquote>
<p>Copy a bounding sphere.
<br><br>
Available in inline form as Q3FastBoundingSphere_Copy.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bSphere</tt></td><td>Address of source bounding sphere.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of bounding sphere to set (may be the same as bSphere).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingSphere_Set"></a>
<h3><a name="Q3BoundingSphere_Set">Q3BoundingSphere_Set</a></h3>
<blockquote><pre><tt>TQ3BoundingSphere * 
Q3BoundingSphere_Set (
    TQ3BoundingSphere             *bSphere,
    const TQ3Point3D              *origin,
    float                         radius,
    TQ3Boolean                    isEmpty
);
</tt><br>
</pre></blockquote>
<p>Set a bounding sphere.
<br><br>
Available in inline form as Q3FastBoundingSphere_Set.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bSphere</tt></td><td>Address of bounding sphere to set.</td></tr>
<tr valign=top><td><tt>origin</tt></td><td>Address of point indicating sphere origin.</td></tr>
<tr valign=top><td><tt>radius</tt></td><td>Sphere radius.</td></tr>
<tr valign=top><td><tt>isEmpty</tt></td><td>True of the bounding sphere is empty, false otherwise.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of bSphere parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingSphere_SetFromPoints3D"></a>
<h3><a name="Q3BoundingSphere_SetFromPoints3D">Q3BoundingSphere_SetFromPoints3D</a></h3>
<blockquote><pre><tt>TQ3BoundingSphere * 
Q3BoundingSphere_SetFromPoints3D (
    TQ3BoundingSphere             *bSphere,
    const TQ3Point3D              *points3D,
    TQ3Uns32                      numPoints,
    TQ3Uns32                      structSize
);
</tt><br>
</pre></blockquote>
<p>Set a bounding sphere to just enclose a set of 3D points.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bSphere</tt></td><td>Description of the parameter.</td></tr>
<tr valign=top><td><tt>points3D</tt></td><td>Array of 3D points.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many points are in the array.</td></tr>
<tr valign=top><td><tt>structSize</tt></td><td>Size of each array element, typically sizeof(TQ3Point3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of bSphere parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingSphere_SetFromRationalPoints4D"></a>
<h3><a name="Q3BoundingSphere_SetFromRationalPoints4D">Q3BoundingSphere_SetFromRationalPoints4D</a></h3>
<blockquote><pre><tt>TQ3BoundingSphere * 
Q3BoundingSphere_SetFromRationalPoints4D (
    TQ3BoundingSphere             *bSphere,
    const TQ3RationalPoint4D      *rationalPoints4D,
    TQ3Uns32                      numPoints,
    TQ3Uns32                      structSize
);
</tt><br>
</pre></blockquote>
<p>Set a bounding sphere to just enclose a set of 4D rational points.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bSphere</tt></td><td>Address of bounding sphere to set.</td></tr>
<tr valign=top><td><tt>rationalPoints4D</tt></td><td>Array of 4D rational points.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many points are in the array.</td></tr>
<tr valign=top><td><tt>structSize</tt></td><td>Size of each array element, typically sizeof(TQ3RationalPoint4D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of bSphere parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingSphere_Union"></a>
<h3><a name="Q3BoundingSphere_Union">Q3BoundingSphere_Union</a></h3>
<blockquote><pre><tt>TQ3BoundingSphere * 
Q3BoundingSphere_Union (
    const TQ3BoundingSphere       *s1,
    const TQ3BoundingSphere       *s2,
    TQ3BoundingSphere             *result
);
</tt><br>
</pre></blockquote>
<p>Compute the minimum bounding sphere that encloses both 's1' and 's2'.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>s1</tt></td><td>Address of one bounding sphere.</td></tr>
<tr valign=top><td><tt>s2</tt></td><td>Address of another bounding sphere.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of bounding sphere to set (may be the same as s1 and/or s2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingSphere_UnionPoint3D"></a>
<h3><a name="Q3BoundingSphere_UnionPoint3D">Q3BoundingSphere_UnionPoint3D</a></h3>
<blockquote><pre><tt>TQ3BoundingSphere * 
Q3BoundingSphere_UnionPoint3D (
    const TQ3BoundingSphere       *bSphere,
    const TQ3Point3D              *point3D,
    TQ3BoundingSphere             *result
);
</tt><br>
</pre></blockquote>
<p>Return the minimum bounding sphere that encloses both 'bSphere' and 'point3D'.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bSphere</tt></td><td>Address of initial bounding sphere.</td></tr>
<tr valign=top><td><tt>point3D</tt></td><td>Address of a point to enclose.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of bounding sphere to set (may be the same as bSphere).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3BoundingSphere_UnionRationalPoint4D"></a>
<h3><a name="Q3BoundingSphere_UnionRationalPoint4D">Q3BoundingSphere_UnionRationalPoint4D</a></h3>
<blockquote><pre><tt>TQ3BoundingSphere * 
Q3BoundingSphere_UnionRationalPoint4D (
    const TQ3BoundingSphere       *bSphere,
    const TQ3RationalPoint4D      *rationalPoint4D,
    TQ3BoundingSphere             *result
);
</tt><br>
</pre></blockquote>
<p>Return the minimum bounding sphere that encloses both 'bSphere' and 'rationalPoint4D'.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>bSphere</tt></td><td>Address of initial bounding sphere.</td></tr>
<tr valign=top><td><tt>rationalPoint4D</tt></td><td>Address of a point to enclose.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of bounding sphere to set (may be the same as bSphere).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Math_InvSquareRoot"></a>
<h3><a name="Q3Math_InvSquareRoot">Q3Math_InvSquareRoot</a></h3>
<blockquote><pre><tt>float  
Q3Math_InvSquareRoot (
    float                         x
);
</tt><br>
</pre></blockquote>
<p>Obtain a fast, but possibly inaccurate, inverse square root.
<br><br>
The available precision depends on the current architecture, but will
suffice for most non-accumulating 3D operations. If a reliable degree
of precision is required, 1.0/sqrt() should be used instead.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>x</tt></td><td>The number whose inverse square root should be returned.</td></tr>
</table>
</blockquote>
<b>Result:</b> Approximate inverse square root of x.
 
<hr>
<a name="//apple_ref/c/func/Q3Math_SquareRoot"></a>
<h3><a name="Q3Math_SquareRoot">Q3Math_SquareRoot</a></h3>
<blockquote><pre><tt>float  
Q3Math_SquareRoot (
    float                         x
);
</tt><br>
</pre></blockquote>
<p>Obtain a fast, but possibly inaccurate, square root.
<br><br>
The available precision depends on the current architecture, but will
suffice for most non-accumulating 3D operations. If a reliable degree
of precision is required, sqrt() should be used instead.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>x</tt></td><td>The number whose square root should be returned.</td></tr>
</table>
</blockquote>
<b>Result:</b> Approximate square root of x.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_Adjoint"></a>
<h3><a name="Q3Matrix3x3_Adjoint">Q3Matrix3x3_Adjoint</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_Adjoint (
    const TQ3Matrix3x3            *matrix3x3,
    TQ3Matrix3x3                  *result
);
</tt><br>
</pre></blockquote>
<p>Calculate adjoint of 3x3 matrix.
<br><br>
The adjoint of a matrix is a scalar multiple of the inverse of
the matrix. For some applications, the adjoint can be used in
place of the inverse. In particular:
<br><br>
adjoint(A) = determinant(A) * inverse(A)
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of a matrix to calculate the adjoint of.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of matrix to set (may be the same as matrix3x3).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_Copy"></a>
<h3><a name="Q3Matrix3x3_Copy">Q3Matrix3x3_Copy</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_Copy (
    const TQ3Matrix3x3            *matrix3x3,
    TQ3Matrix3x3                  *result
);
</tt><br>
</pre></blockquote>
<p>Copy a 3x3 matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of source matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of destination matrix (may be the same as matrix3x3).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_Determinant"></a>
<h3><a name="Q3Matrix3x3_Determinant">Q3Matrix3x3_Determinant</a></h3>
<blockquote><pre><tt>float  
Q3Matrix3x3_Determinant (
    const TQ3Matrix3x3            *matrix3x3
);
</tt><br>
</pre></blockquote>
<p>Return the determinant of 3x3 matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of a matrix.</td></tr>
</table>
</blockquote>
<b>Result:</b> Determinant of that matrix.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_Invert"></a>
<h3><a name="Q3Matrix3x3_Invert">Q3Matrix3x3_Invert</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_Invert (
    const TQ3Matrix3x3            *matrix3x3,
    TQ3Matrix3x3                  *result
);
</tt><br>
</pre></blockquote>
<p>Calculate the inverse of a 3x3 non-singular matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of non-singular matrix to invert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of matrix to set (may be the same as matrix3x3).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_Multiply"></a>
<h3><a name="Q3Matrix3x3_Multiply">Q3Matrix3x3_Multiply</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_Multiply (
    const TQ3Matrix3x3            *m1,
    const TQ3Matrix3x3            *m2,
    TQ3Matrix3x3                  *result
);
</tt><br>
</pre></blockquote>
<p>Multiply two 3x3 matrices.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>m1</tt></td><td>Address of first matrix.</td></tr>
<tr valign=top><td><tt>m2</tt></td><td>Address of second matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of matrix to set with m1*m2 (may be the same as m1 and/or m2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_SetIdentity"></a>
<h3><a name="Q3Matrix3x3_SetIdentity">Q3Matrix3x3_SetIdentity</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_SetIdentity (
    TQ3Matrix3x3                  *matrix3x3
);
</tt><br>
</pre></blockquote>
<p>Set a 3x3 matrix to the identity matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of matrix to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix3x3 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_SetRotate"></a>
<h3><a name="Q3Matrix3x3_SetRotate">Q3Matrix3x3_SetRotate</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_SetRotate (
    TQ3Matrix3x3                  *matrix3x3,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set a 3x3 matrix to rotate about the origin.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix3x3 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_SetRotateAboutPoint"></a>
<h3><a name="Q3Matrix3x3_SetRotateAboutPoint">Q3Matrix3x3_SetRotateAboutPoint</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_SetRotateAboutPoint (
    TQ3Matrix3x3                  *matrix3x3,
    const TQ3Point2D              *origin,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set a 3x3 matrix to rotate about a point.
<br><br>
This is equivalent to translating the point to the origin,
doing a rotation about the origin, and translating back.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>origin</tt></td><td>Address of a 2D point about which to rotate.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix3x3 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_SetScale"></a>
<h3><a name="Q3Matrix3x3_SetScale">Q3Matrix3x3_SetScale</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_SetScale (
    TQ3Matrix3x3                  *matrix3x3,
    float                         xScale,
    float                         yScale
);
</tt><br>
</pre></blockquote>
<p>Set 3x3 matrix to scale in x, y.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>xScale</tt></td><td>Amount to scale in x.</td></tr>
<tr valign=top><td><tt>yScale</tt></td><td>Amount to scale in y.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix3x3 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_SetTranslate"></a>
<h3><a name="Q3Matrix3x3_SetTranslate">Q3Matrix3x3_SetTranslate</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_SetTranslate (
    TQ3Matrix3x3                  *matrix3x3,
    float                         xTrans,
    float                         yTrans
);
</tt><br>
</pre></blockquote>
<p>Set a 3x3 matrix to translate in x, y.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>xTrans</tt></td><td>Amount to translate in x.</td></tr>
<tr valign=top><td><tt>yTrans</tt></td><td>Amount to translate in y.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix3x3 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix3x3_Transpose"></a>
<h3><a name="Q3Matrix3x3_Transpose">Q3Matrix3x3_Transpose</a></h3>
<blockquote><pre><tt>TQ3Matrix3x3 * 
Q3Matrix3x3_Transpose (
    const TQ3Matrix3x3            *matrix3x3,
    TQ3Matrix3x3                  *result
);
</tt><br>
</pre></blockquote>
<p>Transpose a 3x3 matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of a matrix to transpose.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of matrix to set (may be the same as matrix3x3).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_Copy"></a>
<h3><a name="Q3Matrix4x4_Copy">Q3Matrix4x4_Copy</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_Copy (
    const TQ3Matrix4x4            *matrix4x4,
    TQ3Matrix4x4                  *result
);
</tt><br>
</pre></blockquote>
<p>Copy a 4x4 matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of source matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of destination matrix (may be the same as matrix4x4).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_Determinant"></a>
<h3><a name="Q3Matrix4x4_Determinant">Q3Matrix4x4_Determinant</a></h3>
<blockquote><pre><tt>float  
Q3Matrix4x4_Determinant (
    const TQ3Matrix4x4            *matrix4x4
);
</tt><br>
</pre></blockquote>
<p>Return the determinant of 4x4 matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of a matrix.</td></tr>
</table>
</blockquote>
<b>Result:</b> Determinant of that matrix.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_Invert"></a>
<h3><a name="Q3Matrix4x4_Invert">Q3Matrix4x4_Invert</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_Invert (
    const TQ3Matrix4x4            *matrix4x4,
    TQ3Matrix4x4                  *result
);
</tt><br>
</pre></blockquote>
<p>Calculate the inverse of a 4x4 non-singular matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of non-singular matrix to invert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of matrix to set (may be the same as matrix4x4).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_Multiply"></a>
<h3><a name="Q3Matrix4x4_Multiply">Q3Matrix4x4_Multiply</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_Multiply (
    const TQ3Matrix4x4            *m1,
    const TQ3Matrix4x4            *m2,
    TQ3Matrix4x4                  *result
);
</tt><br>
</pre></blockquote>
<p>Multiply two 4x4 matrices.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>m1</tt></td><td>Address of first matrix.</td></tr>
<tr valign=top><td><tt>m2</tt></td><td>Address of second matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of matrix to set with m1*m2 (may be the same as m1 and/or m2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetIdentity"></a>
<h3><a name="Q3Matrix4x4_SetIdentity">Q3Matrix4x4_SetIdentity</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetIdentity (
    TQ3Matrix4x4                  *matrix4x4
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix to the identity matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetQuaternion"></a>
<h3><a name="Q3Matrix4x4_SetQuaternion">Q3Matrix4x4_SetQuaternion</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetQuaternion (
    TQ3Matrix4x4                  *matrix4x4,
    const TQ3Quaternion           *quaternion
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix from to the rotation represented by a quaternion.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of the quaternion to imitate.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetRotateAboutAxis"></a>
<h3><a name="Q3Matrix4x4_SetRotateAboutAxis">Q3Matrix4x4_SetRotateAboutAxis</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetRotateAboutAxis (
    TQ3Matrix4x4                  *matrix4x4,
    const TQ3Point3D              *origin,
    const TQ3Vector3D             *axis,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set 4x4 matrix to rotate about an arbitrary origin and axis.
<br><br>
Note that for correct results, the axis should be normalized
(i.e. have length = 1).
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>origin</tt></td><td>Address of a 2D point about which to rotate.</td></tr>
<tr valign=top><td><tt>axis</tt></td><td>Address of a 3D vector to use as the rotation axis.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetRotateAboutPoint"></a>
<h3><a name="Q3Matrix4x4_SetRotateAboutPoint">Q3Matrix4x4_SetRotateAboutPoint</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetRotateAboutPoint (
    TQ3Matrix4x4                  *matrix4x4,
    const TQ3Point3D              *origin,
    float                         xAngle,
    float                         yAngle,
    float                         zAngle
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix to rotate about axes through apoint and 
parallel to the X, Y, and Z axes (in that order).
<br><br>
This order of rotations is rarely useful, but it's kept for backwards
compatibility with QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>origin</tt></td><td>Address of a 3D point about which to rotate.</td></tr>
<tr valign=top><td><tt>xAngle</tt></td><td>Angle to rotate about the translated X axis (in radians).</td></tr>
<tr valign=top><td><tt>yAngle</tt></td><td>Angle to rotate about the translated Y axis (in radians).</td></tr>
<tr valign=top><td><tt>zAngle</tt></td><td>Angle to rotate about the translated Z axis (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetRotateVectorToVector"></a>
<h3><a name="Q3Matrix4x4_SetRotateVectorToVector">Q3Matrix4x4_SetRotateVectorToVector</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetRotateVectorToVector (
    TQ3Matrix4x4                  *matrix4x4,
    const TQ3Vector3D             *v1,
    const TQ3Vector3D             *v2
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix to rotate vector 'v1' to 'v2'.
<br><br>
Note that for correct results, both vectors should be normalized
(i.e. have length = 1).
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>v1</tt></td><td>Address of "starting" vector.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of "ending" vector.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetRotate_X"></a>
<h3><a name="Q3Matrix4x4_SetRotate_X">Q3Matrix4x4_SetRotate_X</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetRotate_X (
    TQ3Matrix4x4                  *matrix4x4,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix to rotate about the X axis.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetRotate_XYZ"></a>
<h3><a name="Q3Matrix4x4_SetRotate_XYZ">Q3Matrix4x4_SetRotate_XYZ</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetRotate_XYZ (
    TQ3Matrix4x4                  *matrix4x4,
    float                         xAngle,
    float                         yAngle,
    float                         zAngle
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix to rotate about the X, Y, Z axes (in that order).
<br><br>
This order of rotations is rarely useful, but it's kept for backwards
compatibility with QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>xAngle</tt></td><td>Angle to rotate about the X axis (in radians).</td></tr>
<tr valign=top><td><tt>yAngle</tt></td><td>Angle to rotate about the Y axis (in radians).</td></tr>
<tr valign=top><td><tt>zAngle</tt></td><td>Angle to rotate about the Z axis (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetRotate_Y"></a>
<h3><a name="Q3Matrix4x4_SetRotate_Y">Q3Matrix4x4_SetRotate_Y</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetRotate_Y (
    TQ3Matrix4x4                  *matrix4x4,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix to rotate about the Y axis.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetRotate_Z"></a>
<h3><a name="Q3Matrix4x4_SetRotate_Z">Q3Matrix4x4_SetRotate_Z</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetRotate_Z (
    TQ3Matrix4x4                  *matrix4x4,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix to rotate about the Z axis.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetScale"></a>
<h3><a name="Q3Matrix4x4_SetScale">Q3Matrix4x4_SetScale</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetScale (
    TQ3Matrix4x4                  *matrix4x4,
    float                         xScale,
    float                         yScale,
    float                         zScale
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix to scale in x, y, z.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>xScale</tt></td><td>Amount to scale in x.</td></tr>
<tr valign=top><td><tt>yScale</tt></td><td>Amount to scale in y.</td></tr>
<tr valign=top><td><tt>zScale</tt></td><td>Amount to scale in z.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_SetTranslate"></a>
<h3><a name="Q3Matrix4x4_SetTranslate">Q3Matrix4x4_SetTranslate</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_SetTranslate (
    TQ3Matrix4x4                  *matrix4x4,
    float                         xTrans,
    float                         yTrans,
    float                         zTrans
);
</tt><br>
</pre></blockquote>
<p>Set a 4x4 matrix to translate in x, y, z.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of matrix to set.</td></tr>
<tr valign=top><td><tt>xTrans</tt></td><td>Amount to translate in x.</td></tr>
<tr valign=top><td><tt>yTrans</tt></td><td>Amount to translate in y.</td></tr>
<tr valign=top><td><tt>zTrans</tt></td><td>Amount to translate in z.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of matrix4x4 parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Matrix4x4_Transpose"></a>
<h3><a name="Q3Matrix4x4_Transpose">Q3Matrix4x4_Transpose</a></h3>
<blockquote><pre><tt>TQ3Matrix4x4 * 
Q3Matrix4x4_Transpose (
    const TQ3Matrix4x4            *matrix4x4,
    TQ3Matrix4x4                  *result
);
</tt><br>
</pre></blockquote>
<p>Transpose a 4x4 matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of a matrix to transpose.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of matrix to set (may be the same as matrix4x4).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Param2D_AffineComb"></a>
<h3><a name="Q3Param2D_AffineComb">Q3Param2D_AffineComb</a></h3>
<blockquote><pre><tt>TQ3Param2D * 
Q3Param2D_AffineComb (
    const TQ3Param2D              *params2D,
    const float                   *weights,
    TQ3Uns32                      numPoints,
    TQ3Param2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Return weighted combination of several 2D parameter points.
<br><br>
Provide an array of points and a parallel array of weights, and
this function will compute the weighted combination.  Note that
the weights are NOT required to sum to 1, but the sum must be
nonzero.
<br><br>
If you have only two points, use Q3Param2D_RRatio instead.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>params2D</tt></td><td>Array of 2D parameter points.</td></tr>
<tr valign=top><td><tt>weights</tt></td><td>Array of weights.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many elements there are in each array.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set with the weighted combination.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Param2D_Distance"></a>
<h3><a name="Q3Param2D_Distance">Q3Param2D_Distance</a></h3>
<blockquote><pre><tt>float  
Q3Param2D_Distance (
    const TQ3Param2D              *p1,
    const TQ3Param2D              *p2
);
</tt><br>
</pre></blockquote>
<p>Return Euclidean distance between two UV parameter points.
<br><br>
Available in inline form as Q3FastParam2D_Distance.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Distance between the given points.
 
<hr>
<a name="//apple_ref/c/func/Q3Param2D_DistanceSquared"></a>
<h3><a name="Q3Param2D_DistanceSquared">Q3Param2D_DistanceSquared</a></h3>
<blockquote><pre><tt>float  
Q3Param2D_DistanceSquared (
    const TQ3Param2D              *p1,
    const TQ3Param2D              *p2
);
</tt><br>
</pre></blockquote>
<p>Return the squared Euclidean distance between two UV parameter points.
<br><br>
Available in inline form as Q3FastParam2D_DistanceSquared.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Square of the distance between the given points.
 
<hr>
<a name="//apple_ref/c/func/Q3Param2D_RRatio"></a>
<h3><a name="Q3Param2D_RRatio">Q3Param2D_RRatio</a></h3>
<blockquote><pre><tt>TQ3Param2D * 
Q3Param2D_RRatio (
    const TQ3Param2D              *p1,
    const TQ3Param2D              *p2,
    float                         r1,
    float                         r2,
    TQ3Param2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Return the point at ratio r2/(r1+r2) along the line segment is
parameter (UV) space from p1 to p2.
<br><br>
Put another way, this function gives you the weighted average of points
p1 and p2, with the weights given by r1 and r2.  (Note that r1+r2 must
be nonzero.)
<br><br>
Available in inline form as Q3FastParam2D_RRatio.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of one end of a line segment.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of the other end of a line segment.</td></tr>
<tr valign=top><td><tt>r1</tt></td><td>Weight given to point p1.</td></tr>
<tr valign=top><td><tt>r2</tt></td><td>Weight given to point p2.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as p1 and/or p2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Param2D_Set"></a>
<h3><a name="Q3Param2D_Set">Q3Param2D_Set</a></h3>
<blockquote><pre><tt>TQ3Param2D * 
Q3Param2D_Set (
    TQ3Param2D                    *param2D,
    float                         u,
    float                         v
);
</tt><br>
</pre></blockquote>
<p>Set a 2D parameterization value (i.e., a UV coordinate).
<br><br>
Available in inline form as Q3FastParam2D_Set.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>param2D</tt></td><td>Address of param2D to set (may be NULL).</td></tr>
<tr valign=top><td><tt>u</tt></td><td>U coordinate to set into param2D.</td></tr>
<tr valign=top><td><tt>v</tt></td><td>V coordinate to set into param2D.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of param2D parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Param2D_Subtract"></a>
<h3><a name="Q3Param2D_Subtract">Q3Param2D_Subtract</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Param2D_Subtract (
    const TQ3Param2D              *p1,
    const TQ3Param2D              *p2,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Subtract 2D parametric point p2 from p1.
<br><br>
Available in inline form as Q3FastParam2D_Subtract.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of a point.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of point to subtract.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of a vector to set with (p1-p2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Param2D_Transform"></a>
<h3><a name="Q3Param2D_Transform">Q3Param2D_Transform</a></h3>
<blockquote><pre><tt>TQ3Param2D * 
Q3Param2D_Transform (
    const TQ3Param2D              *param2D,
    const TQ3Matrix3x3            *matrix3x3,
    TQ3Param2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Transform a 2D parametric point by a 3x3 matrix.
<br><br>
A more extensive description can be supplied here, covering
the typical usage of this function and any special requirements.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point2D</tt></td><td>Address of a point to transform.</td></tr>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of a 3x3 transformation matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as point2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Param2D_Vector2D_Add"></a>
<h3><a name="Q3Param2D_Vector2D_Add">Q3Param2D_Vector2D_Add</a></h3>
<blockquote><pre><tt>TQ3Param2D * 
Q3Param2D_Vector2D_Add (
    const TQ3Param2D              *param2D,
    const TQ3Vector2D             *vector2D,
    TQ3Param2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Add a 2D vector to a parametric (UV) point.
<br><br>
Available in inline form as Q3FastParam2D_Vector2D_Add.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>param2D</tt></td><td>Address of a 2D parametric point.</td></tr>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of a vector to add.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as param2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Param2D_Vector2D_Subtract"></a>
<h3><a name="Q3Param2D_Vector2D_Subtract">Q3Param2D_Vector2D_Subtract</a></h3>
<blockquote><pre><tt>TQ3Param2D * 
Q3Param2D_Vector2D_Subtract (
    const TQ3Param2D              *param2D,
    const TQ3Vector2D             *vector2D,
    TQ3Param2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Subtract a 2D vector from a parametric (UV) point.
<br><br>
Available in inline form as Q3FastParam2D_Vector2D_Subtract.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>param2D</tt></td><td>Address of a 2D parametric point.</td></tr>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of a vector to subtract.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as param2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_AffineComb"></a>
<h3><a name="Q3Point2D_AffineComb">Q3Point2D_AffineComb</a></h3>
<blockquote><pre><tt>TQ3Point2D * 
Q3Point2D_AffineComb (
    const TQ3Point2D              *points2D,
    const float                   *weights,
    TQ3Uns32                      numPoints,
    TQ3Point2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Return weighted combination of several 2D points.
<br><br>
Provide an array of points and a parallel array of weights, and
this function will compute the weighted combination.  Note that
the weights are NOT required to sum to 1, but the sum must be
nonzero.
<br><br>
If you have only two points, use Q3Point2D_RRatio instead.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>points2D</tt></td><td>Array of 2D points.</td></tr>
<tr valign=top><td><tt>weights</tt></td><td>Array of weights.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many elements there are in each array.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set with the weighted combination.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_CrossProductTri"></a>
<h3><a name="Q3Point2D_CrossProductTri">Q3Point2D_CrossProductTri</a></h3>
<blockquote><pre><tt>float 
Q3Point2D_CrossProductTri (
    const TQ3Point2D              *p1,
    const TQ3Point2D              *p2,
    const TQ3Point2D              *p3
);
</tt><br>
</pre></blockquote>
<p>Return the length of the cross product of a triangle specified by
three 2D points, that is, of the vectors p2-p1 and p3-p2.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
Available in inline form as Q3FastPoint2D_CrossProductTri.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of one point in the triangle.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of a second point in the triangle.</td></tr>
<tr valign=top><td><tt>p3</tt></td><td>Address of a third point in the triangle.</td></tr>
</table>
</blockquote>
<b>Result:</b> Length of (p2-p1) x (p3-p2).
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_Distance"></a>
<h3><a name="Q3Point2D_Distance">Q3Point2D_Distance</a></h3>
<blockquote><pre><tt>float  
Q3Point2D_Distance (
    const TQ3Point2D              *p1,
    const TQ3Point2D              *p2
);
</tt><br>
</pre></blockquote>
<p>Return Euclidean distance between two 2D points.
<br><br>
Available in inline form as Q3FastPoint2D_Distance.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Distance between the given points.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_DistanceSquared"></a>
<h3><a name="Q3Point2D_DistanceSquared">Q3Point2D_DistanceSquared</a></h3>
<blockquote><pre><tt>float  
Q3Point2D_DistanceSquared (
    const TQ3Point2D              *p1,
    const TQ3Point2D              *p2
);
</tt><br>
</pre></blockquote>
<p>Return the squared Euclidean distance between two 2D points.
<br><br>
Available in inline form as Q3FastPoint2D_DistanceSquared.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Square of the distance between the given points.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_RRatio"></a>
<h3><a name="Q3Point2D_RRatio">Q3Point2D_RRatio</a></h3>
<blockquote><pre><tt>TQ3Point2D * 
Q3Point2D_RRatio (
    const TQ3Point2D              *p1,
    const TQ3Point2D              *p2,
    float                         r1,
    float                         r2,
    TQ3Point2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Return the point at ratio r2/(r1+r2) along the line segment from p1 to p2.
<br><br>
Put another way, this function gives you the weighted average of points
p1 and p2, with the weights given by r1 and r2.  (Note that r1+r2 must
be nonzero.)
<br><br>
NOTE: The QD3D docs claim that the ratio used is r1/(r1+r2), but
it was found by direct experimentation that the QD3D library (1.6)
in fact uses r2/(r1+r2) instead.  This is as it should be, if r1 is
the weight of p1, and r2 is the weight of p2.
<br><br>
As usual, we do as QD3D does, not as the docs say.
<br><br>
Available in inline form as Q3FastPoint2D_RRatio.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of one end of a line segment.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of the other end of a line segment.</td></tr>
<tr valign=top><td><tt>r1</tt></td><td>Weight given to point p1.</td></tr>
<tr valign=top><td><tt>r2</tt></td><td>Weight given to point p2.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as p1 and/or p2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_Set"></a>
<h3><a name="Q3Point2D_Set">Q3Point2D_Set</a></h3>
<blockquote><pre><tt>TQ3Point2D * 
Q3Point2D_Set (
    TQ3Point2D                    *point2D,
    float                         x,
    float                         y
);
</tt><br>
</pre></blockquote>
<p>Set a 2D point.
<br><br>
Available in inline form as Q3FastPoint2D_Set.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point2D</tt></td><td>Address of point to set (may be NULL).</td></tr>
<tr valign=top><td><tt>x</tt></td><td>X coordinate to set into vector2D.</td></tr>
<tr valign=top><td><tt>y</tt></td><td>Y coordinate to set into vector2D.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of point2D parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_Subtract"></a>
<h3><a name="Q3Point2D_Subtract">Q3Point2D_Subtract</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Point2D_Subtract (
    const TQ3Point2D              *p1,
    const TQ3Point2D              *p2,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Subtract the 2D point p2 from p1.
<br><br>
Available in inline form as Q3FastPoint2D_Subtract.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of a point.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of point to subtract.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of a vector to set with (p1-p2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_To2DTransformArray"></a>
<h3><a name="Q3Point2D_To2DTransformArray">Q3Point2D_To2DTransformArray</a></h3>
<blockquote><pre><tt>TQ3Status  
Q3Point2D_To2DTransformArray (
    const TQ3Point2D              *inPoints2D,
    const TQ3Matrix3x3            *matrix3x3,
    TQ3Point2D                    *outPoints2D,
    TQ3Int32                      numPoints,
    TQ3Uns32                      inStructSize,
    TQ3Uns32                      outStructSize
);
</tt><br>
</pre></blockquote>
<p>Transform an array of 2D points by a 3x3 matrix.
<br><br>
When you have many points to transform, this is a more efficient
alternative to calling Q3Point2D_Transform repeatedly.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>inPoints2D</tt></td><td>Array of 2D points to transform.</td></tr>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Transformation matrix.</td></tr>
<tr valign=top><td><tt>outPoints2D</tt></td><td>Array of points to receive output (may be the same as inPoints2D).</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many points are in each array.</td></tr>
<tr valign=top><td><tt>inStructSize</tt></td><td>Size of one element of the input array, typically sizeof(TQ3Point2D).</td></tr>
<tr valign=top><td><tt>outStructSize</tt></td><td>Size of one element of the output array, typically sizeof(TQ3Point2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> kQ3Success or some error code.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_To3D"></a>
<h3><a name="Q3Point2D_To3D">Q3Point2D_To3D</a></h3>
<blockquote><pre><tt>TQ3RationalPoint3D * 
Q3Point2D_To3D (
    const TQ3Point2D              *point2D,
    TQ3RationalPoint3D            *result
);
</tt><br>
</pre></blockquote>
<p>Convert 2D point to rational 3D, setting w to 1.
<br><br>
The Apple version incorrectly declares the type of 'result' to
be TQ3Point3D rather than TQ3RationalPoint3D. At a binary level
there is no difference, but at the source code level the Apple
version forces the use of the incorrect type or type casting.
<br><br>
Available in inline form as Q3FastPoint2D_To3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point2D</tt></td><td>Address of 2D point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 3D rational point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_ToPolar"></a>
<h3><a name="Q3Point2D_ToPolar">Q3Point2D_ToPolar</a></h3>
<blockquote><pre><tt>TQ3PolarPoint * 
Q3Point2D_ToPolar (
    const TQ3Point2D              *point2D,
    TQ3PolarPoint                 *result
);
</tt><br>
</pre></blockquote>
<p>Convert 2D cartesian point to polar coordinates.
<br><br>
The angle (theta) here is measured counter-clockwise from the +x axis.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point2D</tt></td><td>Address of 2D point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of polar point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_Transform"></a>
<h3><a name="Q3Point2D_Transform">Q3Point2D_Transform</a></h3>
<blockquote><pre><tt>TQ3Point2D * 
Q3Point2D_Transform (
    const TQ3Point2D              *point2D,
    const TQ3Matrix3x3            *matrix3x3,
    TQ3Point2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Transform a 2D point by a 3x3 matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point2D</tt></td><td>Address of a point to transform.</td></tr>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of a 3x3 transformation matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as point2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_Vector2D_Add"></a>
<h3><a name="Q3Point2D_Vector2D_Add">Q3Point2D_Vector2D_Add</a></h3>
<blockquote><pre><tt>TQ3Point2D * 
Q3Point2D_Vector2D_Add (
    const TQ3Point2D              *point2D,
    const TQ3Vector2D             *vector2D,
    TQ3Point2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Add a 2D vector to a point.
<br><br>
Available in inline form as Q3FastPoint2D_Vector2D_Add.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point2D</tt></td><td>Address of a point.</td></tr>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of a vector to add.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as point2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point2D_Vector2D_Subtract"></a>
<h3><a name="Q3Point2D_Vector2D_Subtract">Q3Point2D_Vector2D_Subtract</a></h3>
<blockquote><pre><tt>TQ3Point2D * 
Q3Point2D_Vector2D_Subtract (
    const TQ3Point2D              *point2D,
    const TQ3Vector2D             *vector2D,
    TQ3Point2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Subtract a 2D vector from a point.
<br><br>
Available in inline form as Q3FastPoint2D_Vector2D_Subtract.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point2D</tt></td><td>Address of a point.</td></tr>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of a vector to subtract.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as point2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_AffineComb"></a>
<h3><a name="Q3Point3D_AffineComb">Q3Point3D_AffineComb</a></h3>
<blockquote><pre><tt>TQ3Point3D * 
Q3Point3D_AffineComb (
    const TQ3Point3D              *points3D,
    const float                   *weights,
    TQ3Uns32                      numPoints,
    TQ3Point3D                    *result
);
</tt><br>
</pre></blockquote>
<p>Return weighted combination of several 3D points.
<br><br>
Provide an array of points and a parallel array of weights, and
this function will compute the weighted combination.  Note that
the weights are NOT required to sum to 1, but the sum must be
nonzero.
<br><br>
If you have only two points, use Q3Point3D_RRatio instead.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>points3D</tt></td><td>Array of 3D points.</td></tr>
<tr valign=top><td><tt>weights</tt></td><td>Array of weights.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many elements there are in each array.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set with the weighted combination.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_CrossProductTri"></a>
<h3><a name="Q3Point3D_CrossProductTri">Q3Point3D_CrossProductTri</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Point3D_CrossProductTri (
    const TQ3Point3D              *p1,
    const TQ3Point3D              *p2,
    const TQ3Point3D              *p3,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Return the cross product of triangle triangle defined by three
3D points, that is, of the vectors p2-p1 and p3-p2.
<br><br>
Available in inline form as Q3FastPoint3D_CrossProductTri.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of one point in the triangle.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of a second point in the triangle.</td></tr>
<tr valign=top><td><tt>p3</tt></td><td>Address of a third point in the triangle.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set with cross product (p2-p1) x (p3-p2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_Distance"></a>
<h3><a name="Q3Point3D_Distance">Q3Point3D_Distance</a></h3>
<blockquote><pre><tt>float  
Q3Point3D_Distance (
    const TQ3Point3D              *p1,
    const TQ3Point3D              *p2
);
</tt><br>
</pre></blockquote>
<p>Return Euclidean distance between two 3D points.
<br><br>
Available in inline form as Q3FastPoint3D_Distance.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Distance between the given points.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_DistanceSquared"></a>
<h3><a name="Q3Point3D_DistanceSquared">Q3Point3D_DistanceSquared</a></h3>
<blockquote><pre><tt>float  
Q3Point3D_DistanceSquared (
    const TQ3Point3D              *p1,
    const TQ3Point3D              *p2
);
</tt><br>
</pre></blockquote>
<p>Return the squared Euclidean distance between two 3D points.
<br><br>
Available in inline form as Q3FastPoint3D_DistanceSquared.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Square of the distance between the given points.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_RRatio"></a>
<h3><a name="Q3Point3D_RRatio">Q3Point3D_RRatio</a></h3>
<blockquote><pre><tt>TQ3Point3D * 
Q3Point3D_RRatio (
    const TQ3Point3D              *p1,
    const TQ3Point3D              *p2,
    float                         r1,
    float                         r2,
    TQ3Point3D                    *result
);
</tt><br>
</pre></blockquote>
<p>Return the point at ratio r2/(r1+r2) along the line segment from p1 to p2.
<br><br>
Put another way, this function gives you the weighted average of points
p1 and p2, with the weights given by r1 and r2.  (Note that r1+r2 must
be nonzero.)
<br><br>
NOTE: The QD3D docs claim that the ratio used is r1/(r1+r2), but
it was found by direct experimentation that the QD3D library (1.6)
in fact uses r2/(r1+r2) instead.  This is as it should be, if r1 is
the weight of p1, and r2 is the weight of p2.
<br><br>
As usual, we do as QD3D does, not as the docs say.
<br><br>
Available in inline form as Q3FastPoint3D_RRatio.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of one end of a line segment.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of the other end of a line segment.</td></tr>
<tr valign=top><td><tt>r1</tt></td><td>Weight given to point p1.</td></tr>
<tr valign=top><td><tt>r2</tt></td><td>Weight given to point p2.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as p1 and/or p2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_Set"></a>
<h3><a name="Q3Point3D_Set">Q3Point3D_Set</a></h3>
<blockquote><pre><tt>TQ3Point3D * 
Q3Point3D_Set (
    TQ3Point3D                    *point3D,
    float                         x,
    float                         y,
    float                         z
);
</tt><br>
</pre></blockquote>
<p>Set a 3D point.
<br><br>
Available in inline form as Q3FastPoint3D_Set.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point3D</tt></td><td>Address of point to set (may be NULL).</td></tr>
<tr valign=top><td><tt>x</tt></td><td>X coordinate to set into point3D.</td></tr>
<tr valign=top><td><tt>y</tt></td><td>Y coordinate to set into point3D.</td></tr>
<tr valign=top><td><tt>z</tt></td><td>Z coordinate to set into point3D.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of point3D parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_Subtract"></a>
<h3><a name="Q3Point3D_Subtract">Q3Point3D_Subtract</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Point3D_Subtract (
    const TQ3Point3D              *p1,
    const TQ3Point3D              *p2,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Subtract 3D point p2 from p1.
<br><br>
Available in inline form as Q3FastPoint3D_Subtract.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of a point.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of a point to subtract.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as p1 and/or p2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_To3DTransformArray"></a>
<h3><a name="Q3Point3D_To3DTransformArray">Q3Point3D_To3DTransformArray</a></h3>
<blockquote><pre><tt>TQ3Status  
Q3Point3D_To3DTransformArray (
    const TQ3Point3D              *inPoints3D,
    const TQ3Matrix4x4            *matrix4x4,
    TQ3Point3D                    *outPoints3D,
    TQ3Int32                      numPoints,
    TQ3Uns32                      inStructSize,
    TQ3Uns32                      outStructSize
);
</tt><br>
</pre></blockquote>
<p>Transform an array of 3D points by a 4x4 matrix.
<br><br>
When you have many points to transform, this is a more efficient
alternative to calling Q3Point3D_Transform repeatedly.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>inPoints3D</tt></td><td>Array of 3D points to transform.</td></tr>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Transformation matrix.</td></tr>
<tr valign=top><td><tt>outPoints3D</tt></td><td>Array of points to receive output (may be the same as inPoints3D).</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many points are in each array.</td></tr>
<tr valign=top><td><tt>inStructSize</tt></td><td>Size of one element of the input array, typically sizeof(TQ3Point3D).</td></tr>
<tr valign=top><td><tt>outStructSize</tt></td><td>Size of one element of the output array, typically sizeof(TQ3Point3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> kQ3Success or some error code.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_To4D"></a>
<h3><a name="Q3Point3D_To4D">Q3Point3D_To4D</a></h3>
<blockquote><pre><tt>TQ3RationalPoint4D * 
Q3Point3D_To4D (
    const TQ3Point3D              *point3D,
    TQ3RationalPoint4D            *result
);
</tt><br>
</pre></blockquote>
<p>Convert 3D point to rational 4D, setting w to 1.
<br><br>
Available in inline form as Q3FastPoint3D_To4D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point3D</tt></td><td>Address of 3D point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of rational 4D point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_To4DTransformArray"></a>
<h3><a name="Q3Point3D_To4DTransformArray">Q3Point3D_To4DTransformArray</a></h3>
<blockquote><pre><tt>TQ3Status  
Q3Point3D_To4DTransformArray (
    const TQ3Point3D              *inPoints3D,
    const TQ3Matrix4x4            *matrix4x4,
    TQ3RationalPoint4D            *outRationalPoints4D,
    TQ3Int32                      numPoints,
    TQ3Uns32                      inStructSize,
    TQ3Uns32                      outStructSize
);
</tt><br>
</pre></blockquote>
<p>Transform an array of 3D points by a 4x4 matrix into 4D rational points.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>inPoints3D</tt></td><td>Array of 3D points to transform.</td></tr>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Transformation matrix.</td></tr>
<tr valign=top><td><tt>outRationalPoints4D</tt></td><td>Array of points to receive output.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many points are in each array.</td></tr>
<tr valign=top><td><tt>inStructSize</tt></td><td>Size of one element of the input array, typically sizeof(TQ3Point3D).</td></tr>
<tr valign=top><td><tt>outStructSize</tt></td><td>Size of one element of the output array, typically sizeof(TQ3RationalPoint4D).</td></tr>
</table>
</blockquote>
<b>Result:</b> kQ3Success or some error code.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_ToSpherical"></a>
<h3><a name="Q3Point3D_ToSpherical">Q3Point3D_ToSpherical</a></h3>
<blockquote><pre><tt>TQ3SphericalPoint * 
Q3Point3D_ToSpherical (
    const TQ3Point3D              *point3D,
    TQ3SphericalPoint             *result
);
</tt><br>
</pre></blockquote>
<p>Convert 3D cartesian point to spherical coordinates.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point3D</tt></td><td>Address of 3D cartesian point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of spherical-coordinates point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_Transform"></a>
<h3><a name="Q3Point3D_Transform">Q3Point3D_Transform</a></h3>
<blockquote><pre><tt>TQ3Point3D * 
Q3Point3D_Transform (
    const TQ3Point3D              *point3D,
    const TQ3Matrix4x4            *matrix4x4,
    TQ3Point3D                    *result
);
</tt><br>
</pre></blockquote>
<p>Transform a 3D point by a 4x4 matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point3D</tt></td><td>Address of a point to transform.</td></tr>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of a 4x4 transformation matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as point3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_TransformQuaternion"></a>
<h3><a name="Q3Point3D_TransformQuaternion">Q3Point3D_TransformQuaternion</a></h3>
<blockquote><pre><tt>TQ3Point3D * 
Q3Point3D_TransformQuaternion (
    const TQ3Point3D              *point3D,
    const TQ3Quaternion           *quaternion,
    TQ3Point3D                    *result
);
</tt><br>
</pre></blockquote>
<p>Transform a 3D point by a quaternion.
<br><br>
Note that for correct results, the quaternion should be normalized.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point3D</tt></td><td>Address of a point to transform.</td></tr>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to transform by.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of a point to set (may be the same as point3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_Vector3D_Add"></a>
<h3><a name="Q3Point3D_Vector3D_Add">Q3Point3D_Vector3D_Add</a></h3>
<blockquote><pre><tt>TQ3Point3D * 
Q3Point3D_Vector3D_Add (
    const TQ3Point3D              *point3D,
    const TQ3Vector3D             *vector3D,
    TQ3Point3D                    *result
);
</tt><br>
</pre></blockquote>
<p>Add a 3D vector to a point.
<br><br>
Available in inline form as Q3FastPoint3D_Vector3D_Add.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point3D</tt></td><td>Address of a point.</td></tr>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of a vector to add.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as point3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Point3D_Vector3D_Subtract"></a>
<h3><a name="Q3Point3D_Vector3D_Subtract">Q3Point3D_Vector3D_Subtract</a></h3>
<blockquote><pre><tt>TQ3Point3D * 
Q3Point3D_Vector3D_Subtract (
    const TQ3Point3D              *point3D,
    const TQ3Vector3D             *vector3D,
    TQ3Point3D                    *result
);
</tt><br>
</pre></blockquote>
<p>Subtract 3D vector from point.
<br><br>
Available in inline form as Q3FastPoint3D_Vector3D_Subtract.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>point3D</tt></td><td>Address of a point.</td></tr>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of a vector to subtract.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as point3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3PolarPoint_Set"></a>
<h3><a name="Q3PolarPoint_Set">Q3PolarPoint_Set</a></h3>
<blockquote><pre><tt>TQ3PolarPoint * 
Q3PolarPoint_Set (
    TQ3PolarPoint                 *polarPoint,
    float                         r,
    float                         theta
);
</tt><br>
</pre></blockquote>
<p>Set a 2D polar-coordinates point.
<br><br>
Available in inline form as Q3FastPolarPoint_Set.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>polarPoint</tt></td><td>Address of point to set (may be NULL).</td></tr>
<tr valign=top><td><tt>r</tt></td><td>Radius coordinate to set into polarPoint.</td></tr>
<tr valign=top><td><tt>theta</tt></td><td>Angle coordinate (in radians) to set into polarPoint.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of polarPoint parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3PolarPoint_ToPoint2D"></a>
<h3><a name="Q3PolarPoint_ToPoint2D">Q3PolarPoint_ToPoint2D</a></h3>
<blockquote><pre><tt>TQ3Point2D * 
Q3PolarPoint_ToPoint2D (
    const TQ3PolarPoint           *polarPoint,
    TQ3Point2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Convert 2D polar point to cartesian coordinates.
<br><br>
The angle (theta) here is measured counter-clockwise from the +x axis.
<br><br>
Available in inline form as Q3FastPolarPoint_ToPoint2D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>polarPoint</tt></td><td>Address of polar point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 2D cartesian point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_Copy"></a>
<h3><a name="Q3Quaternion_Copy">Q3Quaternion_Copy</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_Copy (
    const TQ3Quaternion           *quaternion,
    TQ3Quaternion                 *result
);
</tt><br>
</pre></blockquote>
<p>Copy a quaternion.
<br><br>
Available in inline form as Q3FastQuaternion_Copy.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of source quaternion.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of destination quaternion (may be the same as the first parameter).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_Dot"></a>
<h3><a name="Q3Quaternion_Dot">Q3Quaternion_Dot</a></h3>
<blockquote><pre><tt>float  
Q3Quaternion_Dot (
    const TQ3Quaternion           *q1,
    const TQ3Quaternion           *q2
);
</tt><br>
</pre></blockquote>
<p>Return the dot product of q1 and q2.
<br><br>
Available in inline form as Q3FastQuaternion_Dot.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>q1</tt></td><td>Address of one quaternion.</td></tr>
<tr valign=top><td><tt>q2</tt></td><td>Address of another quaternion (may be the same as q1).</td></tr>
</table>
</blockquote>
<b>Result:</b> Dot product of q1 and q2.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_GetAxisAndAngle"></a>
<h3><a name="Q3Quaternion_GetAxisAndAngle">Q3Quaternion_GetAxisAndAngle</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Quaternion_GetAxisAndAngle (
	const TQ3Quaternion           *quaternion,
	TQ3Vector3D                   *outAxis,
	float                         *outAngle
);
</tt><br>
</pre></blockquote>
<p>Get the rotation axis and/or angle represented by a quaternion.
<br><br>
Note that for correct results, the quaternion should be normalized.
<br><br>
If the quaternion represents a null rotation, then outAngle will be
set to 0.0 and outAxis will be set to <0, 1, 0> (since in this case
the rotation axis is undefined, but we want to always give you a 
valid axis).
<br><br>
Either outAxis or outAngle may be null if you are not interested in
that result.  (You could even pass null for both, but that would be
rather pointless.)
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to inspect.</td></tr>
<tr valign=top><td><tt>outAxis</tt></td><td>Address of a vector to set to the rotation axis (may be null).</td></tr>
<tr valign=top><td><tt>outAngle</tt></td><td>Address of a float to set to the rotation angle (may be null).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of outAxis parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_InterpolateFast"></a>
<h3><a name="Q3Quaternion_InterpolateFast">Q3Quaternion_InterpolateFast</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_InterpolateFast (
    const TQ3Quaternion           *q1,
    const TQ3Quaternion           *q2,
    float                         t,
    TQ3Quaternion                 *result
);
</tt><br>
</pre></blockquote>
<p>Compute a straight linear interpolation between two quaternions.
<br><br>
This does a true linear, not spherical, interpolation between
q1 and q2.  It's fast, but not very proper for most uses.
<br><br>
The result is automatically normalized, so there is no need to
do so yourself.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>q1</tt></td><td>Address of first quaternion.</td></tr>
<tr valign=top><td><tt>q2</tt></td><td>Address of second quaternion.</td></tr>
<tr valign=top><td><tt>t</tt></td><td>Fraction (0-1) of the way from q1 to q2.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of quaternion to set (may be the same as q1 and/or q2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_InterpolateLinear"></a>
<h3><a name="Q3Quaternion_InterpolateLinear">Q3Quaternion_InterpolateLinear</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_InterpolateLinear (
    const TQ3Quaternion           *q1,
    const TQ3Quaternion           *q2,
    float                         t,
    TQ3Quaternion                 *result
);
</tt><br>
</pre></blockquote>
<p>Compute a spherical linear interpolation between two quaternions.
<br><br>
Despite the name, this function does a SLERP (spherical linear
interpolation) from q1 to q2.
It falls back on a straight linear interpolation only when the
cosine of the angle between them is less than 0.01.
<br><br>
The cut-off point was chosen arbitrarily, and may not match
that of QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>q1</tt></td><td>Address of first quaternion.</td></tr>
<tr valign=top><td><tt>q2</tt></td><td>Address of second quaternion.</td></tr>
<tr valign=top><td><tt>t</tt></td><td>Fraction (0-1) of the way from q1 to q2.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of quaternion to set (may be the same as q1 and/or q2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_Invert"></a>
<h3><a name="Q3Quaternion_Invert">Q3Quaternion_Invert</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_Invert (
    const TQ3Quaternion           *quaternion,
    TQ3Quaternion                 *result
);
</tt><br>
</pre></blockquote>
<p>Invert a quaternion.
<br><br>
For correct results, the quaternion should be normalized
before inverting.
<br><br>
Available in inline form as Q3FastQuaternion_Invert.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to invert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of quaternion to set (may be the same as the first parameter).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_IsIdentity"></a>
<h3><a name="Q3Quaternion_IsIdentity">Q3Quaternion_IsIdentity</a></h3>
<blockquote><pre><tt>TQ3Boolean  
Q3Quaternion_IsIdentity (
    const TQ3Quaternion           *quaternion
);
</tt><br>
</pre></blockquote>
<p>Return whether a quaternion is (roughly) the identity,
i.e., (1,0,0,0).
<br><br>
Values for x, y, and z are considered close enough to 0
if they are within FLT_EPSILON (a small number).
<br><br>
For correct results, the quaternion should first be normalized.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of quaternion to test.</td></tr>
</table>
</blockquote>
<b>Result:</b> True if quaternion is the identity.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_MatchReflection"></a>
<h3><a name="Q3Quaternion_MatchReflection">Q3Quaternion_MatchReflection</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_MatchReflection (
    const TQ3Quaternion           *q1,
    const TQ3Quaternion           *q2,
    TQ3Quaternion                 *result
);
</tt><br>
</pre></blockquote>
<p>Set result to either q1 or -q1, whichever produces a positive dot
product with q2 (i.e., whichever is "closer" to q2 in orientation).
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>q1</tt></td><td>Address of source quaternion.</td></tr>
<tr valign=top><td><tt>q2</tt></td><td>Address of quaternion to match.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of quaternion to set (may be the same as q1 and/or q2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_Multiply"></a>
<h3><a name="Q3Quaternion_Multiply">Q3Quaternion_Multiply</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_Multiply (
    const TQ3Quaternion           *q1,
    const TQ3Quaternion           *q2,
    TQ3Quaternion                 *result
);
</tt><br>
</pre></blockquote>
<p>Compute the product of two quaternions.
<br><br>
This is a very useful operation, since the rotation represented
by q1*q2 is exactly the same as rotating by q1 and then by q2.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>q1</tt></td><td>Address of first quaternion.</td></tr>
<tr valign=top><td><tt>q2</tt></td><td>Address of second quaternion.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of quaternion to set (may be the same as q1 and/or q2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_Normalize"></a>
<h3><a name="Q3Quaternion_Normalize">Q3Quaternion_Normalize</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_Normalize (
    const TQ3Quaternion           *quaternion,
    TQ3Quaternion                 *result
);
</tt><br>
</pre></blockquote>
<p>Scale a quaternion to length 1.
<br><br>
This is often needed when combining or interpolating between
quaternions, to keep accumulated error from causing your
quaternion values to "blow up".
<br><br>
Available in inline form as Q3FastQuaternion_Normalize.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to normalize.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of quaternion to set (may be the same as the first parameter).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_Set"></a>
<h3><a name="Q3Quaternion_Set">Q3Quaternion_Set</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_Set (
    TQ3Quaternion                 *quaternion,
    float                         w,
    float                         x,
    float                         y,
    float                         z
);
</tt><br>
</pre></blockquote>
<p>Set a quaternion with its individual w, x, y, and z components.
<br><br>
Available in inline form as Q3FastQuaternion_Set.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to set.</td></tr>
<tr valign=top><td><tt>w</tt></td><td>Value for w component.</td></tr>
<tr valign=top><td><tt>x</tt></td><td>Value for x component.</td></tr>
<tr valign=top><td><tt>y</tt></td><td>Value for y component.</td></tr>
<tr valign=top><td><tt>z</tt></td><td>Value for z component.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of quaternion parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_SetIdentity"></a>
<h3><a name="Q3Quaternion_SetIdentity">Q3Quaternion_SetIdentity</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_SetIdentity (
    TQ3Quaternion                 *quaternion
);
</tt><br>
</pre></blockquote>
<p>Set a quaternion to the identity value (1,0,0,0).
<br><br>
Available in inline form as Q3FastQuaternion_SetIdentity.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_SetMatrix"></a>
<h3><a name="Q3Quaternion_SetMatrix">Q3Quaternion_SetMatrix</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_SetMatrix (
    TQ3Quaternion                 *quaternion,
    const TQ3Matrix4x4            *matrix4x4
);
</tt><br>
</pre></blockquote>
<p>Set a quaternion from a 4x4 rotation matrix.
<br><br>
Note: The QD3D implementation of this function appears to be buggy.
This can be demonstrated by starting with an arbitrary
quaternion, converting to a matrix, then converting back (with
this function).
<br><br>
QD3D's result is something ridiculous; in Quesa, this function 
returns the original quaternion (or something equivalent).
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to set.</td></tr>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of a rotation matrix to imitate.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of quaternion parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_SetRotateAboutAxis"></a>
<h3><a name="Q3Quaternion_SetRotateAboutAxis">Q3Quaternion_SetRotateAboutAxis</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_SetRotateAboutAxis (
    TQ3Quaternion                 *quaternion,
    const TQ3Vector3D             *axis,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set quaternion to rotate about arbitrary axis.
<br><br>
Note that for correct results, the axis should be normalized
(i.e. have length = 1).
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to set.</td></tr>
<tr valign=top><td><tt>axis</tt></td><td>Address of a 3D vector to use as the rotation axis.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of quaternion parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_SetRotateVectorToVector"></a>
<h3><a name="Q3Quaternion_SetRotateVectorToVector">Q3Quaternion_SetRotateVectorToVector</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_SetRotateVectorToVector (
    TQ3Quaternion                 *quaternion,
    const TQ3Vector3D             *v1,
    const TQ3Vector3D             *v2
);
</tt><br>
</pre></blockquote>
<p>Set a quaternion to rotate vector 'v1' to 'v2'.
<br><br>
Note that for correct results, both vectors should be normalized
(i.e. have length = 1).
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to set.</td></tr>
<tr valign=top><td><tt>v1</tt></td><td>Address of "starting" vector.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of "ending" vector.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of quaternion parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_SetRotate_X"></a>
<h3><a name="Q3Quaternion_SetRotate_X">Q3Quaternion_SetRotate_X</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_SetRotate_X (
    TQ3Quaternion                 *quaternion,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set a quaternion to rotate about the X axis.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to set.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_SetRotate_XYZ"></a>
<h3><a name="Q3Quaternion_SetRotate_XYZ">Q3Quaternion_SetRotate_XYZ</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_SetRotate_XYZ (
    TQ3Quaternion                 *quaternion,
    float                         xAngle,
    float                         yAngle,
    float                         zAngle
);
</tt><br>
</pre></blockquote>
<p>Set a quaternion to rotate about the X, Y, and Z axes (in that order).
<br><br>
This order of rotations is rarely useful, but it's kept for backwards
compatibility with QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to set.</td></tr>
<tr valign=top><td><tt>xAngle</tt></td><td>Angle to rotate about the X axis (in radians).</td></tr>
<tr valign=top><td><tt>yAngle</tt></td><td>Angle to rotate about the Y axis (in radians).</td></tr>
<tr valign=top><td><tt>zAngle</tt></td><td>Angle to rotate about the Z axis (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of quaternion parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_SetRotate_Y"></a>
<h3><a name="Q3Quaternion_SetRotate_Y">Q3Quaternion_SetRotate_Y</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_SetRotate_Y (
    TQ3Quaternion                 *quaternion,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set a quaternion to rotate about the Y axis.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to set.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of quaternion parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Quaternion_SetRotate_Z"></a>
<h3><a name="Q3Quaternion_SetRotate_Z">Q3Quaternion_SetRotate_Z</a></h3>
<blockquote><pre><tt>TQ3Quaternion * 
Q3Quaternion_SetRotate_Z (
    TQ3Quaternion                 *quaternion,
    float                         angle
);
</tt><br>
</pre></blockquote>
<p>Set a quaternion to rotate about the Z axis.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to set.</td></tr>
<tr valign=top><td><tt>angle</tt></td><td>Angle to rotate (in radians).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of quaternion parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint3D_AffineComb"></a>
<h3><a name="Q3RationalPoint3D_AffineComb">Q3RationalPoint3D_AffineComb</a></h3>
<blockquote><pre><tt>TQ3RationalPoint3D * 
Q3RationalPoint3D_AffineComb (
    const TQ3RationalPoint3D      *rationalPoints3D,
    const float                   *weights,
    TQ3Uns32                      numPoints,
    TQ3RationalPoint3D            *result
);
</tt><br>
</pre></blockquote>
<p>Compute the weighted combination of several 3D rational points.
<br><br>
This operation makes no sense mathematically, but is included
for compatibility with QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoints3D</tt></td><td>Array of 3D rational points.</td></tr>
<tr valign=top><td><tt>weights</tt></td><td>Array of weights.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many elements there are in each array.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set with the weighted combination.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint3D_Distance"></a>
<h3><a name="Q3RationalPoint3D_Distance">Q3RationalPoint3D_Distance</a></h3>
<blockquote><pre><tt>float  
Q3RationalPoint3D_Distance (
    const TQ3RationalPoint3D      *p1,
    const TQ3RationalPoint3D      *p2
);
</tt><br>
</pre></blockquote>
<p>Returns the Euclidian distance between two rational 3D points.
<br><br>
This operation makes no sense mathematically, but is included
for backwards compatibility with QD3D.
<br><br>
Available in inline form as Q3FastRationalPoint3D_Distance.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Distance between the given points, treating
w as a spatial coordinate.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint3D_DistanceSquared"></a>
<h3><a name="Q3RationalPoint3D_DistanceSquared">Q3RationalPoint3D_DistanceSquared</a></h3>
<blockquote><pre><tt>float  
Q3RationalPoint3D_DistanceSquared (
    const TQ3RationalPoint3D      *p1,
    const TQ3RationalPoint3D      *p2
);
</tt><br>
</pre></blockquote>
<p>Returns the squared Euclidian distance between two rational 3D points.
<br><br>
This operation makes no sense mathematically, but is included
for backwards compatibility with QD3D.
<br><br>
Available in inline form as Q3FastRationalPoint3D_DistanceSquared.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Square of the distance between the given points, 
treating w as a spatial coordinate.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint3D_Set"></a>
<h3><a name="Q3RationalPoint3D_Set">Q3RationalPoint3D_Set</a></h3>
<blockquote><pre><tt>TQ3RationalPoint3D * 
Q3RationalPoint3D_Set (
    TQ3RationalPoint3D            *rationalPoint3D,
    float                         x,
    float                         y,
    float                         w
);
</tt><br>
</pre></blockquote>
<p>Set a 3D rational point (x,y,w).
<br><br>
Available in inline form as Q3FastRationalPoint3D_Set.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoint3D</tt></td><td>Address of rational point to set (may be NULL).</td></tr>
<tr valign=top><td><tt>x</tt></td><td>X coordinate to set into rationalPoint3D.</td></tr>
<tr valign=top><td><tt>y</tt></td><td>Y coordinate to set into rationalPoint3D.</td></tr>
<tr valign=top><td><tt>w</tt></td><td>W coordinate to set into rationalPoint3D.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of rationalPoint3D parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint3D_To2D"></a>
<h3><a name="Q3RationalPoint3D_To2D">Q3RationalPoint3D_To2D</a></h3>
<blockquote><pre><tt>TQ3Point2D * 
Q3RationalPoint3D_To2D (
    const TQ3RationalPoint3D      *rationalPoint3D,
    TQ3Point2D                    *result
);
</tt><br>
</pre></blockquote>
<p>Convert rational 3D point to 2D, dividing by w.
<br><br>
Available in inline form as Q3FastRationalPoint3D_To2D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoint3D</tt></td><td>Address of rational 3D point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 2D point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint3D_To3DTransformArray"></a>
<h3><a name="Q3RationalPoint3D_To3DTransformArray">Q3RationalPoint3D_To3DTransformArray</a></h3>
<blockquote><pre><tt>TQ3Status  
Q3RationalPoint3D_To3DTransformArray (
    const TQ3RationalPoint3D      *inRationalPoints3D,
    const TQ3Matrix3x3            *matrix3x3,
    TQ3RationalPoint3D            *outRationalPoints3D,
    TQ3Int32                      numPoints,
    TQ3Uns32                      inStructSize,
    TQ3Uns32                      outStructSize
);
</tt><br>
</pre></blockquote>
<p>Transform an array of 3D rational points by a 3x3 matrix.
<br><br>
When you have many points to transform, this is a more efficient
alternative to calling Q3RationalPoint3D_Transform repeatedly.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>inRationalPoints3D</tt></td><td>Array of 3D rational points to transform.</td></tr>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Transformation matrix.</td></tr>
<tr valign=top><td><tt>outRationalPoints3D</tt></td><td>Array of points to receive output (may be the same as inRationalPoints3D).</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many points are in each array.</td></tr>
<tr valign=top><td><tt>inStructSize</tt></td><td>Size of one element of the input array, typically sizeof(TQ3RationalPoint3D).</td></tr>
<tr valign=top><td><tt>outStructSize</tt></td><td>Size of one element of the output array, typically sizeof(TQ3RationalPoint3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> kQ3Success or some error code.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint3D_ToVector2D"></a>
<h3><a name="Q3RationalPoint3D_ToVector2D">Q3RationalPoint3D_ToVector2D</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3RationalPoint3D_ToVector2D (
    const TQ3RationalPoint3D      *rationalPoint3D,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Convert 3D rational point to 2D vector, discarding w.
<br><br>
Available in inline form as Q3FastRationalPoint3D_ToVector2D.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoint3D</tt></td><td>Address of 3D rational point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 2D vector to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint3D_Transform"></a>
<h3><a name="Q3RationalPoint3D_Transform">Q3RationalPoint3D_Transform</a></h3>
<blockquote><pre><tt>TQ3RationalPoint3D * 
Q3RationalPoint3D_Transform (
    const TQ3RationalPoint3D      *rationalPoint3D,
    const TQ3Matrix3x3            *matri3x3,
    TQ3RationalPoint3D            *result
);
</tt><br>
</pre></blockquote>
<p>Transform 3D rational point by 3x3 matrix.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoint3D</tt></td><td>Address of a point to transform.</td></tr>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of a 3x3 transformation matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as rationalPoint3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint4D_AffineComb"></a>
<h3><a name="Q3RationalPoint4D_AffineComb">Q3RationalPoint4D_AffineComb</a></h3>
<blockquote><pre><tt>TQ3RationalPoint4D * 
Q3RationalPoint4D_AffineComb (
    const TQ3RationalPoint4D      *rationalPoints4D,
    const float                   *weights,
    TQ3Uns32                      numPoints,
    TQ3RationalPoint4D            *result
);
</tt><br>
</pre></blockquote>
<p>Compute the weighted combination of several 4D rational points.
<br><br>
This operation makes no sense mathematically, but is included
for compatibility with QD3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoints4D</tt></td><td>Array of 4D rational points.</td></tr>
<tr valign=top><td><tt>weights</tt></td><td>Array of weights.</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many elements there are in each array.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set with the weighted combination.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint4D_Distance"></a>
<h3><a name="Q3RationalPoint4D_Distance">Q3RationalPoint4D_Distance</a></h3>
<blockquote><pre><tt>float  
Q3RationalPoint4D_Distance (
    const TQ3RationalPoint4D      *p1,
    const TQ3RationalPoint4D      *p2
);
</tt><br>
</pre></blockquote>
<p>Returns the Euclidian distance between two rational 4D points.
<br><br>
This operation makes no sense mathematically, but is included
for backwards compatibility with QD3D.
<br><br>
Available in inline form as Q3FastRationalPoint4D_Distance.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Distance between the given points, treating
w as a spatial coordinate.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint4D_DistanceSquared"></a>
<h3><a name="Q3RationalPoint4D_DistanceSquared">Q3RationalPoint4D_DistanceSquared</a></h3>
<blockquote><pre><tt>float  
Q3RationalPoint4D_DistanceSquared (
    const TQ3RationalPoint4D      *p1,
    const TQ3RationalPoint4D      *p2
);
</tt><br>
</pre></blockquote>
<p>Returns the squared Euclidian distance between two rational 4D points.
<br><br>
This operation makes no sense mathematically, but is included
for backwards compatibility with QD3D.
<br><br>
Available in inline form as Q3FastRationalPoint4D_DistanceSquared.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of first point of interest.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of second point of interest.</td></tr>
</table>
</blockquote>
<b>Result:</b> Square of the distance between the given points, 
treating w as a spatial coordinate.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint4D_RRatio"></a>
<h3><a name="Q3RationalPoint4D_RRatio">Q3RationalPoint4D_RRatio</a></h3>
<blockquote><pre><tt>TQ3RationalPoint4D * 
Q3RationalPoint4D_RRatio (
    const TQ3RationalPoint4D      *p1,
    const TQ3RationalPoint4D      *p2,
    float                         r1,
    float                         r2,
    TQ3RationalPoint4D            *result
);
</tt><br>
</pre></blockquote>
<p>Return the point at ratio r2/(r1+r2) along the line segment from p1 to p2.
<br><br>
Put another way, this function gives you the weighted average of points
p1 and p2, with the weights given by r1 and r2.  (Note that r1+r2 must
be nonzero.)
<br><br>
NOTE: The QD3D docs claim that the ratio used is r1/(r1+r2), but
it was found by direct experimentation that the QD3D library (1.6)
in fact uses r2/(r1+r2) instead.  This is as it should be, if r1 is
the weight of p1, and r2 is the weight of p2.
<br><br>
As usual, we do as QD3D does, not as the docs say.
<br><br>
Available in inline form as Q3FastRationalPoint4D_RRatio.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>p1</tt></td><td>Address of one end of a line segment.</td></tr>
<tr valign=top><td><tt>p2</tt></td><td>Address of the other end of a line segment.</td></tr>
<tr valign=top><td><tt>r1</tt></td><td>Weight given to point p1.</td></tr>
<tr valign=top><td><tt>r2</tt></td><td>Weight given to point p2.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as p1 and/or p2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint4D_Set"></a>
<h3><a name="Q3RationalPoint4D_Set">Q3RationalPoint4D_Set</a></h3>
<blockquote><pre><tt>TQ3RationalPoint4D * 
Q3RationalPoint4D_Set (
    TQ3RationalPoint4D            *rationalPoint4D,
    float                         x,
    float                         y,
    float                         z,
    float                         w
);
</tt><br>
</pre></blockquote>
<p>Set a 4D rational point (x,y,z,w).
<br><br>
Available in inline form as Q3FastRationalPoint4D_Set.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoint4D</tt></td><td>Address of rational point to set.</td></tr>
<tr valign=top><td><tt>x</tt></td><td>X coordinate to set into rationalPoint4D.</td></tr>
<tr valign=top><td><tt>y</tt></td><td>Y coordinate to set into rationalPoint4D.</td></tr>
<tr valign=top><td><tt>z</tt></td><td>Z coordinate to set into rationalPoint4D.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of rationalPoint4D parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint4D_To3D"></a>
<h3><a name="Q3RationalPoint4D_To3D">Q3RationalPoint4D_To3D</a></h3>
<blockquote><pre><tt>TQ3Point3D * 
Q3RationalPoint4D_To3D (
    const TQ3RationalPoint4D      *rationalPoint4D,
    TQ3Point3D                    *result
);
</tt><br>
</pre></blockquote>
<p>Convert rational 4D point to 3D, dividing by w.
<br><br>
Available in inline form as Q3FastRationalPoint4D_To3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoint4D</tt></td><td>Address of rational 4D point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 3D point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint4D_To4DTransformArray"></a>
<h3><a name="Q3RationalPoint4D_To4DTransformArray">Q3RationalPoint4D_To4DTransformArray</a></h3>
<blockquote><pre><tt>TQ3Status  
Q3RationalPoint4D_To4DTransformArray (
    const TQ3RationalPoint4D      *inRationalPoints4D,
    const TQ3Matrix4x4            *matrix4x4,
    TQ3RationalPoint4D            *outRationalPoints4D,
    TQ3Int32                      numPoints,
    TQ3Uns32                      inStructSize,
    TQ3Uns32                      outStructSize
);
</tt><br>
</pre></blockquote>
<p>Transform an array of 4D points by a 4x4 matrix.
<br><br>
When you have many points to transform, this is a more efficient
alternative to calling Q3RationalPoint4D_Transform repeatedly.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>inRationalPoints4D</tt></td><td>Array of 4D points to transform.</td></tr>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Transformation matrix.</td></tr>
<tr valign=top><td><tt>outRationalPoints4D</tt></td><td>Array of points to receive output (may be the same as inRationalPoints4D).</td></tr>
<tr valign=top><td><tt>numPoints</tt></td><td>How many points are in each array.</td></tr>
<tr valign=top><td><tt>inStructSize</tt></td><td>Size of one element of the input array, typically sizeof(TQ3RationalPoint4D).</td></tr>
<tr valign=top><td><tt>outStructSize</tt></td><td>Size of one element of the output array, typically sizeof(TQ3RationalPoint4D).</td></tr>
</table>
</blockquote>
<b>Result:</b> kQ3Success or some error code.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint4D_ToVector3D"></a>
<h3><a name="Q3RationalPoint4D_ToVector3D">Q3RationalPoint4D_ToVector3D</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3RationalPoint4D_ToVector3D (
    const TQ3RationalPoint4D      *rationalPoint4D,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Convert 4D rational point to 3D vector, discarding w.
<br><br>
Available in inline form as Q3FastRationalPoint4D_ToVector3D.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoint4D</tt></td><td>Address of 4D rational point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 3D vector to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3RationalPoint4D_Transform"></a>
<h3><a name="Q3RationalPoint4D_Transform">Q3RationalPoint4D_Transform</a></h3>
<blockquote><pre><tt>TQ3RationalPoint4D * 
Q3RationalPoint4D_Transform (
    const TQ3RationalPoint4D      *rationalPoint4D,
    const TQ3Matrix4x4            *matrix4x4,
    TQ3RationalPoint4D            *result
);
</tt><br>
</pre></blockquote>
<p>Transform a 4D rational point by a 4x4 matrix.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>rationalPoint4D</tt></td><td>Address of a point to transform.</td></tr>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of a 4x4 transformation matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of point to set (may be the same as rationalPoint4D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Ray3D_IntersectBoundingBox"></a>
<h3><a name="Q3Ray3D_IntersectBoundingBox">Q3Ray3D_IntersectBoundingBox</a></h3>
<blockquote><pre><tt>TQ3Boolean  
Q3Ray3D_IntersectBoundingBox (
    const TQ3Ray3D                *theRay,
    const TQ3BoundingBox          *theBounds,
    TQ3Point3D                    *hitPoint
);
</tt><br>
</pre></blockquote>
<p>Test a ray for intersection against a bounding box. If an
intersection occurs, the point of intersection is returned.
<br><br>
The direction vector of the ray must be normalised.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>theRay</tt></td><td>The ray to test.</td></tr>
<tr valign=top><td><tt>theBounds</tt></td><td>The bounding box to test against.</td></tr>
<tr valign=top><td><tt>hitPoint</tt></td><td>Receives the intersection point, if found.</td></tr>
</table>
</blockquote>
<b>Result:</b> Indicates if the ray intersects the bounding box.
 
<hr>
<a name="//apple_ref/c/func/Q3Ray3D_IntersectSphere"></a>
<h3><a name="Q3Ray3D_IntersectSphere">Q3Ray3D_IntersectSphere</a></h3>
<blockquote><pre><tt>TQ3Boolean  
Q3Ray3D_IntersectSphere (
    const TQ3Ray3D                *theRay,
    const TQ3Sphere               *theSphere,
    TQ3Point3D                    *hitPoint
);
</tt><br>
</pre></blockquote>
<p>Test a ray for intersection against a sphere, and return the point
of intersection if found.
<br><br>
The direction vector of the ray must be normalised.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>theRay</tt></td><td>The ray to test.</td></tr>
<tr valign=top><td><tt>theSphere</tt></td><td>The sphere to test against.</td></tr>
<tr valign=top><td><tt>hitPoint</tt></td><td>Receives the intersection point, if found.</td></tr>
</table>
</blockquote>
<b>Result:</b> Indicates if the ray intersects the sphere.
 
<hr>
<a name="//apple_ref/c/func/Q3Ray3D_IntersectTriangle"></a>
<h3><a name="Q3Ray3D_IntersectTriangle">Q3Ray3D_IntersectTriangle</a></h3>
<blockquote><pre><tt>TQ3Boolean  
Q3Ray3D_IntersectTriangle (
    const TQ3Ray3D                *theRay,
    const TQ3Point3D              *point1,
    const TQ3Point3D              *point2,
    const TQ3Point3D              *point3,
    TQ3Boolean                    cullBackfacing,
    TQ3Param3D                    *hitPoint
);
</tt><br>
</pre></blockquote>
<p>Test a ray for intersection against a triangle formed by three
points. If an intersection occurs, returns the barycentric
coordinates of the point of intersection and the distance along
the ray.
<br><br>
Triangles may optionally be subject to backface culling, in
which case a hit on the reverse side of the triangle will fail
to result in an intersection.
<br><br>
Barycentric coordinates can be used to interpolate the triangle
vertices to obtain the exact point of intersection, like so:
<br><br>
t = (1.0f - hitPoint.u - hitPoint.v);
x = (point1.x * t) + (point2.x * hitPoint.u) + (point3.x * hitPoint.v);
y = (point1.y * t) + (point2.y * hitPoint.u) + (point3.y * hitPoint.v);
z = (point1.z * t) + (point2.z * hitPoint.u) + (point3.z * hitPoint.v);
<br><br>
Similar calculations can be made for vertex normals, UVs, or any
other vertex attribute. The w component of hitPoint is set to the
distance along the ray at which the intersection occurs.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>theRay</tt></td><td>The ray to test.</td></tr>
<tr valign=top><td><tt>point1</tt></td><td>The first triangle vertex.</td></tr>
<tr valign=top><td><tt>point2</tt></td><td>The second triangle vertex.</td></tr>
<tr valign=top><td><tt>point3</tt></td><td>The third triangle vertex.</td></tr>
<tr valign=top><td><tt>cullBackfacing</tt></td><td>Controls if back-facing triangles should be skipped.</td></tr>
<tr valign=top><td><tt>hitPoint</tt></td><td>Receives the barycentric coordinates of the intersection, and the distance along the ray.</td></tr>
</table>
</blockquote>
<b>Result:</b> Indicates if the ray intersects the triangle.
 
<hr>
<a name="//apple_ref/c/func/Q3SphericalPoint_Set"></a>
<h3><a name="Q3SphericalPoint_Set">Q3SphericalPoint_Set</a></h3>
<blockquote><pre><tt>TQ3SphericalPoint * 
Q3SphericalPoint_Set (
    TQ3SphericalPoint             *sphericalPoint,
    float                         rho,
    float                         theta,
    float                         phi
);
</tt><br>
</pre></blockquote>
<p>Set a 3D spherical-coordinates point.
<br><br>
Available in inline form as Q3FastSphericalPoint_Set.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>sphericalPoint</tt></td><td>Address of point to set (may be NULL).</td></tr>
<tr valign=top><td><tt>rho</tt></td><td>Rho coordinate to set into sphericalPoint.</td></tr>
<tr valign=top><td><tt>theta</tt></td><td>Theta coordinate to set into sphericalPoint.</td></tr>
<tr valign=top><td><tt>phi</tt></td><td>Phi coordinate to set into sphericalPoint.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of polarPoint parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3SphericalPoint_ToPoint3D"></a>
<h3><a name="Q3SphericalPoint_ToPoint3D">Q3SphericalPoint_ToPoint3D</a></h3>
<blockquote><pre><tt>TQ3Point3D * 
Q3SphericalPoint_ToPoint3D (
    const TQ3SphericalPoint       *sphericalPoint,
    TQ3Point3D                    *result
);
</tt><br>
</pre></blockquote>
<p>Convert 3D spherical point to cartesian coordinates.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>sphericalPoint</tt></td><td>Address of spherical-coordinates point to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 3D cartesian point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Triangle_CrossProductArray"></a>
<h3><a name="Q3Triangle_CrossProductArray">Q3Triangle_CrossProductArray</a></h3>
<blockquote><pre><tt>TQ3Status  
Q3Triangle_CrossProductArray(
    TQ3Uns32                    numTriangles,
    const TQ3Uns8               *usageFlags,
    const TQ3Uns32              *theIndices,
    const TQ3Point3D            *thePoints,
    TQ3Vector3D                 *theNormals
);
</tt><br>
</pre></blockquote>
<p>Calculate an array of triangle normals.
<br><br>
Triangles are specified as a contiguous array of triangle indices,
and a contiguous array of points. The result is a contiguous array
of triangle normals.
<br><br>
Triangles may be omitted from processing with the usageFlags parameter,
which should point to an array of TQ3Uns8 flags. If usageFlags is not
NULL, only triangles whose corresponding entry in this array is 0 will
be processed.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>numTriangles</tt></td><td>The number of triangles to process.</td></tr>
<tr valign=top><td><tt>usageFlags</tt></td><td>The optional usage flags, indicating the triangles to process.</td></tr>
<tr valign=top><td><tt>theIndices</tt></td><td>The triangle indices.</td></tr>
<tr valign=top><td><tt>thePoints</tt></td><td>The triangle points.</td></tr>
<tr valign=top><td><tt>theNormals</tt></td><td>Receives the triangle normals.</td></tr>
</table>
</blockquote>
<b>Result:</b> Success or failure of the operation.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Add"></a>
<h3><a name="Q3Vector2D_Add">Q3Vector2D_Add</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Vector2D_Add (
    const TQ3Vector2D             *v1,
    const TQ3Vector2D             *v2,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Add two 2D vectors.
<br><br>
Available in inline form as Q3FastVector2D_Add.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>v1</tt></td><td>Address of first vector to add.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of second vector to add.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as v1 and/or v2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Cross"></a>
<h3><a name="Q3Vector2D_Cross">Q3Vector2D_Cross</a></h3>
<blockquote><pre><tt>float  
Q3Vector2D_Cross (
    const TQ3Vector2D             *v1,
    const TQ3Vector2D             *v2
);
</tt><br>
</pre></blockquote>
<p>Return the length of the cross product of two 2D vectors.
<br><br>
Equivalently, we assume that the 2D vectors are really 3D vectors with
z=0, then return the z coordinate of the cross product (0,0,z).
<br><br>
Available in inline form as Q3FastVector2D_Cross.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>v1</tt></td><td>Address of first vector.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of second vector.</td></tr>
</table>
</blockquote>
<b>Result:</b> Length of the 2D cross product.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Dot"></a>
<h3><a name="Q3Vector2D_Dot">Q3Vector2D_Dot</a></h3>
<blockquote><pre><tt>float  
Q3Vector2D_Dot (
    const TQ3Vector2D             *v1,
    const TQ3Vector2D             *v2
);
</tt><br>
</pre></blockquote>
<p>Return the dot product of two 2D vectors.
<br><br>
Available in inline form as Q3FastVector2D_Dot.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>v1</tt></td><td>Address of first vector.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of second vector.</td></tr>
</table>
</blockquote>
<b>Result:</b> Dot product of the two vectors.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Length"></a>
<h3><a name="Q3Vector2D_Length">Q3Vector2D_Length</a></h3>
<blockquote><pre><tt>float  
Q3Vector2D_Length (
    const TQ3Vector2D             *vector2D
);
</tt><br>
</pre></blockquote>
<p>Return length of 2D vector.
<br><br>
Available in inline form as Q3FastVector2D_Length.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of vector to get length of.</td></tr>
</table>
</blockquote>
<b>Result:</b> Length of the given vector.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_LengthSquared"></a>
<h3><a name="Q3Vector2D_LengthSquared">Q3Vector2D_LengthSquared</a></h3>
<blockquote><pre><tt>float  
Q3Vector2D_LengthSquared (
    const TQ3Vector2D             *vector2D
);
</tt><br>
</pre></blockquote>
<p>Return squared length of 2D vector.
<br><br>
For many operations, knowing the squared length of a vector is just
as good as knowing the actual length (e.g., when sorting a set of
vectors by length, or comparing a vector to a cut-off length).  But
finding the squared length is much faster, since it avoids a costly
square root computation.
<br><br>
Available in inline form as Q3FastVector2D_LengthSquared.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of vector to get length of.</td></tr>
</table>
</blockquote>
<b>Result:</b> Squared length of the given vector.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Negate"></a>
<h3><a name="Q3Vector2D_Negate">Q3Vector2D_Negate</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Vector2D_Negate (
    const TQ3Vector2D             *vector2D,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Scale a 2D vector by a factor of -1.
<br><br>
Available in inline form as Q3FastVector2D_Negate.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of vector to negate.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as vector2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Normalize"></a>
<h3><a name="Q3Vector2D_Normalize">Q3Vector2D_Normalize</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Vector2D_Normalize (
    const TQ3Vector2D             *vector2D,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Scale a 2D vector to length 1.
<br><br>
To obtain valid results, the length of vector2D must not be 0.
<br><br>
Available in inline form as Q3FastVector2D_Normalize.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of vector to normalize.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as vector2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Scale"></a>
<h3><a name="Q3Vector2D_Scale">Q3Vector2D_Scale</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Vector2D_Scale (
    const TQ3Vector2D             *vector2D,
    float                         scalar,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Scale a 2D vector by the given factor.
<br><br>
Available in inline form as Q3FastVector2D_Scale.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of vector to scale.</td></tr>
<tr valign=top><td><tt>scalar</tt></td><td>Scaling factor.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as vector2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Set"></a>
<h3><a name="Q3Vector2D_Set">Q3Vector2D_Set</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Vector2D_Set (
    TQ3Vector2D                   *vector2D,
    float                         x,
    float                         y
);
</tt><br>
</pre></blockquote>
<p>Set a 2D vector.
<br><br>
Available in inline form as Q3FastVector2D_Set.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of vector to set (may be NULL).</td></tr>
<tr valign=top><td><tt>x</tt></td><td>X coordinate to set into vector2D.</td></tr>
<tr valign=top><td><tt>y</tt></td><td>Y coordinate to set into vector2D.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of vector2D parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Subtract"></a>
<h3><a name="Q3Vector2D_Subtract">Q3Vector2D_Subtract</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Vector2D_Subtract (
    const TQ3Vector2D             *v1,
    const TQ3Vector2D             *v2,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Subtract 2D vector v2 from v1.
<br><br>
Available in inline form as Q3FastVector2D_Subtract.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>v1</tt></td><td>Address of first vector.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of vector to subtract from v1.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as v1 and/or v2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_To2DTransformArray"></a>
<h3><a name="Q3Vector2D_To2DTransformArray">Q3Vector2D_To2DTransformArray</a></h3>
<blockquote><pre><tt>TQ3Status  
Q3Vector2D_To2DTransformArray (
    const TQ3Vector2D             *inVectors2D,
    const TQ3Matrix3x3            *matrix3x3,
    TQ3Vector2D                   *outVectors2D,
    TQ3Int32                      numVectors,
    TQ3Uns32                      inStructSize,
    TQ3Uns32                      outStructSize
);
</tt><br>
</pre></blockquote>
<p>Transform an array of 2D vectors by a 3x3 matrix.
<br><br>
When you have many vectors to transform, this is a more efficient
alternative to calling Q3Vector2D_Transform repeatedly.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>inVectors2D</tt></td><td>Array of 2D vectors to transform.</td></tr>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Transformation matrix.</td></tr>
<tr valign=top><td><tt>outVectors2D</tt></td><td>Array of vectors to receive output (may be the same as inVectors2D).</td></tr>
<tr valign=top><td><tt>numVectors</tt></td><td>How many vectors are in each array.</td></tr>
<tr valign=top><td><tt>inStructSize</tt></td><td>Size of one element of the input array, typically sizeof(TQ3Vector2D).</td></tr>
<tr valign=top><td><tt>outStructSize</tt></td><td>Size of one element of the output array, typically sizeof(TQ3Vector2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> kQ3Success or some error code.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_To3D"></a>
<h3><a name="Q3Vector2D_To3D">Q3Vector2D_To3D</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector2D_To3D (
    const TQ3Vector2D             *vector2D,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Convert 2D vector to 3D, by setting z to 1.
<br><br>
Note: this operation makes no sense mathematically, but is included
for backward-compatibility with QD3D.  Perhaps the QD3D
implementation was really intended to convert a 2D vector into a 3D
rational point -- see QDPoint2D_To3D, which does exactly that.
<br><br>
Available in inline form as Q3FastVector2D_To3D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of 2D vector to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 3D vector to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_ToRationalPoint3D"></a>
<h3><a name="Q3Vector2D_ToRationalPoint3D">Q3Vector2D_ToRationalPoint3D</a></h3>
<blockquote><pre><tt>TQ3RationalPoint3D * 
Q3Vector2D_ToRationalPoint3D (
    const TQ3Vector2D             *vector2D,
    TQ3RationalPoint3D            *result
);
</tt><br>
</pre></blockquote>
<p>Convert 2D vector to 3D rational point, setting w to 0.
<br><br>
Available in inline form as Q3FastVector2D_ToRationalPoint3D.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of 2D vector to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 3D rational point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector2D_Transform"></a>
<h3><a name="Q3Vector2D_Transform">Q3Vector2D_Transform</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Vector2D_Transform (
    const TQ3Vector2D             *vector2D,
    const TQ3Matrix3x3            *matrix3x3,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Transform a 2D vector by a 3x3 matrix.
<br><br>
Note that the translation and perspective components of the
matrix is ignored (as if it were really a 2x2 matrix).
<br><br>
Contrast with E3Point2D_Transform, which does the full 3x3
transformation.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector2D</tt></td><td>Address of a vector to transform.</td></tr>
<tr valign=top><td><tt>matrix3x3</tt></td><td>Address of a 3x3 transformation matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as vector2D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Add"></a>
<h3><a name="Q3Vector3D_Add">Q3Vector3D_Add</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector3D_Add (
    const TQ3Vector3D             *v1,
    const TQ3Vector3D             *v2,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Add two 3D vectors.
<br><br>
Available in inline form as Q3FastVector3D_Add.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>v1</tt></td><td>Address of first vector to add.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of second vector to add.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as v1 and/or v2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Cross"></a>
<h3><a name="Q3Vector3D_Cross">Q3Vector3D_Cross</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector3D_Cross (
    const TQ3Vector3D             *v1,
    const TQ3Vector3D             *v2,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Return 3D cross product of two 3D vectors.
<br><br>
Available in inline form as Q3FastVector3D_Cross.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>v1</tt></td><td>Address of first vector.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of second vector.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set with the result;
may be the same address as v1 and/or v2.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Dot"></a>
<h3><a name="Q3Vector3D_Dot">Q3Vector3D_Dot</a></h3>
<blockquote><pre><tt>float  
Q3Vector3D_Dot (
    const TQ3Vector3D             *v1,
    const TQ3Vector3D             *v2
);
</tt><br>
</pre></blockquote>
<p>Return the dot product of two 3D vectors.
<br><br>
Available in inline form as Q3FastVector3D_Dot.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>v1</tt></td><td>Address of first vector.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of second vector.</td></tr>
</table>
</blockquote>
<b>Result:</b> Dot product of the two vectors.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_DotArray"></a>
<h3><a name="Q3Vector3D_DotArray">Q3Vector3D_DotArray</a></h3>
<blockquote><pre><tt>TQ3Status  
Q3Vector3D_DotArray(
    TQ3Uns32                    numVectors,
    const TQ3Vector3D           *firstVectors,
    const TQ3Vector3D           *secondVectors,
    float                       *dotProducts,
    TQ3Boolean                  *dotLessThanZero
);
</tt><br>
</pre></blockquote>
<p>Calculate an array of dot products.
<br><br>
Given two arrays of vectors, an array of dot products is returned along
with an array of TQ3Booleans indicating which dot products are less than
zero.
<br><br>
At least one of dotProducts or dotLessThanZero must be non-NULL, however
one parameter may be set to NULL if that information is not required.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>numVectors</tt></td><td>The number of vectors to process.</td></tr>
<tr valign=top><td><tt>firstVectors</tt></td><td>The first set of vectors.</td></tr>
<tr valign=top><td><tt>secondVectors</tt></td><td>The second set of vectors.</td></tr>
<tr valign=top><td><tt>dotProducts</tt></td><td>Receives the dot products.</td></tr>
<tr valign=top><td><tt>dotLessThanZero</tt></td><td>Receives the "< 0.0" status of the dot products.</td></tr>
</table>
</blockquote>
<b>Result:</b> Success or failure of the operation.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Length"></a>
<h3><a name="Q3Vector3D_Length">Q3Vector3D_Length</a></h3>
<blockquote><pre><tt>float  
Q3Vector3D_Length (
    const TQ3Vector3D             *vector3D
);
</tt><br>
</pre></blockquote>
<p>Return length of 2D vector.
<br><br>
Available in inline form as Q3FastVector3D_Length.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of vector to get length of.</td></tr>
</table>
</blockquote>
<b>Result:</b> Length of the given vector.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_LengthSquared"></a>
<h3><a name="Q3Vector3D_LengthSquared">Q3Vector3D_LengthSquared</a></h3>
<blockquote><pre><tt>float  
Q3Vector3D_LengthSquared (
    const TQ3Vector3D             *vector3D
);
</tt><br>
</pre></blockquote>
<p>Return squared length of 2D vector.
<br><br>
For many operations, knowing the squared length of a vector is just
as good as knowing the actual length (e.g., when sorting a set of
vectors by length, or comparing a vector to a cut-off length).  But
finding the squared length is much faster, since it avoids a costly
square root computation.
<br><br>
Available in inline form as Q3FastVector3D_LengthSquared.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of vector to get length of.</td></tr>
</table>
</blockquote>
<b>Result:</b> Squared length of the given vector.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Negate"></a>
<h3><a name="Q3Vector3D_Negate">Q3Vector3D_Negate</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector3D_Negate (
    const TQ3Vector3D             *vector3D,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Scale a 3D vector by a factor of -1.
<br><br>
Available in inline form as Q3FastVector3D_Negate.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of vector to negate.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as vector3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Normalize"></a>
<h3><a name="Q3Vector3D_Normalize">Q3Vector3D_Normalize</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector3D_Normalize (
    const TQ3Vector3D             *vector3D,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Scale a 3D vector to length 1.
<br><br>
To obtain valid results, the length of vector3D must not be 0.
<br><br>
Available in inline form as Q3FastVector3D_Normalize.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of vector to normalize.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as vector3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Scale"></a>
<h3><a name="Q3Vector3D_Scale">Q3Vector3D_Scale</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector3D_Scale (
    const TQ3Vector3D             *vector3D,
    float                         scalar,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Scale a 3D vector by the given factor.
<br><br>
Available in inline form as Q3FastVector3D_Scale.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of vector to scale.</td></tr>
<tr valign=top><td><tt>scalar</tt></td><td>Scaling factor.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as vector3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Set"></a>
<h3><a name="Q3Vector3D_Set">Q3Vector3D_Set</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector3D_Set (
    TQ3Vector3D                   *vector3D,
    float                         x,
    float                         y,
    float                         z
);
</tt><br>
</pre></blockquote>
<p>Set a 3D vector.
<br><br>
Available in inline form as Q3FastVector3D_Set.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of vector to set (may be NULL).</td></tr>
<tr valign=top><td><tt>x</tt></td><td>X coordinate to set into vector3D.</td></tr>
<tr valign=top><td><tt>y</tt></td><td>Y coordinate to set into vector3D.</td></tr>
<tr valign=top><td><tt>z</tt></td><td>Z coordinate to set into vector3D.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of vector3D parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Subtract"></a>
<h3><a name="Q3Vector3D_Subtract">Q3Vector3D_Subtract</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector3D_Subtract (
    const TQ3Vector3D             *v1,
    const TQ3Vector3D             *v2,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Subtract 3D vector v2 from v1.
<br><br>
Available in inline form as Q3FastVector3D_Subtract.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>v1</tt></td><td>Address of first vector.</td></tr>
<tr valign=top><td><tt>v2</tt></td><td>Address of vector to subtract from v1.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as v1 and/or v2).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_To2D"></a>
<h3><a name="Q3Vector3D_To2D">Q3Vector3D_To2D</a></h3>
<blockquote><pre><tt>TQ3Vector2D * 
Q3Vector3D_To2D (
    const TQ3Vector3D             *vector3D,
    TQ3Vector2D                   *result
);
</tt><br>
</pre></blockquote>
<p>Convert 3D vector to 2D, dividing by z.
<br><br>
Note: this operation makes no sense mathematically, but is included
for backward-compatibility with QD3D.  It's possible that the QD3D
function was really intended to convert a 3D rational point to a
2D vector -- see E3RationalPoint3D_To2D, which does the same thing
for a 2D point.
<br><br>
Available in inline form as Q3FastVector3D_To2D.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of 3D vector to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 2D vector to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_To3DTransformArray"></a>
<h3><a name="Q3Vector3D_To3DTransformArray">Q3Vector3D_To3DTransformArray</a></h3>
<blockquote><pre><tt>TQ3Status  
Q3Vector3D_To3DTransformArray (
    const TQ3Vector3D             *inVectors3D,
    const TQ3Matrix4x4            *matrix4x4,
    TQ3Vector3D                   *outVectors3D,
    TQ3Int32                      numVectors,
    TQ3Uns32                      inStructSize,
    TQ3Uns32                      outStructSize
);
</tt><br>
</pre></blockquote>
<p>Transform an array of 3D vectors by a 4x4 matrix.
<br><br>
When you have many vectors to transform, this is a more efficient
alternative to calling Q3Vector3D_Transform repeatedly.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>inVectors3D</tt></td><td>Array of 3D vectors to transform.</td></tr>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Transformation matrix.</td></tr>
<tr valign=top><td><tt>outVectors3D</tt></td><td>Array of vectors to receive output (may be the same as inVectors3D).</td></tr>
<tr valign=top><td><tt>numVectors</tt></td><td>How many vectors are in each array.</td></tr>
<tr valign=top><td><tt>inStructSize</tt></td><td>Size of one element of the input array, typically sizeof(TQ3Vector3D).</td></tr>
<tr valign=top><td><tt>outStructSize</tt></td><td>Size of one element of the output array, typically sizeof(TQ3Vector3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> kQ3Success or some error code.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_ToRationalPoint4D"></a>
<h3><a name="Q3Vector3D_ToRationalPoint4D">Q3Vector3D_ToRationalPoint4D</a></h3>
<blockquote><pre><tt>TQ3RationalPoint4D * 
Q3Vector3D_ToRationalPoint4D (
    const TQ3Vector3D             *vector3D,
    TQ3RationalPoint4D            *result
);
</tt><br>
</pre></blockquote>
<p>Convert 3D vector to 4D rational point, setting w to 0.
<br><br>
Available in inline form as Q3FastVector3D_ToRationalPoint4D.
<br><br>
<em>This function is not available in QD3D.</em>
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of 3D vector to convert.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of 4D rational point to set.</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_Transform"></a>
<h3><a name="Q3Vector3D_Transform">Q3Vector3D_Transform</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector3D_Transform (
    const TQ3Vector3D             *vector3D,
    const TQ3Matrix4x4            *matrix4x4,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Transform a 3D vector by a 4x4 matrix.
<br><br>
Note that the translation and perspective components of the
matrix is ignored (as if it were really a 3x3 matrix).
<br><br>
Contrast with E3Point3D_Transform, which does the full 4x4
transformation.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of a vector to transform.</td></tr>
<tr valign=top><td><tt>matrix4x4</tt></td><td>Address of a 4x4 transformation matrix.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of vector to set (may be the same as vector3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<a name="//apple_ref/c/func/Q3Vector3D_TransformQuaternion"></a>
<h3><a name="Q3Vector3D_TransformQuaternion">Q3Vector3D_TransformQuaternion</a></h3>
<blockquote><pre><tt>TQ3Vector3D * 
Q3Vector3D_TransformQuaternion (
    const TQ3Vector3D             *vector3D,
    const TQ3Quaternion           *quaternion,
    TQ3Vector3D                   *result
);
</tt><br>
</pre></blockquote>
<p>Transform a 3D vector by a quaternion.
<br><br>
Note that for correct results, the quaternion should be normalized.
<br><br>
</p>
<h4>Parameters</h4>
<blockquote>
<table bgcolor="#F0F0FF" border=1 bordercolor=white cellpadding=0 cellspacing=0 width = "90%">
<thead><tr valign=top bgcolor="#C8C8FF"><th align=left>Name</th><th align=left>Description</th></tr></thead>
<tr valign=top><td><tt>vector3D</tt></td><td>Address of a vector to transform.</td></tr>
<tr valign=top><td><tt>quaternion</tt></td><td>Address of a quaternion to transform by.</td></tr>
<tr valign=top><td><tt>result</tt></td><td>Address of a vector to set (may be the same as vector3D).</td></tr>
</table>
</blockquote>
<b>Result:</b> Convenience copy of result parameter.
 
<hr>
<p align=center><font size="-1"><a href="http://www.quesa.org/">Copyright &#169; 1999-2002 Quesa Developers &#151; last updated on 11/17/2002 </a></font></p>
</body></html>
