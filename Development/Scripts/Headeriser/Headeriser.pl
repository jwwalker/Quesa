#!/usr/bin/perl -w
#========================================================================
#   Description:
#       Generates a set of Quesa headers from the glue code.
#
#		Note that only function prototypes are generated by this script,
#		and not types/constants/comments.
#
#		This version of the script assumes we're using these headers
#		primarily for carbon compatibility - and so the prototypes are
#		wrapped in a not-not-in-carbon test: so when we're building for
#		classic Mac OS the prototypes are ignored (and are picked up from
#		the real QD3D headers), but when we're building for carbon the
#		prototypes are compiled (and only types/constants are picked up
#		from the real QD3D headers).
#
#		These headers also require a bit of tweaking before they can be
#		used for Quesa - the platform-specific calls need to be wrapped
#		in their appropriate OS, and the headers need to be merged with
#		the existing Quesa headers (i.e., our extensions to QD3D).
#
#   Author:
#		Dair Grant
#       <mailto:dair@webthing.net>
#
#   Version History
#		1.0  - First release
#------------------------------------------------------------------------
# Imports
#------------------------------------------------------------------------
use strict;





#------------------------------------------------------------------------
# Globals
#------------------------------------------------------------------------
# Constants
my $kDirGlueFiles   = "";
my $kDirHFiles      = "";
my $kTemplateQ3H = <<'Q3_HFILE_TEMPLATE';
/*  NAME:
        QuesaFILE_NAME.h

    DESCRIPTION:
        Quesa public header.

    COPYRIGHT:
        Copyright (c) 1999-2004, Quesa Developers. All rights reserved.

        For the current release of Quesa, please see:

            <http://www.quesa.org/>
        
        Redistribution and use in source and binary forms, with or without
        modification, are permitted provided that the following conditions
        are met:
        
            o Redistributions of source code must retain the above copyright
              notice, this list of conditions and the following disclaimer.
        
            o Redistributions in binary form must reproduce the above
              copyright notice, this list of conditions and the following
              disclaimer in the documentation and/or other materials provided
              with the distribution.
        
            o Neither the name of Quesa nor the names of its contributors
              may be used to endorse or promote products derived from this
              software without specific prior written permission.
        
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
        A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
        CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
        EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
        PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
        PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
        OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    ___________________________________________________________________________
*/
#ifndef QUESA_UPPER_NAME_HDR
#define QUESA_UPPER_NAME_HDR
//=============================================================================
//      Include files
//-----------------------------------------------------------------------------
#include "Quesa.h"

#include "QD3DFILE_NAME.h"





//=============================================================================
//		C++ preamble
//-----------------------------------------------------------------------------
#ifdef __cplusplus
extern "C" {
#endif





//=============================================================================
//      Constants
//-----------------------------------------------------------------------------
// Constants go here





//=============================================================================
//      Types
//-----------------------------------------------------------------------------
// Types go here





//=============================================================================
//      Macros
//-----------------------------------------------------------------------------
// Macros go here





//=============================================================================
//      Function prototypes
//-----------------------------------------------------------------------------
#if defined(CALL_NOT_IN_CARBON) && !CALL_NOT_IN_CARBON

FUNCTION_PROTOTYPES

#endif // defined(CALL_NOT_IN_CARBON) && !CALL_NOT_IN_CARBON





//=============================================================================
//		C++ postamble
//-----------------------------------------------------------------------------
#ifdef __cplusplus
}
#endif

#endif

Q3_HFILE_TEMPLATE





#------------------------------------------------------------------------
# Generate a QuesaFoo.h header file.
#------------------------------------------------------------------------
sub generateQuesaHeader
{


    # Retrieve our parameters
    my ($functionListRef, $cFile) = @_;
	my @functionList = @$functionListRef;



	# Break down the file name
	my $fileName = $cFile;
	$fileName    =~ s/.*QD3D(.*)\.c/$1/;
	$fileName    = "" if ($fileName eq "Main");



	# Generate the source file
	my $theFile = "Quesa$fileName.h";
    open(OUT_FILE, ">$kDirHFiles$theFile") or die("Can't open $theFile for writing: $!\n");



	# Generate the prototype list
	my $thePrototypes = "";

	foreach my $theFunction (@functionList)
		{
		# Find the functions
		if ($theFunction =~ /(\w+ \*?)(\w+)\((.*)\)/)
			{
			# Break them down into type, name, and params
			my $funcReturn = $1;
			my $funcName   = $2;
			my $funcParams = $3;
			   $funcParams = "void" if ($funcParams eq "");



			# Build up the prototype
			$thePrototypes .= "/*\n";
			$thePrototypes .= " *\t$funcName\n";
			$thePrototypes .= " *\t\tDescription of function\n";
			$thePrototypes .= " */\n";
			$thePrototypes .= "Q3_EXTERN_API_C ( $funcReturn )\n";
			$thePrototypes .= "$funcName (\n";



			# Add the parameter list
			my @paramList = split(/,/, $funcParams);
			my $numParams = @paramList;
			my $n         = 1;

			foreach my $param (@paramList)
				{
				# Strip off leading and trailing whitespace
				$param  =~ s/^\s+//;
				$param  =~ s/\s+$//;
				
				
				# If there's anything left, push the variable name over from the type
				if ($param =~ /\s/)
					{
					$param   =~ /(.*)\s+(.*)$/;
					my $type = $1;
					my $name = $2;

					$param  = length($type) < 29 ? pack("A29", $type) : $type;
					$param .= " $name";
					}


				# Append a comman if this isn't the last param
				$param .= "," if ($n != $numParams);


				# Finally, append the param to the list
				$thePrototypes .= "\t$param\n";
				$n++;
				}
	
			$thePrototypes .= ");\n";
			$thePrototypes .= "\n\n\n";
			}
		else
			{
			print "Warning - skipping [$theFunction], not an API call?\n";
			}
		}



	# Prepare the template
	my $theTemplate = $kTemplateQ3H;
	$theTemplate    =~ s/FILE_NAME/$fileName/g;
	$theTemplate    =~ s/UPPER_NAME/\U$fileName/g;
	$theTemplate    =~ s/FUNCTION_PROTOTYPES/$thePrototypes/g;



	# Special case the main header (evil hack!)
	if ($fileName eq "")
		{
		# Remove extra underscore
		$theTemplate =~ s/__QUESA___/__QUESA__/g;
		
		# Remove circular #include file
		$theTemplate =~ s/#include "Quesa.h"\n//;
		}



	# Generate the template and clean up
    print OUT_FILE "$theTemplate";

	close(OUT_FILE);
}





#------------------------------------------------------------------------
# Process a Quesa source file.
#------------------------------------------------------------------------
sub processSource
{


    # Retrieve our parameters
    my ($cFile) = @_;



    # Process the source file
    my @functionList = ();
    my $lastLine     = "";
    
    open(IN_FILE, "$kDirGlueFiles$cFile") or die("Can't open $cFile for reading: $!\n");
 	print "Processing $cFile\n";

    while (defined(my $theLine = <IN_FILE>))
        {
        # Process the line
        if ($theLine =~ /^(Q3|CE)\w+/)
            {
            # Start with the previous line (the return type)
            my $theResult = $lastLine;
            
            
            # Add on the function name+initial params
            $theResult .= $theLine;


            # Keep reading lines until we find the initial brace
			while (not $theLine =~ /^{/)
            	{
            	$theLine = <IN_FILE>;
            	chomp($theLine);

            	$theResult .= $theLine if (not $theLine =~ /^{/);
            	}
            

            # Strip out multiple whitespace, tabs, or newlines
            $theResult =~ s/\s{2,}/ /g;
            $theResult =~ s/[\t\n\r]/ /g;
            
            
            # Push the star for pointers over to the variable name
			$theResult  =~ s/\*\s+/\*/g;


            # Save the function details
            push(@functionList, $theResult);
            }


		# Save the line for next time
		$lastLine = $theLine;
        }

    close IN_FILE;



	# Generate the header file
	generateQuesaHeader(\@functionList, $cFile);



    # Print some stats
    my $numFunctions  = @functionList;

    print "  generated " . @functionList . " API functions\n";

	return($numFunctions);
}





#------------------------------------------------------------------------
# Program entry point
#------------------------------------------------------------------------
# Set up our constants
if ($^O eq "MacOS")
	{
	$kDirGlueFiles   = ":::Source:Core:Glue:";
	$kDirHFiles      = ":Includes:";
	}
else
	{
	$kDirGlueFiles   = "";
	$kDirHFiles      = "";
	}



# Grab the files to process
opendir(DIR, $kDirGlueFiles) || die("Can't open $kDirGlueFiles: $!");
my @fileList = readdir(DIR);
closedir(DIR);



# Process the headers
my $numFunctions   = 0;

foreach my $theFile (@fileList)
	{
	my ($countFunctions) = processSource($theFile) if ($theFile =~ /\.c$/);

	$numFunctions  += $countFunctions  if defined($countFunctions);
	}



# Print some stats
print "\n\n";
print "  Total Functions: $numFunctions API functions\n";
